*********

Welcome to International Project 64!

The goal of International Project 64 is to preserve non-English Commodore 64
related documents in electronic text format that might otherwise cease to
exist with the rapid advancement of computer technology and declining
interest in 8-bit computers on the part of the general population. If you
would like to help by converting C64 related hardcopy documents to
electronic texts please contact the manager of International Project 64,
Peter Karlsson, at pk@abc.se.

Extensive efforts were made to preserve the contents of the original
document. However, certain portions, such as diagrams, program listings, and
indexes may have been either altered or sacrificed due to the limitations of
plain vanilla text. Diagrams may have been eliminated where ASCII-art was
not feasible. Program listings may be missing display codes where
substitutions were not possible. Tables of contents and indexes may have
been changed from page number references to section number references.
Please accept our apologies for these limitations, alterations, and possible
omissions.

Document names are limited to the 8.3 file convention of DOS. The first
characters of the file name are an abbreviation of the original document
name and the language of the etext. The version number of the etext follows
next. After that a letter may appear to indicate the particular source of
the document. Finally, the document is given a
.TXT extension.

The author(s) of the original document and members of International Project
64 make no representations about the accuracy or suitability of this
material for any purpose. This etext is provided "as-is". Please refer to
the warranty of the original document, if any, that may included in this
etext. No other warranties, express or implied, are made to you as to the
etext or any medium it may be on. Neither the author(s) nor the members of
International Project 64 will assume liability for damages either from the
direct or indirect use of this etext or from the distribution of or
modification to this etext. Therefore if you read this document or use the
information herein you do so at your own risk.

*********

The International Project 64 etext of the Swedish edition of the Commodore
64 user's guide, converted to text by Peter Karlsson <pk@abc.se>

C64_SV1.TXT, February 1998, etext #26.

Note from the etexter (in Swedish):

Förlagan för denna text trycktes 1987.

Errata:

5.4 skriver "skriv PEEK (53280) AND 15". Det ska naturligtvis stå PRINT
framför

8.4 skriver om "DIMENSION ERROR". Det ska naturligtvis vara "BAD SUBSCRIPT
ERROR".

8.5 skriver "Matrisen S, för sida", men programmet använder matrisen F.
Detta kommer från den engelska manualen, som har "The array F, for FACE".

BILAGA B skriver filen "DATA FILE", men läser "DATAFIL". Eftersom namnen är
olika kommer det inte fungera.

BILAGA E säger att POKE 53272,29 byter till stora bokstäver, och POKE
53272,31 till små/stora. Det ska vara POKE 53272,21 resp. POKE 53272,23

BILAGA L säger att felmeddelandelistan är komplett, men den saknar ändå
"BREAK", "ILLEGAL DEVICE NUMBER", "MISSING FILE NAME", "OUT OF MEMORY" samt
"RETURN WITHOUT GOSUB".

BILAGA M, under IF...THEN, säger "falskt (>0)", vilket är fel. Rätt uppgift
förekommer några rader nedanför. Under POKE påstår den att adressen är
mellan 0 och 65000. Den övre gränsen ska vara 65535.

BILAGA P listar 54275/54274 för pulslängd för stämma 3. Det ska vara
54289/54288.

*********

Commodore 64 Användarmanual

© Copyright COMMODORE AB, 1985

INNEHÅLLSFÖRTECKNING

[0.] FÖRORD

[1.] INSTALLATION
 [1.1] Uppackning och inkoppling av Commodore 64
 [1.2] Installation
 [1.3] Anslutning av kringutrustning
 [1.4] Handhavande
 [1.5] Färgjustering

[2.] ATT KOMMA IGÅNG
 [2.1] Tangentbordet
 [2.2] Åter till normalläge
 [2.3] Hämta och spara program
 [2.4] PRINT och beräkningar
 [2.5] Prioritetsordning vid beräkningar
 [2.6] Kombinerad utskrift och beräkning

[3.] BÖRJA PROGRAMMERA I BASIC
 [3.1] Nästa steg
 [3.2] Redigeringstips
 [3.3] Variabler
 [3.4] IF...THEN
 [3.5] FOR...TO...NEXT

[4.] AVANCERAD BASIC
 [4.1] Inledning
 [4.2] Enkel animering
 [4.3] INPUT
 [4.4] GET
 [4.5] Slumptal och andra funktioner
 [4.6] Gissningsspel
 [4.7] Ditt kast
 [4.8] Slumptalsgrafik
 [4.9] CHR$- och ASC-funktioner

[5.] AVANCERADE FÄRG- OCH GRAFIKKOMANDON
 [5.1] Färg och grafik
 [5.2] PRINTa färger
 [5.3] Färg CHR$-koder
 [5.4] PEEK och POKE
 [5.5] Skärmgrafik
 [5.6] Skärmminneskarta
 [5.7] Färgminneskarta
 [5.8] Mer studsande bollar

[6.] SPRITEGRAFIK
 [6.1] Introduktion av SPRITES
 [6.2] Skapa SPRITES
 [6.3] Mera information om SPRITES
 [6.4] Binär aritmetik

[7.] SKAPA LJUD
 [7.1] Programmera utan att vara programmerare
 [7.2] Uppbyggnad av ljudprogram
 [7.3] Ljuddemoprogram
 [7.4] Gör musik med Commodore 64
 [7.5] Viktiga ljudkontroller
 [7.6] ADSR och vågforminställningar
 [7.7] ATTACK- och DECAY-inställningar
 [7.8] SUSTAIN/RELEASE-inställningar
 [7.9] Spela ett stycke på Commodore 64
 [7.10] Skapa ljudeffekter
 [7.11] Enkla ljudeffekter du kan prova

[8.] AVANCERAD DATABEHANDLING
 [8.1] READ och DATA
 [8.2] Medelvärde
 [8.3] Indexerade variabler
 [8.4] Dimensionering
 [8.5] Simulerat tärningskast
 [8.6] Tvådimensionella fält

BILAGOR
 [A.] Commodore 64 Tillbehör och mjukvaror
 [B.] Avancerad kassetthantering
 [C.] Commodore 64 BASIC
 [D.] Förkortningar av BASIC-ord
 [E.] Skärmkoder
 [F.] ASCII- och CHR$-koder
 [G.] SKÄRM- och FÄRGMINNESKARTOR
 [H.] Härledda matematiska funktioner
 [I.] Kontaktdon för I/O
 [J.] Program du kan pröva
 [K.] Konvertering av standard-BASIC-program till Commodore 64 BASIC
 [L.] Felmeddelanden
 [O.] SPRITE-registerkarta
 [P.] Commodore 64 ljudkontrollinställning


[0.] FÖRORD

 Gratulerar till ditt val av en av världens bästa datorer, Commodore 64.
Commodore är välkänt som DET VÄNLIGA DATORFÖRETAGET, och en del av därav är
användarvänliga, lättlästa, lättanvända, lättbegripliga bruksanvisningar.
Bruksanvisningen för Commodore 64 är gjord för att ge dig all nödvändig
information för installation, bekanta dig med den och ge dig en enkel och
rolig introduktion i att göra egna program.
 För dem som inte bryr sig om att göra egna program, har all information som
behövs för att använda Commodoreprogram, andra programpaket eller
spelkassetter, lagts först i denna manual. Detta betyder att du inte behöver
söka genom hela boken för att komma igång.
 Låt oss nu se på några intressanta finesser i din Commodore 64. När det
gäller grafik har du till ditt förfogande en av de mest avancerade
bildkretsarna inom mikrodatorindustrin. Vi kallar det SPRITEGRAFIK och det
ger dig möjlighet att forma dina egna bilder i 4 olika färger, precis som de
kan se ut i spelhallarnas videospel. Men detta är inte allt, SPRITEEDITORn
låter dig samtidigt animera i upp till 8 olika bildnivåer. SPRITE-editorn
kommer snart att finnas tillgänlig som mjukvara. Du kan flytta dina
skapelser vart du vill på skärmen, även låta en bild passera en anna
antingen bakom eller framför den andra. Din Commodore 64 tillhandahåller
även med automatiskt kollisionsinformation vilken instruear datorn att följa
dina instruktioner när föremålen träffar varann.
 Din Commodore 64 har inbyggda musik- och ljudeffekter jämförbara med många
välkända musiksyntetisatorer. Denna del av din dator ger dig 3 oberoende
tongeneratorer, vardera med 9 oktaver. Dessutom har du tillgång till 4 olika
vågformer (sågtand, triangel, variabel puls och brus), en programmerbar
ADSR- (attack, decay, sustain, release)-generator, en envelopgenerator,
programmerbar hög-, låg- och bandpassfilter för stämmorna och variabel
resonans och volymkontroll. Om du vill lyssna med proffesionell ljudkvalite,
kan utsignalen anslutas till en HIFI-anläggning.
 När vi nu talar om vad som kan anslutas... din dator kan byggas ut genom en
mängd tillbehör efter hand som dina behov ökar. Du kan bland annat ansluta
bandspelareenhet 1350 eller upp till 5 stycken 1541 flexskiveenheter. Om du
redan har en 1540 kan den uppdateras för anslutning till Commodore 64. Du
kan ansluta en matrisskrivare för att skriva ut dina program, brev, fakturor
mm. Om du vill koppla upp dig till stordatorer och dess databaser kan detta
göras med hjälp av MODEM-kassetten.
 Du kan även montera en svensk teckengenerator i din Commodore 64. I de
programexempel som visas i boken används å, ä och ö, det är dock inte
nödvändigt att montera en svensk teckengenerator för att utföra exemplen.
Enda skillnaden är att de svenska tecknen saknas.
 Lika viktigt som tillgång till kringutrustning är det faktum att denna
bruksanvisning hjälper dig att förstå hur datorer arbetar. Den talar inte om
allt som finns att veta om datroer men anvisar på ett antal skrifter som
behandlar vissa saker mer i detalj. Commodore önskar dig mycket glädje med
din nya Commodore 64. Mycket nöje, men kom ihåg: programmering är inte något
man lär sig på en dag. Ha tålamod med dig själv och gå noggrant genom
bruksanvisningen. Men innan du börjar, ta de få minuter som erfordras för
att fylla i och sända in garantikortet om detta inte redan är gjort. Lycka
till!

COMMODORE
Box 8184
163 08 Spånga


[1.] INSTALLATION

* Uppackning och anslutning av Commodore 64
* Installation
* Direkt video och audio
* Uppstartning
* Färgjustering

[1.1] UPPACKNING OCH ANSLUTNING AV COMMODORE 64

 Följande steg för steg instruktion talar om hur du ansluter Commodore 64
till din TV, Ijudsystem eller monitor och kontrollerar att allt fungerar
tillfredsställande.
 Innan du ansluter något till din dator kontrollera innehållet i
förpackningen. Den ska innehålla följande:

 1. Commodore 64
 2. Transformator
 3. Videokabel
 4. Antennomkopplarebox

 Om något saknas kontrollera med den butik där apparaten köpts.
 Låt oss först ta en titt på de olika anslutningarna på datorn och deras
användning.

                                    /####\--------^--\
                               /####                 |
                          /####                      |
                 ____/####                           |
                /                                    |
               |               ----   ----  __  /-\  |
               |               \--/   \--/  ==  \_/  |
                \________________\___/______/____|__/
                                  \/       /     |
                                  3       2      1



     ___/###\__/##_##_##_##_##_##_##_##_##_##_##_##_##_##_##_##\__
    |-------------------------------------------------------------|
    |                                                             |
    |                                                             |
    |                                                             |
    | +--------------+            /-\  /-\  +------+ +----------+ |
    | |==============|  [=]  O    \_/  \_/  |======| |==========| |
    +-----/------------------/-----\-----\--------\---------\-----+
       /                    /       \      \        \         \
     4                     5         6       7        8         9

 KONTAKTER PÅ SIDAN

 1. Kontakt för kabel från transformatorn.
 2. STRÖMBRYTARE TILL/FRÅN (OBS transformatorn står på även om Commodore 64
    inte används, drag därför ut nätkabeln till transformatorn när datorn ej
    används.
 3. SPELKONTAKTER Vardera spelkontakten är avsedd för JOYSTICK, PADDLE eller
    LJUSPENNA.

 KONTAKTER PÅ BAKSIDAN

 4. KASSETTSLITS för program eller spelkassetter. (ROM)
 5. TV-ANSLUTNING. Denna kontakt levererar både bild och ljudsignal till din
    TV.
 6. AUDIO och VIDEO uttag. Denna kontakt levererar DIREKT AUDIO vilken kan
    anslutas till din HlFI-anläggning och en COMPOSITE VIDEO signal till en
    eventuell TV-monitor.
 7. SERIE I/O. Avsett för direktanslutning av skrivare eller enkelt
    flexskiveminne.
 8. KASSETTBANDSPELARE. En bandspelare typ 1530 kan anslutas här. 
 9. ANVÄNDARPORT. Olika interfacekassetter såsom RS232, MODEM mm. anslutes
    här.

[1.2] INSTALLATION

 Anslut datorn till TV'n så som bilden på sidan 4 [nedan] visar.

                        75 OHM       /---#= +--+-----------------+--+
                       UHF-ANSLUTNING|      |  | /-------------\#|  |
                               +----------+ |  | |             |#|  |
                /-----------#= | handic   | |  | |             |#|  |
                |              +----------+ |  | |             | |  |
                |                 ANTENN-   |  | |             | |  |
        TILL    |               OMKOPPLARE- |  | \-------------/ |  |
     TV-SIGNAL- #                   BOX     +==+=================+==+
       UTTAGET  |
  /------------------------\
 |                          |=---\
 | ####################  ## |    |
 | ####################  ## |    |
 |  ##################   ## |    |
 |    ##############     ## |    |
  \________________________/     |
                                 |
                                 |
                                 |
                               +---+
                               |   | TRANSFORMATOR
                               +---+ 
                                 |


1. Anslut ena ändan av TV-kabeln till TV-signalkontakten på baksidan av din
   Commodore 64. Tryck den rakt in.
2. Anslut den andra ändan av kabeln till antennomkopplingsboxen. Tryck den
   enbart rakt in.
3. Om du har TV-antennkabel, koppla ur den från TV-apparaten.
4. Anslut din TV-antennkabel till den bipackade antennomkopplaren, i uttaget
   märkt ANTENN.
5. Anslut kabeln från antennomkopplaren till TV-apparatens antennuttag.
6. Ställ antennomkopplaren i läge DATOR.
7. Sätt i den runda kontakten från transformatorenheten i det runda uttaget
   närmast datorns nätströmbrytare. Den har ett styrspår varför den enbart
   passar på ett sätt.
8. Anslut transformatorns nätkontakt till vägguttaget.

     ___/###\__/##_##_##_##_##_##_##_##_##_##_##_##_##_##_##_##\__
    |-------------------------------------------------------------|
    |                                                             |
    |                                                             |
    |                                                             |
    | +--------------+            /-\  /-\  +------+ +----------+ |
    | |==============|  [=]  O    \_/  \_/  |======| |==========| |
    +-------------------------------------------------------------+
      DATOR                  ^
                             |    TILL 
                             | TV-SIGNAL-
                             |  KONTAKT
                             |               TV-BAKSIDA
                             |   +-----------------------------+
                             |   |                             |
                   /---------+-------\  TILL 75 OHM            |
                   |         |   |   |    ANTENN-              |
            +-------------+  |   |  (o)   INGÅNG               |
            |      TV     |__/   |                             |
       /----|ANTENN  DATOR|      +-----------------------------+
       |    +-------------+
       |        ANTENN-
       |       OMKOPPLARE


 Commodore 64 är nu korrekt ansluten. Inga ytterligare anslutningar behövs
för att använda din dator tillsammans med TV. Antennomkopplaren ansluter
datorn till TV'n när omkopplaren är i läge "DATOR". Med omkopplaren är i
läge "TV" kan du använda TV'n som vanligt.



[1.3] ANSLUTNING AV KRINGUTRUSTNING

 Då Commodore 64 erbjuder Ijud med Hl-FI-kvalitet kanske du önskar att återge
det genom en Hl-FI-anläggning för att få bästa möjliga Ijud. Dessutom finnes
ut från din dator en standard "COMPOSITE" videosignal, vilken kan anslutas
till en TV-monitor. Detta ger en förbättrad bildkvalitet.
 Detta har gjorts möjligt genom det speciella uttaget på baksidan av
Commodore 64. Den lättaste vägen att få tillgång till dessa signaler är att
använda en standard 5-pin DIN audiokabel, (ingår ej i leveransen). Denna
kabel kopplas direkt till datorns AUDIO/VIDEO kontakt. Två av de fyra
stiften innehåller audio- och videosignalen. Om du önskar kan du tillverka
din egen kabel med hjälp av tabellen i APPENDIX 1.
 Vanligtvis kommer audiosignalen ut genom en svart kabel. Denna kontakt kan
anslutas till AUX ingången på din HlFI-anläggning eller AUDIO IN på en
monitor eller annat videosystem såsom videobandspelare.
 Den vita eller röda kontakten levererar vanligtvis videosignalen. Denna
kopplas direkt till VIDEO IN kontakten på en monitor eller video ingången på
något annat videosystem (Videobandspelare).
 Beroende på tillverkaren av DlN-kabeln kan färgkoden på kontakterna
variera. Använd tabellen i Appendix 1 för att kontrollera kabeln om inte
Ijud eller bild fungerar med den föreslagna inkopplingen.

                   __###__################################__
                  /                                         \
                  |               AUDIO/VIDEO-              |
                  |                 UTGÅNG                  |
                  |-----------------_---_-------------------|
                  | =========  = o | | | |  ===== ========= |
                  +-----------------------------------------+

                                    ^
                                    |

                                   /-\
                                   | |
                                   | |
                                    #
                                    |
                                    |
                                    |
                        TILL AUX-   |
         ____________    INGÅNG     |
        /            \             / \  TILL VIDEO IN
  +----++------------++----+  <-#-/   \-#->  +------------+---+
  |    || ### ====== ||    |                 | /--------\ | O |
  |    || ===  OoooO ||    |                 ||          || = |
  |    ||------------||    |                 ||          || o |
  |    ||  |   |   | ||    |                 | \________/ |   |
  |    ||  |   |   | ||    |                 +------------+---+
  +----++============++----+
                                                 TV-MONITOR
         AUDIO-SYSTEM

 Om du köpt kringutrustning såsom 1541 flexskiveenhet eller 1515 skrivare
kan du ansluta dem nu. Läs bruksanvisningarna för respektive enhet för
korrekt inkoppling.
 Ett komplett system kan se ut som nedan

 [Bild på ett C64-system]


[1.4] UPPSTARTNING

1. Slå på datorn med hjälp av strömbrytaren på sidan. Lampan på fronten
   tänds.
2. Justera din TV för mottagning på kanal 36.
3. Efter några sekunder visas följande på TV-skärmen.


      **** COMMODORE 64 BASIC V2 ****
   64K RAM SYSTEM  38911 BASIC BYTES FREE

   READY.
   _  <----------- MARKÖREN VÄNTAR ATT DU SKA SKRIVA NÅGOT


4. Om din TV har manuell fininställning, justera den för bästa bild.
5. Du kanske också vill justera färgen. Då kan du utnyttja det
   färginställningsförfarande som beskrivs längre fram i boken. Skärmen ska
   vid start vara i huvudsak mörkblå med en ljusblå ram och ljusblå tecken.

 Om du inte får förväntat resultat, kontrollera då samtliga kablar och
kontakter. Följande tabell hjälper dig att finna orsaken:

 FELSÖKNINGSSCHEMA

-----------------------------------------------------------------------
Symtom                   Orsak                  Åtgärd
-----------------------------------------------------------------------
Ingen bild (lampan       Strömbrytaren i OFF    Försäkra dig om att
lyser ej)                                       strömbrytaren är i läge
                                                ON

                         Nätkabeln inte         Kontrollera att
                         ansluten               nätkabeln sitter i
                                                väggkontakten

                         Transformatorn inte    Kontrollera att
                         ansluten               kontakten sitter rätt

                         Säkringen utlöst       Lämna din Commodore 64
                                                till en auktoriserad
                                                återförsäljare för
                                                säkringsbyte

Ingen bild (lampan       TV'n inställd på fel   Kontrollera om det
lyser)                   fel kanal              finns någon bild
                                                omkring kanal 36

                         Fel anslutning till    Datorn ska inkopplas
                         TV                     till UHF-antenn-
                                                anslutningen

Sporadisk bild när       Kassetten gör inte     Stäng av, sätt in
ROMkassett används       kontakt ordentligt     kassetten riktigt och
                                                starta på nytt

Bild utan färg           Dåligt inställd TV     Justera TV'n

Bild med dåliga färger   Felaktigt justerade    Justera
                         färgkontroller på TV'n färgkontrollerna

Bild med högt            TV-volyumkontroll      Justera volymkontrollen
bakgrunsbrus             justerad för hög

Bra bild men svagt ljud  TV-volym för låg       Justera volymkontrollen
-----------------------------------------------------------------------
     
TIPS: Commodore 64 är konstruerad för att användas av alla och envar. Men vi
vet att datoranvändare ibland råkar ut för svårigheter. För att ge svar på
dina frågor och ge dig roliga programidéer har det skrivits en hel del
böcker. Det kan också vara en god idé att gå med i någon dataklubb där andra
Commodore 64 ägare kan hjälpa dig att öka på din kunskap och skicklighet.

 MARKÖREN

 Den blinkande fyrkanten närmast ordet READY kallas MARKÖR eller CURSOR och
indikerar den plats där det du skriver på tangentbordet kommer att skrivas
på skärmen. När du skriver flyttar sig MARKÖREN ett steg till höger
vartefter markörens position ersätts med det tecken du skriver. Prova att
skriva på tangentbordet och se hur bokstäverna du skriver visas på
TV-skärmen.


[1.5] FÄRGINSTÄLLNING

 Det finns ett enkelt sätt att få ett färgmönster på TV-skärmen som kan
användas för färgjustering. Även om du ännu inte är van vid datorn ännu,
följ bara anvisningarna så får du se hur enkelt det är att använda Commodore
64.
 Leta först rätt på tangenten märkt <CTRL>. Den finns i tangentbordets
vänsterkant. CTRL står för kontroll (ConTRoL), och används tillsammans med
andra tangenter för att instruera datorn att utföra en speciell uppgift.

 [Bild på ett C64-tangentbord]

 När en kontrollfunktion ska användas håller man <CTRL> nedtryckt och
trycker därefter på den andra tangenten.
 Prova följande: Håll <CTRL>-tangenten nedtryckt och tryck därefter på
<9>-tangenten. Släpp därefter upp båda tangenterna. Inget påtagligt ska nu
ha hänt, men om någon tangent nu trycks ned kommer skriften på skärmen att
visas omvänd (reverserad). Denna skiljer sig markant från startmeddelandet
eller det du skrivit tidigare.
 Tryck nu ned mellanslagstangenten <SPACE>. Vad händer? Om du gjort
ovanstående korrekt ser du en ljusblått fält röra sig över skärmen och
därefter flytta ned till nästa rad så länge som <SPACE>-tangenten är
nedtryckt.

     **** COMMODORE 64 BASIC V2 ****
  64K RAM SYSTEM  38911 BASIC BYTES FREE

  READY.
  ____________________________
  __________

 Håll nu nu nere <CTRL> under tiden du trycker ned någon annan av
siffertangenterna. De har var sin färg markerad på framsidan. Allt som
skrivs på skärmen från och med nu får den nya färgen. Som exempel, tryck ned
<CTRL> och tangenten <8>. Släpp upp dessa och tryck på <SPACE>.
 Se nu på skärmen. Färgfältet ritas nu gult. På liknande sätt kan du ändra
genom att hålla ned <CTRL> och trycka på respektive siffertangent.
 Ändra färgfälten några gånger och använd sedan denna bild för att justera
din TV så färgerna återges riktigt.
 Skärmen bör se ut ungefär som på bilden:

     **** COMMODORE 64 BASIC V2 ****
  64K RAM SYSTEM  38911 BASIC BYTES FREE

  READY.
  _________________________     <------ <3> Röd balk
  _______ ____________ ____     <------ <6> Grön balk
  __________ ______________     <------ <7> Blå balk
  ____________                  <------ <8> Gul balk

 Nu är allt justerat och fungerar riktigt. De följande kapitels kommer att
introducera programmeringsspråket BASIC. Du kan emellertid omgående börja
använda en del av de många färdiga program som finns till Commodore 64 utan
att känna till något om datorprogrammering.
 Dessa programpaket innehåller vanligtvis detaljerad information hur
programmet ska användas. Vi föreslår emellertid att du läser vidare några
kapitel i denna bok för att bli mer bekant med handhavandet av ditt nya
datorsystem.


[2.] ATT KOMMA IGÅNG

* Tangentbordet
* Åter till normalläge
* LOAD- och SAVE-kommando
* PRINt och beräkningar
* Prioritet vid beräkningar
* Kombinerad utskrift och beräkningar

[2.1] TANGENTBORDET

 Nu när du fått allt justerat och i ordning kan du spendera lite tid på att
bekanta dig med tangentbordet. Detta är ditt viktigaste hjälpmedel vid
kommunikation med din Commodore 64.
 Du kommer att upptäcka att tangentbordet liknar det som finns på vanliga
skrivmaskiner. Det finns dessutom ett antal nya tangenter som kontrollerar
speciella funktioner. Det som följer är en kort beskrivning av de olika
tangenterna och dess funktion. En mer detaljerad genomgång kommer längre
fram i bruksanvisningen

 [Bild på en C64]

<RETURN>

 <RETURN>-tangenten meddelar datorn att studera den information du skrivit
på skärmen och flytta den in i datorns minne.

<SHIFT>

 <SHIFT>-tangenten fungerar på samma sätt som på en vanlig skrivmaskin.
Flertalet tangenter kan skriva 2 bokstäver eller symboler och två grafiska
tecken. I läget "stora/små bokstäver" får du stora bokstäver när
<SHIFT>-tangenten är nedtryckt. I läget "stora bokstäver/grafik" skrivs det
högra grafiska tecknet när <SHIFT>-tangenten trycks ned. När det gäller de
speciella funktionstangenterna, får man med <SHIFT> nedtryckt den funktion
som är markerad på respektive tangents framsida.


 REDIGERING

 Ingen är perfekt och Commodore 64 är noga med detaljerna. Ett antal
redigeringstangenter hjälper dig rätta till skrivfel och flytta runt
information på skärmen.

<CRSR>

 Det finns två tangenter märkta <CRSR> (CuRSoR), en med pilar upp och ned,
den andra med vänster/höger-pilar. Du kan använda dessa tangenter för att
flytta markören upp och ned, vänster och höger. I oskiftat läge flyttar
cursor-tangenterna markören nedåt och åt höger. Med <SHIFT> nedtryckt
flyttar cursor-tangenterna markören upp eller till vänster.
Cursortangenterna har en speciell repeterfunktion som fortsätter
markörflyttningen så länge tangenterna är nedtryckta.

<INST/DEL>

 Om du trycker ned <INST/DEL> flyttar sig markören ett steg till vänster och
skriver över (raderar) det senaste skrivna tecknet. Om markören befinner sig
mitt på en linje raderas tecknet närmas till vänster om markören och tecknen
till höger flyttar efter ett steg och fyller ut tomrummet. <SHIFT> och
<INST/DEL> medger att du kan lägga till tecken på en rad. Om du exempelvis
upptäckt ett skrivfel i början av en raden -- kanske du glömt en del i ett
namn -- kan du använda <CRSR VÄ/HÖ>-tangenten att flytta tillbaka markören
till felet och sedan använda <INST/DEL> för att skapa ett utrymme för
tecknet. Skriv sedan in den saknade bokstaven.

<CLR/HOME>

 <CLR/HOME> flyttar markören till skärmens övre vänstra hörn (home
positionen). Om <SHIFT> trycks ned tillsammans med <CLR/HOME> raderas
dessutom skärmen.

<RESTORE>

 <RESTORE> återställer datorn till utgångsläget du hade innan du förändrade
saker med program eller kommandon. Detta kommer att behandlas noggrannare
längre fram.


 FUNKTIONSTANGENTERNA

De fyra tangenterna till höger på tangentbordet (f1-f8), är
funktionstangenter, vilka du kan programmera att utföra många olika
funktioner.

<CTRL>

 <CTRL> (ConTRoL)-tangenten används för att styra färg och andra speciella
funktioner. <CTRL>-tangenten hålls nedtryckt tillsammans med någon annan
bestämd tangent för att ge en speciell funktion. Du hade möjlighet att prova
<CTRL>-tangenten när du ändrade teckenfärg och när du skapade en "testbild"
vid färginställning av din TV.

<RUN/STOP>

 Vanligtvis avbryts ett BASIC program när <RUN/STOP> tangenten trycks ned.
Den signalerar till datorn att avbryta vad den håller på med. Om <RUN/STOP>
användes tillsammans med <SHIFT> laddas program in från en yttre
kassettstation.

<C=> COMMODORE-TANGENTEN

 <C=>-tangenten används för olika funktioner. I första hand medger den
växling mellan TEXT och GRAFIK-läge.
 När datorn startas är den i stora bokstäver/grafik-läge. Detta betyder att
allt du skriver skrivs ut på skärmen med stora bokstäver. Som vi nämnt
tidigare kommer om <SHIFT> trycks ned samtidigt, det grafiska tecknet som
syns till höger på tangent att skrivas ut.
 Om du nu trycker ned <SHIFT> och <C=>-tangenten ändras skärmen till
stora/små bokstäver-läget. Håller du nu ned <C=>-tangenten och trycker ned
en tangent med grafisk symbol kommer den symbol som finns till vänster på
tangenten att visas på skärmen.
 Dessutom används <C=> -tangenten för att göra en andra färgsats om 8 färger
tillgänglig. Genom att hålla ned <C=>-tangenten och trycka på någon av
siffertangenterna kommer all text därefter att vara i ny färg bestämd av den
tangent du trycker ned. I kapitel 5 finns en lista på de färger som finns
tillgängliga genom respektive tangent.


[2.2] ÅTER TILL NORMALLÄGE

 Nu när du haft möjlighet att bekanta dig med tangentbordet låt oss gå
vidare med några av Commodore 64's övriga möjligheter.
 Om du fortfarande har kvar färgbalkarna på skärmen, vilka vi använde vid
inställningen av TV'ns färgkontroller, tryck ned <SHIFT> och <CLR/HOME>.
Skärmen ska nu vara ren och markören befinna sig i övre vänstra hörnet (home
position).
 Tryck nu samtidigt på <C=> och <7>. Detta återställer textfärgen till
ljusblå. Det återstår en sak till för att komma tillbaka till normalläge.
Tryck ned <CTRL> och <0> (noll inte bokstaven O!). Detta återställer
skärmutskriften till normal. Som du minns, ändrade vi till omvänd
(reverserad) skrift tidigare med <CTRL> och <9> för att göra färgbalkar.
Dessa färgbalkar var i verkligheten reverserade blanktecken (mellanslag). Om
vi hade varit i normalläge och försökt rita färgbalkarna skulle markören
flyttat sig men enbart lämnat tomrum.


TIPS:

 Nu när du har gjort återställningen till normal den svåra vägen ska vi visa
ett enklare sätt. Tryck samtidigt ned:

    <RUN/STOP> och <RESTORE>

 Detta raderar skärmen och återställer datorn till utgångsläget. Om det
finns ett program i datorn kommer detta att lämnas orört. Detta är bra att
känna till speciellt om du sysslar mycket med programmering.
 Om du önskar att återställa apparaten så som om den stängts av och satts på
på nytt, skriv då: SYS64759 och tryck på <RETURN>. Använd detta kommando med
eftertanke! Det kommer att radera ut de program och variabler som vid
tillfället finns i datorn.


[2.3] HÄMTA OCH SPARA PROGRAM

 En av de viktigaste egenskaperna hos Commodore 64 är dess förmåga att hämta
(LOAD) och spara (SAVE) program från och till kassettbandspelare eller
diskettstation.
 Denna egenskap tillåter att du sparar program du skrivit för användning vid
senare tillfälle. Du kan också köpa färdiga program klara att användas till
din Commodore 64.
 Övertyga dig om att eventuell band- eller flexskiveenhet är riktigt
ansluten. Se bruksanvisning som medföljer respektive enhet.


 LOADING (inläsning) AV FÄRDIGA PROGRAM

 För de av er som endast är intresserade av de färdiga program som finns
tillgängliga på plugg-in kassetter, kassettband eller flexskivor. Här följer
hur du ska gå tillväga:

1. PLUGG-IN KASSETTER: Till Commodore 64 finns ett stort antal program och
   spel lagrade i pluggfin kassetter. För att ladda in dessa program, gör
   följande:
   Starta TV'n. Kontrollera att datorn är avstängd. Den måste vara avstängd
   under tiden du sätter in eller tar ur en plugg-in kassett. Om inte kan
   kassetten förstöras! Sätt nu in plugg-in kassetten. Starta datorn.
   Slutligen startas programmet enligt den instruktion som medföljer
   programmet.

2. BANDKASSETTER: Använd 1530 kassettbandspelare och den vanliga
   Ijudkassetten som ingår i programpaketet. Övertyga dig om att bandet är
   helt återspolat till början av första sidan. Skriv därefter LOAD. Datorn
   svarar då: "PRESS PLAY ON TAPE" (tryck på bandspelarens PLAY-tangent).
   Gör nu detta. Skärmen raderas och förblir ren tills dess datorn finner
   början av programmet. Datorn skriver då "FOUND (PROGRAM NAMN" = funnet
   (programnamn). Tryck nu ned <C=>-tangenten. Detta medför att programmet
   läses in i datorns minne. Om du önskar avbryta inläsningen tryck på
   <RUN/STOP>-tangenten.

3. FLEXSKIVOR/DISKETTER: När du använder flexskivor ska dessa stoppas in
   försiktigt, med etiketten uppåt och närmast dig. Lägg märke till ett hack
   i skivhöIjet, (det kan vara täckt av tape). Om du for in skivan rätt är
   detta hack till vänster. Stäng luckan när skivan är helt inne. Skriv nu
   LOAD "PROGRAM NAMN", 8 och tryck därefter på <RETURN>. Du hör nu
   diskettenheten arbeta och på skärmen står det:

  SEARCHING FOR PROGRAM NAME
  LOADING
  READY.
  _


 När datorn skrivit READY och markören tänds ska du skriva RUN. Ditt program
är nu klart att användas.


 HÄMTA PROGRAM FRÅN BAND

 Hämta tillbaka program från band eller skiva är lika enkelt. När det gäller
band: Återspola bandet till början och skriv:

  LOAD "PROGRAM NAMN"

 Om du inte minns programnamnet skriv enbart LOAD och det första programmet
datorn hittar kommer att läsas in i datorns minne. Efter du tryckt på
<RETURN> svarar datorn med:

  PRESS PLAY ON TAPE

 När du tryckt ned PLAY-tangenten raderas skärmen och ramfärgen ändras under
den tid datorn söker efter programmet. När den funnit programmet visar
skärmen:

  FOUND PROGRAM NAMN

 För att verkställa inläsningen av programmet måste du trycka på
<C=>-tangenten. Om du önskar avbryta inläsningen kan du trycka på <RUN/STOP>
När du trycker på Commodore-tangenten ändras kantfärgen under tiden
programmet läses in i datorn.
 Efter inläsningen är avslutad återgår kantfärgen till sin vanliga färg och
markören återkommer.


 HÄMTA PROGRAM FRÅN SKIVA

Att hämta program från flexskiva görs på samma sätt. Skriv:

  LOAD "PROGRAM NAMN",8

Efter du tryckt på <RETURN> börjar flexskivan snurra och skärmen visar:

  SEARCHING FOR PROGRAM NAMN
  LOADING

  READY.
  _

OBS

 När du läser in ett nytt program i datorns minne raderas alla tidigare
instruktioner. Övertyga dig om att det program du tidigare arbetat med är
sparat innan du läser in ett nytt program. Direkt efter att programmet lästs
in i datorns minne, kan det köras (RUN), listas (LIST) eller förändras för
att åter sparas i ny version.


 SPARA PROGRAM PÅ TAPE

Om du efter att ha skrivit ett program önskar spara det på band, skriv:

  SAVE "PROGRAM NAMN"

 "PROGRAM NAME" kan vara en kombination av upp till 16 tecken. Efter att du
tryckt <RETURN> svarar nu datorn:

  PRESS PLAY AND RECORD ON TAPE

 Tryck ned både RECORD och PLAY-tangenterna på bandspelaren. Skärmen raderas
och ramfärgen ändras.
 Efter programmet är sparat på bandet återkommer markören och indikerar att
du kan börja arbeta med ett annat program eller stänga av datorn för en tid.


 SPARA PROGRAM PÅ FLEXSKIVA

Att spara program på flexskiva är ännu enklare. Skriv:

  SAVE "PROGRAM NAMN",8

 Siffran 8 är koden för flexskiveenheten, så du har just talat om för datorn
att du önskar få programmet sparar på flexskiva.
 Efter att du tryckt <RETURN> börjar flexskivan snurra och datorn svarar med:

  SAVING "PROGRAM NAMN"
  OK
  READY.
  _


[2.4] PRINT OCH BERÄKNINGAR

 Nu när vi gått igenom ett antal komplicerade instruktioner som behövs för
att spara de program du vill behålla, låt oss börja att göra några program
du kan spara.
 Försök att skriva följande exakt så som det visas:

  PRINT "COMMODORE 64"     <----- Skriv denna rad och tryck på <RETURN>
  COMMODORE 64            <------ Datorns utskrift

  READY.
  _

 Om du gör ett skrivfel, använd då <INST/DEL>-tangenten för att radera
tecknet närmas till vänster om markören. Du kan radera så många tecken du
önskar.

 Låt oss nu se på vad som hände i exemplet ovan. Först instruerade
(kommenderade) du datorn att skriva (PRINT) det som står innanför
citationstecknen. Genom att trycka ned <RETURN> bad du datorn att verkställa
din instruktion och Commodore 64 skrevs därefter på skärmen.
 När du använder PRINT-kommandot på detta sätt skrivs allt innanför
citationstecknen ut exakt som du skrivit det.
 Om datorn svarar med:

  ?SYNTAX  ERROR

kontrollera om du gjort ett skrivfel eller glömt citationstecken.

 Datorn är pedantisk och förväntar sig instruktioner i exakt förutbestämd
form.
 Men bli inte orolig, kom bara ihåg att skriva i minsta detalj så som visas
i exemplen och ditt samarbete med Commodore 64 kommer att gå bra.
 Kom också ihåg att du kan inte skada datorn genom att skriva på den. Det
bästa sättet att lära BASIC är att prova olika saker och se vad som händer.
 PRINT är ett av de mest användbara och kraftfulla kommandona i
BASIC-språket. Med det kan du visa på skärmen nästan vad du vill inklusive
grafik och svaren på beräkningar.

Prova exempelvis följande. Radera först skärmen genom att trycka ned <SHIFT>
och <CLR/HOME> och skriv (siffran 1 inte bokstaven I):

  PRINT 12 + 12            <----- Skriv denna rad och tryck <RETURN>
  24                      <------ Datorn skrev svaret

  READY.
  _

 Nu har du upptäckt att datorn är en räknemaskin i dess grundläggande form.
Resultatet "24" beräknades och skrevs ut automatiskt. Du kan också utföra
subtraktion, multiplikation, division, exponentiering och avancerad
matematiska funktioner såsom beräkning av kvadratrot mm. Du är inte
begränsad till en enkel beräkning på en enda rad. Mer om detta längre fram.
 Lägg märke till att PRINT-instruktionen uppförde sig annorlunda nu än i det
tidigare exemplet. I detta fallet visades ett värde eller resultat istället
för exakt det meddelande du skrivit in beroende på att citationstecken nu
var utelämnade.


 ADDITION

 Plustecknet (+) betyder addition: vi bad datorn att skriva resultatet av 12
adderat till 12. Andra matematiska beräkningar utförs liknande. Kom ihåg att
alltid trycka på <RETURN>-tangenten efter att du skrivit PRINT och
beräkningen.


 SUBTRAKTION

Vid subtraktion används det vanliga minus (-)-tecknet. Skriv:

  PRINT 12 - 9             <----- Tryck <RETURN>
  3


 MULTIPLIKATION

 Om du önskar multiplicera 12 med 12, använder du asterisken (*) för att
representera multiplikation. Du skriver då:

  PRINT 12 * 12            <----- Tryck <RETURN>
  144


 DIVISION

Division använder den bekanta "/". Exempelvis dividera 144 med 12, skrivs:

  PRINT 144 / 12           <----- Tryck <RETURN>
  12


 EXPONENTIERING

 På ett liknande sätt kan exponentiering utföras. (Detta är detsamma som att
multiplicera ett tal med sig själv ett bestämt antal gånger). Pil upp
(^)-tecknet används för exponentiering.

  PRINT 12 ^ 5
  248832

Detta är detsamma som att skriva:

  PRINT 12 * 12 * 12 * 12 * 12
  248832

TIPS:

 Basic innehåller ett antal genvägar. En sådan genväg är att använda
förkortade BASIC-kommandon. Ett "?" kan exempelvis användas istället för
PRINT. När vi nu går vidare presenteras ett flertal kommandon. Appendix D
visar förkortningarna for dessa och vad som syns på skärmen när du skriver
kommandon i förkortad form.

 Ett sista exempel visar på en annan viktig punkt: flera beräkningar kan
göras på en rad och de kan vara en blandning av olika räknesätt. Du kan
beräkna detta problem:


  ? 3 + 5 - 7 + 2          (Detta '?' ersätter ordet PRINT)
  3

 Vi har visat datorns förmåga att räkna med hjälp av enkla exempel.
Commodore 64 är emellertid kapabel att utföra avsevärt mer komplicerade
beräkningar. Du kan exempelvis addera ett antal stora tal. Pröva följande,
men använd inte komma (,) då får du ett felmeddelande.

  ? 122.45 + 345.78 + 7895.687
  8364.917

 Det ser bra ut. Pröva nu följande:

  ? 12123123.45 + 345.78 + 7895.687
  12131364.9

 Om du tog tid på dig och adderade ovanstående för hand skulle du fått ett
annat resultat.
 Vad är det som händer? Även för en kraftfull dator finns det en begränsning
i hur många siffror den kan hantera. Commodore 64 kan handskas med tal upp
till 10 siffror. När talet skrivs ut visas emellertid endast 9 siffror.
 Därför har talet i vårt exempel rundats av. Commodore 64 rundar av uppåt
när nästa siffra är 5 eller större, och rundar av nedåt då nästa siffra är 4
eller mindre.
 Tal mellan 0.01 och 999 999 999 skrivs ut som vanligt. Tal utanför detta
område skrivs ut i exponentform.
 Exponentform är enbart ett sätt att skriva ut mycket stora eller mycket
stora tal med en siffra och 8 decimaler följt av et E och därför ett tal som
är 10-exponenten av talet.
 Om du skriver:

  ? 123000000000000000
  1.23E+17

 Detta är detsamma som 1.23*10^17 och används för att göra utskriften
hanterbar.
 Det finns en begränsning för hur stora tal datorn kan hantera även vid
exponentiering.

 Största +/- 1.70141183E+38
 Minsta +/- 2.93873588E-39


[2.5] PRIORITET VID BERÄKNINGAR

 Om du försökt utföra en blandad beräkning annat än de vi använt i exempel,
kan det ha inträffat att du fått ett oväntat resultat. Orsaken är att datorn
utför beräkningar i en speciell ordningföljd.
 I denna uppställning:

  20 + 8 / 2

kan man inte säkert veta om svaret ska vara 24 eller 14 utan att veta i
vilken ordningsföljd beräkningen ska utföras. Om du lägger samman 20 och 8
delat med 2 (=4) får du svaret 14. Prova exemplet och se vad du får. Orsaken
att du får 24 är att Commodore 64 utför beräkningar från vänster till höger
enligt följande ordningsföljd:

1: minustecknet indikerande negativa tal
2: exponentiering, vänster till höger
3: multiplikation och division, vänster till höger
4: addition och subtraktion, vänster till höger

 Om man följer denna ordningsföljd för det tidigare exemplet beräknar datorn
divisionen först och därefter additionen varför resultatet blir 24.
 Gör några olika egna problem och se om du kan följa med i beräkningarna och
förutsäga resultatet med räkneföljdsreglerna ovan.
 Det finns också ett enkelt sätt att ändra ordningsföljden vid beräkningar.
Genom att använda parenteser kan man bestämma vilken beräkning som ska
utföras först.
 Om du exempelvis vill dela 35 med 5 plus 2 skriver du:

  ? 35 / 5 + 2
  9

du får 35 delat med 5 med 2 adderat till svaret, vilket inte är vad du
önskade. Försök följande:

  ? 35 / (5 + 2)
  5

 Vad som nu hänt är att datorn utvärderar det som finns inom parenteserna
först. Om det finns parenteser inom parenteser beräknas den innersta
parentesen först.
 Om det finns ett flertal parenteser på en rad, såsom:

  ? (12 + 9) * (6 + 1)
  147

beräknas parenteserna från vänster till höger. Här blir 21 multiplicerat med
7 och resultatet blir 147.


[2.6] KOMBINERAD UTSKRIFT OCH BERÄKNING

 Trots att vi har lagt ned mycket tid i områden som inte verkar särskilt
viktiga, kommer många detaljer att visa sig betydelsefulla när du börjar att
skriva egna program.
 För att ge dig en idé om var de olika sakerna passar in, föreställ dig
följande: Hur kan de två olika typer av PRINT-kommando vi har studerat
användas för att skriva något meningsfullt på skärmen?
 Vi känner ju till att det som skrivs inom citationstecken skriv ut exakt
som det skrevs, och genom att använda matematiska instruktioner kan
beräkningar utföras. Så varför inte kombinera dessa 2 typer av
PRINT-kommando på följande sätt:

  ? "5 * 9 = "; 5 * 9      (Semikolon = inget mellanrum)
  5 * 9 = 45

 Även om detta verkar en aning överflödigt, vad vi har åstadkommit är att
helt enkelt använda båda typerna av PRINT-kommando tillsammans. Den första
delen skriver ut "5*9 = " exakt som det är skrivet. Den andra delen gör den
verkliga beräkningen och skriver ut resultatet, med ett semikolon emellan
för att avskilja meddelandedelen från beräkningsdelen.
 Du måste alltid separera de olika delarna i en blandad PRINT-instruktion
med någon typ av mellantecken. Prova med ett komma istället för semikolon
och se vad som händer.
 För den vetgirige, semikolon orsakar att den senare delen skrivs ut i
direkt anslutning till den tidigare delen. Komma åstadkommer något annat.
Även om det kan användas som separator, sprider det ut utskriften mera. Om
du skriver:

  ? 2,3,4,5,6   <-------------------------------- Tryck <RETURN>
  2            3            4             5
  6

siffrorna skrivs ut över hela raden och ned på nästa rad.
 Commodore 64's skärm är uppdelad i fyra områden med 10 kolumner vardera.
Kommat fabulerar varje resultat i närmast följande lediga tabulatorposition.
Eftersom vi bad datorn skriva ut mer information än vad som får plats på en
rad (vi försökte att få plats med 5 st 10-kolumner på en rad) flyttades den
sista siffran ned till nästa rad.
 Denna grundläggande skillnad mellan komma och semikolon vid uppställning av
PRINT-instruktioner kan med fördel användas för att skapa mera komplicerade
uppställningar; det hjälper oss att skapa sofistikerade resultat mycket
enkelt.


[3.] BÖRJA PROGRAMMERA I BASIC

* Nästa steg
- GOTO
* Redigeringstips
* Variabler
* IF ... THEN
* FOR ... TO ... NEXT


[3.1] NÄSTA STEG

 Hittills har vi utfört enklare uppgifter genom att skriva in en enda rad med
instruktioner i datorn. Efter det att vi tryckt på <RETURN> utfördes den
begärda uppgiften direkt. Detta kallas DlREKT-mod eller KALKYLATOR-mod.
 Men för att kunna utföra något meningsfullt måste vi få datorn att arbeta
med mer än en instruktionsrad. Ett antal instruktioner kombinerade
tillsammans bildar ett PROGRAM, vilket gör att du bättre kan utnyttja
Commodore 64's fulla kapacitet.
 För att se hur enkelt det är att skriva ditt första Commodore 64 program,
pröva följande:

 Radera skärmen genom att haffa ned <SHIFT> och tryck på <CLR/HOME>.
 Skriv NEW och tryck på <RETURN>. (Detta raderar ut eventuella tal som kan
ligga kvar i datorns minne från tidigare experiment).
 Skriv nu följande exakt som det står. (kom ihåg att trycka <RETURN> efter
varje rad).

  10 ?"COMMODORE 64"
  20 GOTO 10
  _

 Skriv nu RUN och tryck <RETURN> -- se vad som händer. Skärmen kommer nu att
fyllas med "COMMODORE 64" i vänsterkanten. När du har sett färdigt tryck på
<RUN/STOP> för att stoppa programmet.

  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  BREAK IN 10
  READY

 Ett antal viktiga begrepp, som introducerades i detta korta program, är
grundläggande för all programmering.
 Lägg märke till att varje instruktionsrad föregicks av ett nummer. Dessa
radnummer talar om för datorn i vilken ordningsföljd de olika
instruktionerna ska utföras. Dessa nummer är också en referenspunkt i den
händelse programmet behöver gå tillbaka till en specifik rad. Radnummer kan
vara vilket som helst heltal mellan 0 och 63999.

  10 PRINT "COMMODORE 64"
  ^    ^
  |    |-- Instruktion
  |
  +------- Radnummer


 Det är god programmeringsteknik att numrera raderna i steg om 10 -- i den
händelse du senare önskar lägga till ytterligare instruktioner. Förutom
PRINT använde vårt program ytterligare ett BASIC-kommando, nämligen GOTO.
Detta instruerar datorn att gå direkt till en bestämd rad och utföra vad som
står där och därefter fortsätta vidare därifrån.

  +--> 10 PRINT "COMMODORE 64"
  |
  +--- 20 GOTO 10

 I vårt exempel skriver programmet meddelandet i rad 10, går till nästa rad
(20), vilket instruerar datorn att gå tillbaka till rad 10 för att skriva
meddelandet en gång till. Detta upprepas hela tiden. Eftersom vi inte givit
programmet någon väg ut ur denna slinga, snurrar programmet runt utan slut
tills dess vi avbryter det utifrån med <RUN/STOP>-tangenten.
 Skriv LIST direkt du har stoppat programmet. Ditt program visas då på
skärmen, som du skrivit det, emedan det finns i datorns minne. Lägg också
märke till att datorn omvandlade ? till PRINT åt dig. Programmet kan nu
ändras, sparas eller köras igen.
 En annan viktig skillnad mellan att skriva in något i direktmod och att
skriva program är att direkt efter datorn utfört instruktionerna och du
raderat skärmen är instruktionerna förlorade om du använt direktmod. Ett
program kan du emellertid alltid få tillbaka genom att skriva LIST.
 När det gäller förkortningar, glöm inte av att datorn kanske inte får plats
med alla instruktioner om du använder för många på en rad.


[3.2] REDIGERINGSTIPS

Om du gör ett fel på en rad har du ett antal korrigeringsmöjligheter.

1. Du kan skriva om en hel rad, och datorn ersätter alltid den gamla raden
   med den nya.

2. En oönskad rad kan raderas genom att skriva radnumret följt av <RETURN>.

3. Du kan också enkelt redigera en rad med hjälp av CRSR-tangenterna och
   redigeringstangenterna.

 Föreställ dig att du gjort ett skrivfel på en av raderna i exemplet. För
att korrigera utan att skriva om hela raden ger följande:
 Skriv LIST. Använd därefter <SHIFT> och <CRSR UPP/NED> tangenterna
tillsammans och flytta markören upp till den rad som behöver ändras.
 CRSR-höger tangenten används for att flytta markaren till det tecken du
vill ändra. Skriv det nya tecknet Över det gamla. Tryck nu på <RETURN> så
ersätter datorn det gamla tecknet med det nya.
 Om du behöver mer utrymme på en rad, ställ markaren där utrymmet behovs och
tryck ned <SHIFT> och <INST/DEL>. samtidigt och du får utrymme for ett
ytterligare tecken. Skriv nu in den information du önskar och tryck
<RETURN>. På liknande sätt kan du ta bort oönskade tecken genom att placera
markaren omedelbart till häger om det tecken som du vill avlägsna och
därefter trycka på <INST/DEL>-tangenten.
 För att övertyga dig om att ändringarna accepterats av datorn, skriv LIST
och det korrigerade programmet visas på skärmen. Radnummer behöver inte
skrivas in i nummerföljd. Datorn lägger dem själv i rätt följd.
 Försök nu att redigera vårt enkla program genom att ändra rad 10 genom att
lägga till ett komma (,) vid slutet av raden så som visas nedan. Glöm inte
att flytta ned markören under rad 20 innan du skriver RUN.

  10 PRINT "COMMODORE 64",


  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  BREAK IN 10
  READY


[3.3] VARIABLER

 Variabler är en av de mest använda egenskaperna hos programspråken, därför
att de kan representera mängder av information som finns i datorn. Att
förstå hur variabler fungerar ger datoranvändandet enklare och tillåter dig
att använda finesser som annars vore omöjliga att utnyttja.
 Föreställ dig ett antal lådor i datorn. Dessa lådor kan användas att
förvara siffervärden eller en rad med bokstäver. Varje låda ska märkas med
ett namn som vi själva väljer. Det namnet kallas variabel och representerar
informationen i lådan. Om vi exempelvis säger:

  10 X% = 15
  20 X = 23.5
  30 X$ = "SUMMAN AV X% + X="

 Datorn skulle kunna representera variablerna på följande sätt:

  X%  15
  X   23.5
  X$  SUMMAN AV X% + X =

 En variabel motsvarar lådan, eller minnesplatsen, där det aktuella värdet av
variabeln lagras. Som du ser kan vi tilldela endera heltal, decimaltal eller
bokstäver till variabler.
 Procenttecknet (%) efter ett variabelnamn betyder att variabeln ska
representera ett heltal mellan 0 och +-32767. Följande är tillåtna namn på
heltalsvariabler:

  A%
  X%
  A1%
  NM%

 Dollartecknet ($) efter ett variabelnamn betyder att variabelnamnet
representerar en textrad (textsträng). Följande är exempel på
strängvariabler

  A$
  X$
  Ml$

 Decimaltalsvariabler följer samma system, med följande exempel:

  A1
  X
  Y
  MI

 När man tilldelar en variabel ett namn måste man komma ihåg: För det
första: en variabel kan ha ett eller två tecken. Det första tecknet måste
vara en bokstav mellan A och Z. Det andra tecknet kan vara en bokstav eller
en siffra. Ett tredje tecken kan användas för att indikera vilken sorts
variabel det gäller (heltals- eller sträng-variabel) % eller $.
 Du kan använda variabelnamn med mer än två bokstäver men endast de två
första används av datorn. Därför är variabelnamn såsom PA och PARTNO samma
och refererar till samma variabel-låda.
 Den sista regeln för variabelnamn är enkel: De får inte innehålla några av
BASIC's reserverade ord såsom GOTO, RUN etc. Se appendix D för en komplett
sammanställning.
 För att se hur variabler kan användas kan du skriva in det program vi
visade tidigare och sedan köra det. Kom ihåg att trycka <RETURN> efter varje
rad.

  10 X% = 15
  20 X = 23.5
  30 X$ = "SUMMAN AV X% + X ="
  40 PRINT "X% = "; X%, "X = "; X
  50 PRINT X$; X% + X

 Om du gjort allt rät har du fått upp följande på din bildskärm.

  RUN
  X% = 15    X = 23.5
  SUMMAN AV X% + XD = 38.5
  READY
  _

 Vi har använt alla de trick vi hittills lärt hur man kan formatera
utskriften på skärmen och skrivit ut summan av de två variablerna.
 På rad 10 och 20 tilldelade vi ett heltalsvärde till X% och ett
flyttalsvärde till X. Rad 40 kombinerar de två typerna av PRINT-kommandon
för att skriva ut ett meddelande och de aktuella variabelnamn- värdena på X%
och X. Rad 50 skriver ut textsträngen med variabelnamnet X$ och summan av X%
och X.
 Lägg märke till att trots att X används som en del i varje variabel, gör %
och $-tecknen variablerna unika så de kan representera olika värden. Men
variabler är ännu mer kraftfulla. Om du ändrar dess värde ersätts det gamla
värdet med det nya i samma låda. Detta tillåter dig att skriva en
instruktion såsom:

  X = X + 1

 Detta kan inte accepteras i normal matematik, men är en mycket vanlig
formulering vid programmering. Det betyder: Tag det aktuella värdet på X,
lägg till ett och lägg tillbaka summan i lådan som representerar X.


[3.4] IF...THEN

 Beväpnade med möjligheten att enkelt uppdatera värde på variabler, kan vi
nu prova ett program som:


  NEW
  10 CT = 0
  20 ?"COMMODORE 64"
  30 CT = CT + 1
  40 IF CT < 5 THEN 20
  50 END

 Vad vi nu gjort är att vi infört två nya BASIC-kommandon, och fått viss
kontroll över det lilla PRINT-program vi introducerade i början av detta
kapitel.
 IF...THEN lägger till vissa förutsättningar för programmet. Det ger att OM
(= IF) ett uttryck är sant DÅ (THEN) ska något utfaras. Om inte uttrycket
är sant utförs nästa programrad.
 Ett antal förutsättningar eller villkor kan ställas upp vid användning av
IF...THEN-kommandona:

  <   Mindre än
  >   Större än
  =   Lika med
  <>  Inte lika med
  >=  Större än eller lika med
  <=  Mindre än eller lika med

 Det är enkelt att använda dessa jämförelser mellan två värden, men de är
ändå överraskande användbara.

       10 CT = 0
  +--> 20 ? "COMMODORE 64"
  |    30 CT = CT + 1
  +-<- 40 IF CT < 5 THEN 20
       |
       V
       50 END

 I detta programexempel har vi gjort en "loop" (slinga) som kräver vissa
förutsättningar genom att säga: IF (om) ett värde är mindre än ett annat
värde THEN (då) ska något utföras.
 Rad 10 sätter värdet på CT till 0. Rad 20 skriver ut meddelandet. Rad 30
ökar värdet på CT med 1. Denna rad räknar upp hur många gånger loopen
genomlöpts. Rad 40 är vår kontrollrad. Om CT är mindre än 5, vilket betyder
att programmet arbetat sig genom loopen mindre än 5 gånger, går programmet
tillbaka till 20 och skriver en gång till. När CT blir lika med 5, det
betyder att "COMMODORE 64" skrivits 5 gånger, går programmet till rad 50.
Rad 50 signalerar till datorn att avsluta programmet.
 Prova nu programmet och se vad vi menar. Genom att ändra CT-gränsen i rad
40 kan du få önskat antal rader utskrivna.
 IF...THEN kan utföra en mängd andra nyttigheter vilka vi visar längre fram.


[3.5] FOR...TO...NEXT

 Det finns en enklare och mer använd väg att utföra vad vi gjorde i det
förra exemplet. Vi kan använda en FOR...TO...NEXT-loop. Studera följande:

  NEW

  10 FOR CT = 1 TO 5
  20 ? "COMMODORE 64"
  30 NEXT CT

  RUN
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64


 Som du ser har programmet blivit kortare och mer rättfram.
 CT startar med värdet 1 på rad 10 Rad 20 utför utskriften. På rad 30 ökas
CT med 1.
 NEXT-kommandot på rad 30 sänder automatiskt programmet tillbaka till rad 10
där FOR delen av FOR...NEXT-instruktionen finns. Detta förlopp fortsätter
till dess att CT når den gräns du skrivit in efter nyckelordet TO, (här 5).
 Variabeln som används i en FOR...NEXT-loop kan ökas med ett värde mindre än
ett, om så önskas.
 Prova följande:

  NEW

  10 FOR NB = 1 TO 10 STEP .5
  20 PRINT NB,
  30 NEXT NB

  RUN
  1          1.5           2             2.5
  3          3.5           4             4.5
  5          5.5           6             6.5
  7          7.5           8             8.5
  9          9.5           10

 Om du skriver in och kör detta program, kommer du att se tal från 1 till
10, med 0.5 steg utskrivna på skärmen.
 Allt vi gjort är att skriva ut de värden NB har när programmet går genom
loopen.
 Du kan även bestämma om variabeln ska öka eller minska. Ersätt rad 10 med
följande:

  10 FOR NB = 10 TO 1 STEP -.5

 och se motsatsen hända, då NB minskar från 10 till 1.



[3.] BÖRJA PROGRAMMERA I BASIC

* Nästa steg
- GOTO
* Redigeringstips
* Variabler
* IF ... THEN
* FOR ... TO ... NEXT


[3.1] NÄSTA STEG

 Hittills har vi utfört enklare uppgifter genom att skriva in en enda rad med
instruktioner i datorn. Efter det att vi tryckt på <RETURN> utfördes den
begärda uppgiften direkt. Detta kallas DlREKT-mod eller KALKYLATOR-mod.
 Men för att kunna utföra något meningsfullt måste vi få datorn att arbeta
med mer än en instruktionsrad. Ett antal instruktioner kombinerade
tillsammans bildar ett PROGRAM, vilket gör att du bättre kan utnyttja
Commodore 64's fulla kapacitet.
 För att se hur enkelt det är att skriva ditt första Commodore 64 program,
pröva följande:

 Radera skärmen genom att haffa ned <SHIFT> och tryck på <CLR/HOME>.
 Skriv NEW och tryck på <RETURN>. (Detta raderar ut eventuella tal som kan
ligga kvar i datorns minne från tidigare experiment).
 Skriv nu följande exakt som det står. (kom ihåg att trycka <RETURN> efter
varje rad).

  10 ?"COMMODORE 64"
  20 GOTO 10
  _

 Skriv nu RUN och tryck <RETURN> -- se vad som händer. Skärmen kommer nu att
fyllas med "COMMODORE 64" i vänsterkanten. När du har sett färdigt tryck på
<RUN/STOP> för att stoppa programmet.

  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  BREAK IN 10
  READY

 Ett antal viktiga begrepp, som introducerades i detta korta program, är
grundläggande för all programmering.
 Lägg märke till att varje instruktionsrad föregicks av ett nummer. Dessa
radnummer talar om för datorn i vilken ordningsföljd de olika
instruktionerna ska utföras. Dessa nummer är också en referenspunkt i den
händelse programmet behöver gå tillbaka till en specifik rad. Radnummer kan
vara vilket som helst heltal mellan 0 och 63999.

  10 PRINT "COMMODORE 64"
  ^    ^
  |    |-- Instruktion
  |
  +------- Radnummer


 Det är god programmeringsteknik att numrera raderna i steg om 10 -- i den
händelse du senare önskar lägga till ytterligare instruktioner. Förutom
PRINT använde vårt program ytterligare ett BASIC-kommando, nämligen GOTO.
Detta instruerar datorn att gå direkt till en bestämd rad och utföra vad som
står där och därefter fortsätta vidare därifrån.

  +--> 10 PRINT "COMMODORE 64"
  |
  +--- 20 GOTO 10

 I vårt exempel skriver programmet meddelandet i rad 10, går till nästa rad
(20), vilket instruerar datorn att gå tillbaka till rad 10 för att skriva
meddelandet en gång till. Detta upprepas hela tiden. Eftersom vi inte givit
programmet någon väg ut ur denna slinga, snurrar programmet runt utan slut
tills dess vi avbryter det utifrån med <RUN/STOP>-tangenten.
 Skriv LIST direkt du har stoppat programmet. Ditt program visas då på
skärmen, som du skrivit det, emedan det finns i datorns minne. Lägg också
märke till att datorn omvandlade ? till PRINT åt dig. Programmet kan nu
ändras, sparas eller köras igen.
 En annan viktig skillnad mellan att skriva in något i direktmod och att
skriva program är att direkt efter datorn utfört instruktionerna och du
raderat skärmen är instruktionerna förlorade om du använt direktmod. Ett
program kan du emellertid alltid få tillbaka genom att skriva LIST.
 När det gäller förkortningar, glöm inte av att datorn kanske inte får plats
med alla instruktioner om du använder för många på en rad.


[3.2] REDIGERINGSTIPS

Om du gör ett fel på en rad har du ett antal korrigeringsmöjligheter.

1. Du kan skriva om en hel rad, och datorn ersätter alltid den gamla raden
   med den nya.

2. En oönskad rad kan raderas genom att skriva radnumret följt av <RETURN>.

3. Du kan också enkelt redigera en rad med hjälp av CRSR-tangenterna och
   redigeringstangenterna.

 Föreställ dig att du gjort ett skrivfel på en av raderna i exemplet. För
att korrigera utan att skriva om hela raden ger följande:
 Skriv LIST. Använd därefter <SHIFT> och <CRSR UPP/NED> tangenterna
tillsammans och flytta markören upp till den rad som behöver ändras.
 CRSR-höger tangenten används for att flytta markaren till det tecken du
vill ändra. Skriv det nya tecknet Över det gamla. Tryck nu på <RETURN> så
ersätter datorn det gamla tecknet med det nya.
 Om du behöver mer utrymme på en rad, ställ markaren där utrymmet behovs och
tryck ned <SHIFT> och <INST/DEL>. samtidigt och du får utrymme for ett
ytterligare tecken. Skriv nu in den information du önskar och tryck
<RETURN>. På liknande sätt kan du ta bort oönskade tecken genom att placera
markaren omedelbart till häger om det tecken som du vill avlägsna och
därefter trycka på <INST/DEL>-tangenten.
 För att övertyga dig om att ändringarna accepterats av datorn, skriv LIST
och det korrigerade programmet visas på skärmen. Radnummer behöver inte
skrivas in i nummerföljd. Datorn lägger dem själv i rätt följd.
 Försök nu att redigera vårt enkla program genom att ändra rad 10 genom att
lägga till ett komma (,) vid slutet av raden så som visas nedan. Glöm inte
att flytta ned markören under rad 20 innan du skriver RUN.

  10 PRINT "COMMODORE 64",


  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  COMMODORE   COMMODORE   COMMODORE   COMMODORE
  BREAK IN 10
  READY


[3.3] VARIABLER

 Variabler är en av de mest använda egenskaperna hos programspråken, därför
att de kan representera mängder av information som finns i datorn. Att
förstå hur variabler fungerar ger datoranvändandet enklare och tillåter dig
att använda finesser som annars vore omöjliga att utnyttja.
 Föreställ dig ett antal lådor i datorn. Dessa lådor kan användas att
förvara siffervärden eller en rad med bokstäver. Varje låda ska märkas med
ett namn som vi själva väljer. Det namnet kallas variabel och representerar
informationen i lådan. Om vi exempelvis säger:

  10 X% = 15
  20 X = 23.5
  30 X$ = "SUMMAN AV X% + X="

 Datorn skulle kunna representera variablerna på följande sätt:

  X%  15
  X   23.5
  X$  SUMMAN AV X% + X =

 En variabel motsvarar lådan, eller minnesplatsen, där det aktuella värdet av
variabeln lagras. Som du ser kan vi tilldela endera heltal, decimaltal eller
bokstäver till variabler.
 Procenttecknet (%) efter ett variabelnamn betyder att variabeln ska
representera ett heltal mellan 0 och +-32767. Följande är tillåtna namn på
heltalsvariabler:

  A%
  X%
  A1%
  NM%

 Dollartecknet ($) efter ett variabelnamn betyder att variabelnamnet
representerar en textrad (textsträng). Följande är exempel på
strängvariabler

  A$
  X$
  Ml$

 Decimaltalsvariabler följer samma system, med följande exempel:

  A1
  X
  Y
  MI

 När man tilldelar en variabel ett namn måste man komma ihåg: För det
första: en variabel kan ha ett eller två tecken. Det första tecknet måste
vara en bokstav mellan A och Z. Det andra tecknet kan vara en bokstav eller
en siffra. Ett tredje tecken kan användas för att indikera vilken sorts
variabel det gäller (heltals- eller sträng-variabel) % eller $.
 Du kan använda variabelnamn med mer än två bokstäver men endast de två
första används av datorn. Därför är variabelnamn såsom PA och PARTNO samma
och refererar till samma variabel-låda.
 Den sista regeln för variabelnamn är enkel: De får inte innehålla några av
BASIC's reserverade ord såsom GOTO, RUN etc. Se appendix D för en komplett
sammanställning.
 För att se hur variabler kan användas kan du skriva in det program vi
visade tidigare och sedan köra det. Kom ihåg att trycka <RETURN> efter varje
rad.

  10 X% = 15
  20 X = 23.5
  30 X$ = "SUMMAN AV X% + X ="
  40 PRINT "X% = "; X%, "X = "; X
  50 PRINT X$; X% + X

 Om du gjort allt rät har du fått upp följande på din bildskärm.

  RUN
  X% = 15    X = 23.5
  SUMMAN AV X% + XD = 38.5
  READY
  _

 Vi har använt alla de trick vi hittills lärt hur man kan formatera
utskriften på skärmen och skrivit ut summan av de två variablerna.
 På rad 10 och 20 tilldelade vi ett heltalsvärde till X% och ett
flyttalsvärde till X. Rad 40 kombinerar de två typerna av PRINT-kommandon
för att skriva ut ett meddelande och de aktuella variabelnamn- värdena på X%
och X. Rad 50 skriver ut textsträngen med variabelnamnet X$ och summan av X%
och X.
 Lägg märke till att trots att X används som en del i varje variabel, gör %
och $-tecknen variablerna unika så de kan representera olika värden. Men
variabler är ännu mer kraftfulla. Om du ändrar dess värde ersätts det gamla
värdet med det nya i samma låda. Detta tillåter dig att skriva en
instruktion såsom:

  X = X + 1

 Detta kan inte accepteras i normal matematik, men är en mycket vanlig
formulering vid programmering. Det betyder: Tag det aktuella värdet på X,
lägg till ett och lägg tillbaka summan i lådan som representerar X.


[3.4] IF...THEN

 Beväpnade med möjligheten att enkelt uppdatera värde på variabler, kan vi
nu prova ett program som:


  NEW
  10 CT = 0
  20 ?"COMMODORE 64"
  30 CT = CT + 1
  40 IF CT < 5 THEN 20
  50 END

 Vad vi nu gjort är att vi infört två nya BASIC-kommandon, och fått viss
kontroll över det lilla PRINT-program vi introducerade i början av detta
kapitel.
 IF...THEN lägger till vissa förutsättningar för programmet. Det ger att OM
(= IF) ett uttryck är sant DÅ (THEN) ska något utfaras. Om inte uttrycket
är sant utförs nästa programrad.
 Ett antal förutsättningar eller villkor kan ställas upp vid användning av
IF...THEN-kommandona:

  <   Mindre än
  >   Större än
  =   Lika med
  <>  Inte lika med
  >=  Större än eller lika med
  <=  Mindre än eller lika med

 Det är enkelt att använda dessa jämförelser mellan två värden, men de är
ändå överraskande användbara.

       10 CT = 0
  +--> 20 ? "COMMODORE 64"
  |    30 CT = CT + 1
  +-<- 40 IF CT < 5 THEN 20
       |
       V
       50 END

 I detta programexempel har vi gjort en "loop" (slinga) som kräver vissa
förutsättningar genom att säga: IF (om) ett värde är mindre än ett annat
värde THEN (då) ska något utföras.
 Rad 10 sätter värdet på CT till 0. Rad 20 skriver ut meddelandet. Rad 30
ökar värdet på CT med 1. Denna rad räknar upp hur många gånger loopen
genomlöpts. Rad 40 är vår kontrollrad. Om CT är mindre än 5, vilket betyder
att programmet arbetat sig genom loopen mindre än 5 gånger, går programmet
tillbaka till 20 och skriver en gång till. När CT blir lika med 5, det
betyder att "COMMODORE 64" skrivits 5 gånger, går programmet till rad 50.
Rad 50 signalerar till datorn att avsluta programmet.
 Prova nu programmet och se vad vi menar. Genom att ändra CT-gränsen i rad
40 kan du få önskat antal rader utskrivna.
 IF...THEN kan utföra en mängd andra nyttigheter vilka vi visar längre fram.


[3.5] FOR...TO...NEXT

 Det finns en enklare och mer använd väg att utföra vad vi gjorde i det
förra exemplet. Vi kan använda en FOR...TO...NEXT-loop. Studera följande:

  NEW

  10 FOR CT = 1 TO 5
  20 ? "COMMODORE 64"
  30 NEXT CT

  RUN
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64
  COMMODORE 64


 Som du ser har programmet blivit kortare och mer rättfram.
 CT startar med värdet 1 på rad 10 Rad 20 utför utskriften. På rad 30 ökas
CT med 1.
 NEXT-kommandot på rad 30 sänder automatiskt programmet tillbaka till rad 10
där FOR delen av FOR...NEXT-instruktionen finns. Detta förlopp fortsätter
till dess att CT når den gräns du skrivit in efter nyckelordet TO, (här 5).
 Variabeln som används i en FOR...NEXT-loop kan ökas med ett värde mindre än
ett, om så önskas.
 Prova följande:

  NEW

  10 FOR NB = 1 TO 10 STEP .5
  20 PRINT NB,
  30 NEXT NB

  RUN
  1          1.5           2             2.5
  3          3.5           4             4.5
  5          5.5           6             6.5
  7          7.5           8             8.5
  9          9.5           10

 Om du skriver in och kör detta program, kommer du att se tal från 1 till
10, med 0.5 steg utskrivna på skärmen.
 Allt vi gjort är att skriva ut de värden NB har när programmet går genom
loopen.
 Du kan även bestämma om variabeln ska öka eller minska. Ersätt rad 10 med
följande:

  10 FOR NB = 10 TO 1 STEP -.5

 och se motsatsen hända, då NB minskar från 10 till 1.


[4.] AVANCERAD BASIC

* Introduktion
* Enkel animering
* Trådade loopar
* INPUT
* GET
* Slumptal och andra funktioner
* Gissningsspel
* Ditt kast
* Slumptals-grafik
* CHR$- och ASC-funktioner


[4.1] INLEDNING

 De närmast följande kapitlen har skrivits för dig som är relativt van vid
programspråket BASIC och dess begrepp, vilket är nödvändigt för att första
dessa mer avancerade program.
 För de av er som just börjat lära programmering, kommer viss information att
vara något för teknisk att förstås fullständigt. Bli nu inte orolig... det
finns nämligen två roliga kapitel: SPRITE-grafik och SKAPA LJUD där vi
gjort enkla exempel som är skrivna för nybörjare. Exemplen kommer att ge
dig en god uppfattning om hur man använder Commodore 64's rika möjligheter
att skapa sofistikerade ljud och bildprogram.
 Om du beslutar att lära dig mer om hur man skriver program i BASIC, finns
det lämplig litteratur i ämnet.


[4.2] ENKEL ANIMERING

 Låt oss öva på några av Commodore 64's grafiska egenskaper genom att
utnyttja det vi visat tidigare tillsammans med några nya begrepp. Om du är
intresserad kan du skriva in följande program och se vad som händer. Du
kommer att upptäcka att inom PRINT-instruktioner kan vi också använda
markörstyrnings- och skärmkommandon. När du ser något liknande (CRSR
vänster) i en programlista, tryck ned <SHIFT>-tangenten och tryck på
CRSR-tangenten. Bildskärmen visar då det grafiska tecknet för
markörförflyttning ett steg vänster (två reverserade vertikala balkar). På
samma sätt visas, om man trycker <SHIFT> och <CLR/HOME>, ett reverserat
hjärta.

  NEW

start tok64 SID43.prg
10 REM studsande boll
20 PRINT"{clear}":REM shift+clear/home
25 FOR x = 1 TO 10 : PRINT"{down}" :NEXT
26 REM "{down}"=crsr-ned
30 FOR bl=1 TO 40
40 PRINT" Q{left}"; :REM "Q"=shift+q
41 REM "{left}"=crsr-vanster
50 FOR tm = 1 TO 5
60 NEXT tm
70 NEXT bl
75 REM flytta bollen hoger-vanster
80 FOR bl = 40 TO 1 STEP -1
90 PRINT " {left*2}Q{left}";:REM crsr-vanster,crsr-vanster,shift+q,crsr-vanster
100 FOR tm = 1 TO 5
110 NEXT tm
120 NEXT bl
130 GOTO 20
stop tok64

ANM: ':' på rad 25 indikerar ny instruktion. Mellanrummen på rad 40 och 90
är avsiktliga.

TIPS: Alla ord i denna text skrivs ut i en följd. Så länge som du inte
trycker på <RETURN> kommer Commodore 64 automatiskt att vid radslut byta
till nästa rad även mitt i ett ord.

 Detta program visar en studsande boll som rör sig fram och tillbaka Över
skärmen.
 Om vi studerar programmet noga, (se nedan) kan du se hur detta utfördes..

       10 REM studsande boll
+----> 20 PRINT"{clear}":REM shift+clear/home
|      25 FOR x = 1 TO 10 : PRINT"{down}" :NEXT
|      26 REM "{down}"=crsr-ned
| +--> 30 FOR bl=1 TO 40
| |    40 PRINT" Q{left}"; :REM "Q"=shift+q
| |    41 REM "{left}"=crsr-vanster
| | +> 50 FOR tm = 1 TO 5
| | +- 60 NEXT tm
| +--- 70 NEXT bl
|      75 REM flytta bollen hoger-vanster
| +--> 80 FOR bl = 40 TO 1 STEP -1
| |    90 PRINT " {left*2}Q{left}";:REM crsr-vanster,crsr-vanster,
| |    shift+q,crsr-vanster
| | +> 100 FOR tm = 1 TO 5
| | +- 110 NEXT tm
| +--- 120 NEXT bl
+----- 130 GOTO 20

 Rad 10 är en REMark (kommentar) som enbart berättar vad programmet gör. Den
har ingen inverkan på det egentliga programmet. Rad 20 raderar skärmen på
all information.
 Rad 25 skriver 10 st markör-nedåt kommando. Detta styr bollen till mitten
av skärmen. Om rad 25 utelämnas skulle bollen röra sig över översta raden på
skärmen.
 Rad 30 startar en loop (slinga) för att flytta bollen 40 kolumner från
vänster till höger.
 Rad 40 utför en hel del. Först skrivs ett mellanslag för att radera den
tidigare bollpositionen, därefter skrivs bollen ut och slutligen utförs
markör vänster-förflyttning för att förbereda nästa radering av
bollpositionen.
 Slingan, som startas i rad 50 och 60, minskar bollens hastighet genom att
fördröja programmet. Utan fördröjning skulle bollen röra sig för fort för
att synas.
 Rad 70 avslutar slingan, som ritar bollen på skärmen, vilken startade på
rad 30.
 Varje gång som slingan genomlöps flyttas bollen ytterligare ett steg till
höger. Som du ser av illustrationen har vi åstadkommit en slinga inom en
annan. Detta kallas en kapslad slinga (nested loop).
 Detta accepteras av datorn. Den enda gång du får problem är när slingorna
korsar varann. Vi rekommenderar att du kontrollerar program med flertal
slingor på detta sätt.
 För att se vad som händer om du korsar två slingor, byt instruktionerna på
rad 60 och 70. Du kommer att få felindikering (error) då datorn blir
förvirrad och inte kan för stå vad som händer.
 Rad 80 till 120 gör samma sak som i första delen av programmet men med
omvänd funktion. Bollen flyttas nu från höger till vänster. Rad 90 är lätt
förändrad jämfört med rad 40 eftersom bollen ska röras i motsatt riktning
(vi måste radera bollen till höger och flytta åt vänster).
 När allt detta är utfart ger programmet tillbaka till rad 20 och startar om
på nytt. Ganska händigt!
 En variant på programmet kan erhållas om du ändrar rad 40 enligt följande:

40 PRINT "O" <-- För att åstadkomma O håll ned SHIT och tryck på bokstaven
                 Q.

kör programmet och se vad som händer. Eftersom vi utelämnade
markörkontrollerna kommer alla bollarna att bli kvar på skärmen tills dess
de raderas av bollen när den rör sig från höger till vänster i andra delen
av programmet.


[4.3] INPUT

 Allt inom ett program har hittills varit bestämt innan det körts. När
programmet väl var startat kunde inget ändras. INPUT tillåter dig att
förmedla information under tiden programmet körs. Programmet kan alltså
bearbeta eller reagera på den nya informationen under körning.
 För att du ska få en idé om hur INPUT arbetar, skriv NEW och skriv in detta
korta program:

  10 INPUT A$
  20 PRINT "DU SKREV: ";A$
  30 PRINT
  40 GOTO10

  RUN
  ? COMMODORE 64  <--------------- Du skrev
  DU SKREV: COMMODORE 64    <----- Datorn svarade

 Vad som händer när du kör detta korta program är enkelt. Ett frågetecken
visar sig. Detta indikerar att datorn väntar att du ska skriva in något.
Skriv vilket som helst tecken eller grupp av tecken och tryck <RETURN>.
Datorn kommer att svara med "DU SKREV:" följt av det du skrev in. Detta kan
verka mycket elementärt men föreställ dig vad du kan få datorn att göra med
information du skriver in.
 Du kan använda INPUT för numeriska värden eller textsträngar och även få
INPUT-kommandot att skriva ut ett meddelande till användaren. INPUT skrivs i
följande form:

  INPUT "MEDDELANDE"; VARIABEL
         ^
         +---- Meddelande måste vara mindre än 40 tecken!

Eller enbart:

  INPUT VARIABEL

OBS. För att avbryta detta program tryck på <RUN/STOP> och <RESTOR>
samtidigt.

 Följande är inte endast användbart, utan demonstrerar dessutom en hel del
av vad som presenterats tidigare, inklusive det nya INPUT-kommandot.

  NEW

start tok64 SID46.prg
1 REM temperatur-omvandlings-program
5 PRINT "{clear}" : REM shift+clr home
10 PRINT "omvandla fran farenheit eller celsius":INPUT "(f/c)";a$
20 IF a$ = "" THEN 5
30 IF a$ = "f" THEN 100
40 IF a$ <> "c" THEN 10
50 INPUT "antal grader celsius: "; c
60 f = (c*9)/5+32
70 PRINT c ; "grad. celsius ="; f;"grad. farenheit"
80 PRINT
90 GOTO 10
100 INPUT "antal grader fahrenheit: "; f
110 c = (f-32)*5/9
120 PRINT f ; "grad. farenheit ="; c; "grad. celsius"
130 PRINT
140 GOTO 10
stop tok64

ANM: Inget mellanslag mellan citationstecknen på rad 20. Glöm inte trycka
RETURN efter raderna.

 Om du skriver in och kör detta program får du se INPUT-kommandot i aktion.
 Rad 10 använder INPUT-kommandot inte enbart för att hämta information utan
också för att skriva ut ett uppmanande meddelande. Lägg också märke till att
vi kan fråga efter antingen ett siffervärde eller en textsträng (genom att
använda numerisk eller sträng-variabel).
 Raderna 20, 30 och 40 gör vissa kontroller av vad som skrivits in. På rad
20, om inget skrivits in men RETURN tryckts, återgår programmet till rad 10
och begär ny inskrift. På rad 30, om F är inskrivet, vet vi att användaren
önskar få en temperatur i Fahrenheit omvandlad till Celsius, varför
programmet grenas av till den del som utför denna omvandling.
 Rad 40 gör ytterligare en kontroll. Vi vet att det finns enbart två giltiga
val som användaren kan skriva in. For att komma till rad 40 måste användaren
skrivit ett tecken annat än F. Nu görs en koll om tecknet är C, om inte
begär programmet en ny INPUT.
 Detta verkar vara en massa detaljer, men är god programmeringspraxis. En
användare som inte är van vid programmet kan bli mycket irriterad om
programmet gör något oväntat beroende på inmatningsfel.
 Så fort vi bestämt vilken typ av omvandling vi Önskar, utförs beräkningen
av programmet och datorn skriver ut den inskriva temperaturen tillsammans
med den omvandlade temperaturen.
 Beräkningen är enbart vanlig matematik, med användning av den kända formeln
för temperaturomvandling. Efter att beräkningen och utskriften är klar
hoppar programmet tillbaka och startar på nytt.
 Efter att programmet körts kan skärmen se ut så här:

  OMVANDLA FRÅN FAHRENHEIT ELLER CELSIUS
  (F/C) ?F
  ANTAL GRADER FAHRENHEIT: 32
  32 GRAD. FAHRENHEIT= 0 GRAD. CELSIUS

  OMVANDLA FRÅN FAHRENHEIT ELLER CELSIUS
  (F/C) ?

 Efter att du kört programmet kan du spara det på flexskiva eller band.
Detta program såväl som andra som visas i denna bruksanvisning kan bilda
grunden för ditt eget programbibliotek


[4.4] GET

 GET möjliggör hämtning av ett tecken i taget från tangentbordet utan att
man behöver trycka på <RETURN>. Detta ökar i många fall hastigheten vid
inmatning av data. Den tangent du trycker ned, tilldelas den variabel du
angett efter GET.
 Följande rutin visar hur GET fungerar:

  NEW

start tok64 SID47.prg
1 PRINT "{clear}"
10 GET a$: IF a$= "" THEN 10
20 PRINT a$;
30 GOTO 10
stop tok64

ANM: Inget mellanslag mellan citationstecknen på rad 10

 Om du kör programmet, rensas skärmen och varje gång du trycker på en
tangent, skriver rad 20 ut tecknet på skärmen. Därefter väntar programmet på
rad 10 till dess du trycker ned nästa tangent. Det är viktigt att lägga
märke till att de inmatade tecknen inte visas på skärmen såvida du inte
uttryckligen begär det genom PRINT-kommandot, så som vi gjort har.
 Den andra instruktionen på rad 10 är också betydelsefull. GET-instruktionen
utförs kontinuerligt, även om ingen tangent trycks ned, (till skillnad från
INPUT som väntar på ett svar). Den andra instruktionen kontrollerar alltså
tangentbordet till dess en tangent trycks ned.
 Undersök vad som händer om den andra instruktionen på rad 10 tas bort.
Detta program kan stoppas med <RUN/STOP> och <RESTORE> nedtryckta samtidigt.
Den första delen av temperaturomvandlingsprogrammet kan lätt skrivas om till
GET-kommando. Hämta (LOAD) temperaturprogrammet och ändra raderna 10, 20 och
40 enligt nedan:

  10 PRINT "OMVANDLA FRÅN FAHRENHEIT ELLER CELSIUS (F/C)"
  20 GET A$:IF A$ = "" THEN 20
  40 IF A$ <> "C" THEN20

 Denna förändring ger att programmet fungerar smidigare, eftersom inget
händer såvida användaren inte skriver in önskat svar, F eller C.
 När denna förändring gjorts är det lämpligt att spara den nya versionen av
programmet.


[4.5] SLUMPTAL OCH ANDRA FUNKTIONER

 Commodore 64 innehåller ett antal funktioner som används för att utföra
speciella uppgifter. Funktioner kan liknas vid ett speciellt program inbyggt
i BASIC. Istället för att skriva in ett antal instruktioner varje gång du
vill utföra en speciell beräkning, räcker det med att du skriver
kommandoordet för den önskade funktionen varefter datorn sköter resten.
 Många gånger när du ger ett spel eller utbildningsprogram, behöver du skapa
ett slumptal, exempelvis för att simulera ett tärningskast. Du kan givetvis
skriva ett program som skapar dessa slumptal, men ett enklare sätt är att
anropa RaNDom number (slumptal) funktionen.
 För att utröna vad RND verkligen gör. Prova följande korta program:

  NEW

  10 FOR X = 1 TO 10
  20 PRINT RND(1), <--- Om du utelämnar komma skrivs siffrorna ut i en rad
  30 NEXT

 Efter du kört programmet kommer skärmen att se ut ungefär så här:

  .789280697          .664673958
  .256373663          .0123442287
  .682952381          3.90587279E-04
  .402343724          .879300926
  .158209063          .245596701

 Dina siffror passar inte? Om dom passat vore det väl underligt då de är
helt slumpmässigt utvalda!
 Prova med att köra programmet några gånger för att övertyga dig om att
resultatet är annorlunda varje gång. Även om talen inte följer ett bestämt
mönster, kommer du att märka att vissa saker blir samma varje gång
programmet körs.
 För det första blir resultatet alltid mellan 0 och 1 men aldrig 0 eller 1.
Detta passar oss inte om vi vill simulera ett slumpmässigt tärningskast. Vi
letar efter siffror mellan 1 och 6.
 Den andra viktiga egenskapen vi ser är att vi handskas med decimaltal (med
decimalkomma). Även detta kan vara ett problem då det ofta behövs enbart
heltal.
 Det finns ett antal enkla sätt att erhålla siffror i det område vi önskar
från RND-funktionen.
 Ersätt rad 20 med följande och kör programmet på nytt.

  20 PRINT 6*RND(1),

  RUN

  3.60563664          4.53660853
  5.47238963          8.40850227
  3.19265054          4.39547668
  3.16331095          5.50620749
  9.32527884          4.17090293

 Detta löste problemet med att få resultat större än 1, men vi har
fortfarande decimalerna att handskas med. Nu måste vi använda oss av en
annan funktion.
 INTeger (heltal)-funktionen omvandlar decimaltal till heltal.
 Byt på nytt ut rad 20 med följande och kör programmet så ser du vad som
förändrats.

  20 PRINT INT(6*RND(1)),

  RUN

  2         3         1         0
  2         4         5         5
  0         1

 Detta löste en hel del. Vi kom närmare vårt mål att skapa slumptal mellan 1
och 6. Om du tittar efter noga så ser du att resultatet är inom området 0
till 5.
 Som ett sista steg, addera 1 till instruktionen enligt följande:

  20 PRINT INT(6*RND(1))+1,

 Nu har vi erhållit det önskade resultatet..
 Rent allmänt kan du placera ett tal, en variabel, eller något BASIC-uttryck
inom parenteserna till INT-funktionen. Beroende på önskat område
multiplicerar du den övre gränsen med RND-funktionen. Om du exempelvis vill
generera ett slumptal mellan 1 och 25, kan du skriva:

  20 PRINT INT(25*RND(1))+1

 Den allmänna formeln för att generera ett slumptal inom ett bestämt område
är:

  SLUMPTALET = INT (Undre gräns + (övre-undre + 1) * RND(x))


[4.6] GISSNINGSSPEL

 Då vi nu kommit en bit på vägen att förstå slumptal, utnyttjar vi detta.
Följande spel visar på ett användningsområde för slumptal och bjuder oss
dessutom på ytterligare programmeringsteori.

start tok64 SID51.prg
1 REM nummergissnings-spel
2 PRINT"{clear}":REM clr+shift
5 INPUT"ovre grans for talet";li
10 nm=INT(li*RND(1))+1
15 cn=0
20 PRINT"jag har ett tal."
30 INPUT"vad gissar du";gu
35 cn=cn+1
40 IF gu > nm THENPRINT"mitt tal ar lagre":PRINT:GOTO30
50 IF gu < nm THENPRINT"mitt tal ar storre":PRINT:GOTO30
60 IF gu = nm THENPRINT"bra!du fick mitt nummer"
65 PRINT"efter ";cn;"gissningar.":PRINT
70 PRINT"vill du gissa mer ? (j/n)";
80 GET an$:IF an$=""THEN 80
90 IF an$="j"THEN 2
100 IF an$<> "n" THEN 80
110 END
stop tok64

 När du kör detta program skapas ett slumptal, NM.
 Du kan bestämma hur stort talet får bli i början av programmet. Sedan är
det din uppgift att gissa vilket talet är.
 En provkörning följer tillsammans med en förklaring:

  ÖVRE GRÄNS FÖR TALET? 15
  JAG HAR ETT TAL.
  VAD GISSAR DU? 10
  MITT TAL ÄR LÄGRE

  VAD GISSAR DU? 5
  MITT TAL ÄR LÄGRE

  VAD GISSAR DU? 3
  BRA!DU FICK MITT NUMMER
  EFTER  3 GISSNINGAR.

 IF/THEN-instruktionen jämför det tal du gissat med det framtagna
slumptalet. Beroende på vad du gissat skriver datorn om det är större eller
mindre än slumptalet.
 Prova om du med hjälp av formeln för slumptal kan lägga till några rader i
programmet så att du också kan bestämma den undre gränsen på slumptalen.
 Varje gång du gissar ökar DN med 1 för att hålla reda på hur många gånger
du gissat. När du använder programmet försök genom att fråga logiskt komma
fram till rätt svar på minsta möjliga antal försök.
 När du gett rätt svar skriver datorn ut "BRA! DU FICK MITT NUMMER",
tillsammans med uppgift om det antal gissningar som behövdes. Du kan
därefter starta på nytt. Programmet tar fram ett nytt slumpmässigt utvalt
tal varje gång.

PROGRAMTIPS:

 På raderna 40 och 50 används ett kolon för att Åtskilja flera instruktioner
på samma rad. Detta sparar inte enbart skrivarbete, utan i långa program
sparar det även minnesutrymme.
 Lägg också märke till IF/THEN instruktionen på samma rader. Där vi
instruerar datorn att skriva (PRINTa) något istället för att direkt grena ut
till någon annan punkt i programmet.
 Den sista punkten visar på orsaken till att skriva radnummer i steg om 10:
 Efter programmet var skrivet beslöts att lägga till räknedelen. Genom att
helt enkelt lägga till dessa nya rader i slutet av programmet, med radnummer
som passar in mellan befintliga rader, var det enkelt att modifiera
programmet.


[4.7] DITT KAST

 Följande program simulerar kast med 2 tärningar. Du kan använda det som det
är eller som del i ett större program.

   5 PRINT "VILL DU PRÖVA LYCKAN?"
  10 PRINT "RÖD TÄRNING =";INT(6*RND(1))+1
  20 PRINT "VIT TÄRNING =";INT(6*RND(1))+1
  30 PRINT "TRYCK MELLANSLAGSTANGENTEN FÖR NYTT KAST" : PRINT
  40 GET A$ : IF A$ = "" THEN 40
  50 IF A$ = CHR$(32) THEN 10

 Är du beredd att pröva lyckan?
 Med hjälp av vad du lärt om slumptal och BASIC, se om du kan förstå vad som
händer.


[4.8] SLUMPMÄSSIG GRAFIK

 Som en avslutning på slumptal, och som en introduktion till hur man
konstruerar grafik, ta och skriv in och kör följande korta program.

start tok64 SID53.prg
10 PRINT"{clear}"
20 PRINT CHR$(205.5 + RND(1));
30 GOTO 20
stop tok64

 Som du kanske väntat dig är rad 20 nyckelraden. Ytterligare en ny funktion,
CHR$ (teckensträng), getr dig ett tecken, baserat på ett standardiserat
kodnummer från 0 till 255. Alla tecken Commodore 64 kan skriva är kodade på
detta sätt. Se bilaga F.
 För att få reda på koden för något tecken, skriv:

  PRINT ASC("X")

där X är det tecken du frågar på. Detta kan vara alla skrivbara tecken,
inklusive grafik. Svaret är koden för det tecken du skrev. SOm du antagligen
redan räknat ut är "ASC" ännu en funktion, vilken ger tillbaka den
standardiserade "ASCII"-koden för det tecken du skrev.
 Du kan nu skriva ut tecknet genom att skriva:

  PRINT CHR$(X)

 Om du skriver:

  PRINT CHR$(205); CHR$(206)

kommer du se de två grafiska tecknen som finns till höger på M- och
N-tangenterna. Detta är de två tecken som programmet använder till
labyrinten.
 Genom att använda formeln 205.5+RND(1) använder datorn slumptal mellan
205.5 till 206.5. Detta ger 50% chans att talet är över eller under 206.
CHR$ ignorerar decimaldelen av talen så att halva tiden skrivs tecknet med
koden 205 ut och den återstående tiden skrivs tecknet med koden 206.
 Om du vill experimentera med detta program, kan du prova med att ändra 20.5
genom att addera eller subtrahera några tiondelar. Detta kommer att ge
endera tecknet en större chans att bli utvalt.


[5.] AVANCERADE FÄRG- OCH GRAFIKKOMMANDON

* Färg och grafik
* PRINTa färger
* Färg-CHR$-koder
* PEEK och POKE
* Skärmgrafik
* Fler studsande bollar


[5.1] FÄRG OCH GRAFIK

 Vi har nu utforskat en liten del av den datakraft som Commodore 64
erbjuder. En av datorns mest fascinerande egenskaper är de fina
möjligheterna att skapa grafik och färg.
 Du har redan sett ett enkelt exempel på grafik i programmen "studsande
boll" och "labyrint". Dessa program enbart snuddade vid de möjligheter du
erbjuds. Ett antal nya begrepp kommer att introduceras i detta kapitel.
Dessa kommer att visa grafik och färgprogrammering och hur du kan skapa dina
egna spel och animationer.
 Eftersom vi tidigare koncentrerat oss på datorns beräkningsmöjligheter, har
alla bilder vi använt varit i en enda färg (Ijusblå text på mörkblå bakgrund
och med ljusblå ram).
 I detta kapitel ska vi lära oss hur vi sätter färg på våra program och hur
vi kontrollerar alla de ovanliga grafiska symbolerna på tangentbordet.


[5.2] PRINTa FÄRGER

 Som du redan upptäckt, om du provade färginställningsförfarandet som
beskrevs i kapitel 1, kan du förändra textfärgen genom att trycka ned
<CTRL>-tangenten och en av färgtangenterna samtidigt. Detta fungerar bra i
direktmode men vad händer om du vill använda detta i ett program?
 När vi visade "studsande boll"-programmet såg du hur tangentbordets
kommandon såsom markörflyttningar kunde användas i PRINT-instruktioner. På
liknande sätt kan du också lägga textfärgändringar till ditt program.
 Du har hela 16 olika färger att arbeta med. Genom att använda
<CTRL>-tangenten och en siffertangent blir följande färger möjliga:

     1        2        3        4        5       6        7        8
   Svart     Vit      Röd     Cyan    Purpur   Grön      Blå      Gul

 Om du trycker ned <C=> samtidigt med en siffertangent blir följande färger
tillgängliga:

     1        2        3        4        5       6        7        8
   Orange   Brun    Lj. röd   Grå 1    Grå 2  Lj. grön Lj. blå   Grå 3

Skriv NEW och experimentera med följande: Håll ned <CTRL>-tangenten och
tryck samtidigt på <1>-tangenten. Tryck därefter på <R>-tangenten utan att
hålla ned <CTRL>-tangenten.
 Håll nu ned <CTRL> och tryck på <2>-tangenten. Släpp upp <CTRL> och tryck
på <R>-tangenten. Arbeta dig genom siffrorna omväxlande med bokstäverna och
skriv ordet RAINBOW enligt följande:

  10 PRINT " R A I N B O W"
            ^ ^ ^ ^ ^ ^ ^
     <CTRL><1 2 3 4 5 6 7>

  RUN
  RAINBOW

 Precis som markörkontroll visas som ett grafiskt tecken, visas också ett
tecken för varje färgändring.

När du i det tidigare exemplet höll ned <CTRL> och tryckte på <3> skrevs ett
"L" ut. <CTRL> och <7> skrev ut en vänsterpil "<-". Varje färgkontroll
kommer att visa sin egen unika grafiska kod när den används på detta sätt.
Tabellen visar den grafiska representationen för samtliga färgkontroller som
kan påverkas genom PRINT-instruktion.

  Tangentbord  Färg   Grafisk kod       Tangentbord  Färg   Grafisk kod
  <CTRL> <1>   Svart                    <C=> <1>     Orange
  <CTRL> <2>   Vit    [E]               <C=> <2>     Brun
  <CTRL> <3>   Röd    [£]               <C=> <3>     Ljusröd
  <CTRL> <4>   Cyan                     <C=> <4>     Grå 1
  <CTRL> <5>   Purpur                   <C=> <5>     Grå 2
  <CTRL> <6>   Grön   [^]               <C=> <6>     Ljusgrön
  <CTRL> <7>   Blå    [<-]              <C=> <7>     Ljusblå
  <CTRL> <8>   Gul    [¶]               <C=> <8>     Grå 3

 Även om PRINT-instruktionen ser lite konstig ut på skärmen så visas endast
texten när du kör programmet. Och bokstäverna växlar färg i enlighet med de
färgkontroll tecken du placerade i PRINT-instruktionen.
 Prova några egna exempel, blanda vilka färger du vill inom en enda
PRINT-instruktion. Kom också ihåg att du kan använda den andra satsen färger
genom att trycka ner <C=>-tangenten och en siffertangent.

TIPS:
 Du kommer att märka att sedan du kört ett program med färg eller mode
(t.ex. revers) för ändring, kommer markören och all följande text du skriver
att ha den senast inställda färgen. För att återkomma till normal bild,
tryck ned <RUN/STOP> och <RESTORE>


[5.3] FÄRG CHR$-KODER

 Tag en snabb titt på bilaga F, och läs sedan vidare här.
 Du har antagligen lagt märke till när du läste genom listan i bilaga F, att
varje färg, (såväl som de flesta andra tangentbordskontroller såsom
markörstyrningar mm.), har en unik kod. Dessa koder kan skrivas direkt för
att erhålla samma resultat som att skriva CTRL och en lämplig tangent i en
PRINT-sats.
 Prova exempelvis följande:

start tok64 SID58A.prg
10 PRINT CHR$(147):REM clr/home
20 PRINT CHR$(30);"chr$(30) andrar mig till ?"
stop tok64

 Texten ska nu ha blivit grön. I ett flertal fall är det mycket enklare att
använda CHR$-funktionen, speciellt om du vill experimentera med att ändra
färger. På följande sida beskrivs ett annat sätt att skapa ett spektrum av
färger. Då det är ett antal rader som är nästan lika (40-110) kan du använda
redigeringstangenterna för att minska skrivarbetet. Se anmärkning efter
programlistningen, vilken friskar upp ditt minne med avseende på
redigeringsproceduren.

  NEW

start tok64 SID58B.prg
1 REM  automatiska fargbalkar
5 PRINTCHR$(147):REM chr$(147)=clr/home
10 PRINT CHR$(18);"{space*6}";:REM revers balkar
20 cl=INT(8*RND(1))+1
30 ON cl GOTO 40,50,60,70,80,90,100,110
40 PRINT CHR$(5);:GOTO 10
50 PRINT CHR$(28);:GOTO 10
60 PRINT CHR$(30);:GOTO 10
70 PRINT CHR$(31);:GOTO 10
80 PRINT CHR$(144);:GOTO 10
90 PRINT CHR$(156);:GOTO 10
100 PRINT CHR$(158);:GOTO 10
110 PRINT CHR$(159);:GOTO 10
stop tok64

 Skriv raderna 5 till 40 som vanligt. Skärmen bör se ut så här:

  1 REM  AUTOMATISKA FÄRGBALKAR
  5 PRINTCHR$(147):REM CHR$(147)=CLR/HOME
  10 PRINT CHR$(18);"      ";:REM REVERS BALKAR
  20 CL=INT(8*RND(1))+1
  30 ON CL GOTO 40,50,60,70,80,90,100,110
  40 PRINT CHR$(5);:GOTO 10

REDIGERlNGSANMÄRKNINGAR

 Använd markör-upp-tangenten för att styra markören till rad 40. Skriv sedan
5 över 4'an i 40. Använd därefter markör-höger tangenten att flytta över
markören till 5 i CHR$-parentesen. Tryck på <SHIFT><INST/DEL> för att skapa
ett utrymme och skriv "28". Nu kan du trycka på <RETURN> med markören var
som helst på linjen. Skärmen ska nu se ut så här:

  1 REM  AUTOMATISKA FÄRGBALKAR
  5 PRINTCHR$(147):REM CHR$(147)=CLR/HOME
  10 PRINT CHR$(18);"      ";:REM REVERS BALKAR
  20 CL=INT(8*RND(1))+1
  30 ON CL GOTO 40,50,60,70,80,90,100,110
  50 PRINT CHR$(28);:GOTO 10

 Oroa dig inte! Rad 40 finns fortfarande kvar. LlSTa programmet och se
efter. Använd samma procedur och modifiera nedre raden med ett nytt
radnummer och CHR$-kod till dess alla återstående rader skrivits in. Du ser
nu att redigeringstangenterna visar sig mycket användbara. Som en slutlig
kontroll, LlSTa nu programmet och övertyga dig om att samtliga rader
skrivits in rätt innan du kör programmet.
 Nu följer en kort beskrivning av vad som sker. 
 Du har troligen förstått det mesta av färgbalksprogrammet nu, med undantag
för det nya och ovana begreppet på rad 30. Men låt oss först se vad
programmet verkligen utför. Rad 5 skriver CHR$-koden för CLR/HOME.
 Rad 10 ändrar till omvänd skrift och skriver 5 mellanrum, vilket visar sig
som en balk, eftersom mellanrummen är omvända (har textfärg). Första gången
programmet genomlöps blir balken blå, den normala textfärgen.
 På rad 20 används vår arbetshäst, RND-funktionen, för att slumpmässigt
välja en färg mellan 1 och 8.
 Rad 30 innehåller en variation på IF...THEN kommandot vilket kallas
ON...GOTO.ON...GOTO möjliggör för programmet att välja från en tabell av
radnummer vart det ska gå. Om variabeln (här CL) har ett värde av 1, väljs
det första radnumret (40 i vårt exempel). Om värdet är 2 väljs det andra
radnumret i tabellen och så vidare.
 Raderna 40 till 110 omvandlar våra slumptal för färgval till motsvarande
CHR$-kod och återför programmet till rad 10 för utskrift (PRINT) av balk i
vald färg.
 Därefter fortsätter programmet samma förlopp igen. 
 Se om du kan räkna ut hur det kan gå till att skapa 16 olika, slumpmässigt
valda färger. Utöka ON...GOTO för att ta hand om dem och lägg till de
återstående CHR$-koderna för att visa de återstående 8 färgerna.


[5.4] PEEK och POKE

 Med kommandona PEEK är det möjligt att se efter i datorns minne vad som
finns på en bestämd adress och med POKE att lägga in data där.
 Precis som variabler kunde liknas vid ett antal lådor i datorn där du
placerade din information, kan du också tänka dig vissa speciella lådor i
datorn vilka representerar en bestämd minnesposition.
 Commodore 64 undersöker dessa minnespositioner för att se vilka skärmens
bakgrund och ramfärger ska vara, vilka tecken som ska skrivas på skärmen och
var de ska skrivas samt en mängd andra uppgifter.
 Genom att placera, POKEa, ett nytt värde i en speciell minnesposition, kan
vi ändra färger, definiera och flytta föremål, och även skapa musik. Dessa
minnespositioner kan representeras på detta sätt:

  +-----------+     +-----------+      +-----------+      +-----------+
  |   53280   |     |   53281   |      |   53282   |      |   53283   |
  |     X     |     |     Y     |      |           |      |           |
  +-----------+     +-----------+      +-----------+      +-----------+

     RAMFÄRG        BAKGRUNDSFÄRG

 Ovan visade vi 4 minnespositioner, av vilka 2 kontrollerar skärm- och
bakgrundsfärgerna. Pröva skriva in följande:

  POKE 53281,7 <RETURN>

 Skärmens bakgrundsfärs har nu ändrats till gul eftersom vi placerade värdet
"7" -för gul- i minnespositionen som kontrollerar skärmens bakgrundsfärs.
 Prova att med hjälp av POKE-kommandot lägga in olika värden i
minnespositionen som kontrollerar skärmens bakgrundsfärs. Du kan lägga in
vilket som helst värde mellan 0 och 255, men enbart 0 till 15 fungerar.
 De rätta värdena för respektive färg är:

+-----------------------------------------------------------------------+
|       0       Svart                  8        Orange                  |
|       1       Vit                    9        Brown                   |
|       2       Röd                   10        Ljusröd                 |
|       3       Cyan                  11        Grå 1                   |
|       4       Purple                12        Grå 2                   |
|       5       Grön                  13        Ljusgrön                |
|       6       Blå                   14        Ljusblå                 |
|       7       Gul                   15        Grå 3                   |
+-----------------------------------------------------------------------+

 Kan du komma på ett sätt att visa de olika bakgrunds- och
ramfärgkombinationerna? Följande kan vara till hjälp:

  NEW

start tok64 SID61.prg
10 FOR ba = 0 TO 15
20 FOR bo = 0 TO 15
30 POKE 53280, ba
40 POKE 53281, bo
50 FOR x = 1 TO 2000: NEXT x
60 NEXT bo: NEXT ba
stop tok64

 Två enkla slingor används för att med hjälp av POKE variera bakgrund och
ramfärger. Fördröjningsslingor på rad 50 sänker endast hastigheten.
 Ta nu och skriv:

  PEEK (53280) AND 15

 Du ska få värdet 15. Detta är det senaste varde ramfärgen fått och det är
rätt eftersom både bakgrund och ramfärgen är grå (värde 15) efter det att
programmet har körts.
 Genom att skriva AND 15 elimineras alla andra värden förutom 1-15. Detta
beror på det sätt som färgkoderna lagras i datorn. Vanligtvis kan du
förvänta dig att finna samma värde som senast "POKEades" in i
minnespositionen. PEEK låter oss undersöka en bestämd minnesposition och se
vilket värde som för tillfället finns lagrat där. Kan du komma på en extra
rad till programmet som visar innehållet i bakgrund och ramfärgsminnena
samtidigt som programmet körs?
 Prova följande:

  45 PRINT CHR$(147);"RAM =" ;PEEK(53280) AND 15,
           "BAKGRUND=";PEEK(53281) AND 15


[5.5] SKÄRMGRAFIK

 Vid utskrift av information vi hittills arbetat med har datorn behandlat
informationen i sekventiell form. Tecken har skrivits efter varandra med
början från föregående markörposition. Detta med undantag för då du begärt
ny rad eller genom att skriva "," vid PRINT-formattering.
 För att skriva data på en speciell plats på skärmen kan du starta från en
känd punkt och styra markören med hjälp av markörkontrolltecken för att
formattera skärmen. Detta kräver emellertid en mängd programsteg och är
tidskrävande.
 På samma sätt som det finns en speciell adress i Commodore 64's minne för
färgkontroll, finns det också minnespositioner som du kan använda för att
direkt kontrollera varje punkt på skärmen.


[5.6] SKÄRMENS MINNESKARTA

 Då datorns skärm har plats för 1000 tecken (40 kolumner gånger 25 rader)
finns det 1000 minnespositioner reserverade för att ta hand om det som
skrivs på skärmen.
 Skärmen är arrangerad som ett rutmönster där varje fyrkant representerar en
minnesposition.

 Då varje minnesposition kan lagra ett tal från 0 till 255, finns det 256
möjliga värden för varje minnesposition. Dessa värden representerar de olika
tecken Commodore 64 kan visa. (Se bilaga E). Genom att använda
POKE-kommandot kan värdet för ett tecken läggas in i en minnesposition så
att tecknet visas på motsvarande plats på skärmen.

                                 kolumn                             1063
      0             10             20             30            39 /
     +------------------------------------------------------------/
1024 |                                                            |  0
1064 |                                                            |
1104 |                                                            |
1144 |                                                            |
1184 |                                                            |
1224 |                                                            |
1264 |                                                            |
1304 |                                                            |
1344 |                                                            |
1384 |                                                            |
1424 |                                                            | 10
1464 |                                                            |
1504 |                                                            |   rad
1544 |                                                            |
1584 |                                                            |
1624 |                                                            |
1664 |                                                            |
1704 |                                                            |
1744 |                                                            |
1784 |                                                            |
1824 |                                                            | 20
1864 |                                                            |
1904 |                                                            |
1944 |                                                            |
1984 |                                                            | 24
     +------------------------------------------------------------\
                                                                   \
                                                                    2023

 Skärmminnet hos Commodore 64 börjar normalt med minnesposition (adress)
1024 och slutar med adress 2023. Position 1024 är skärmens övre vänstra
hörn. Adress 1025 är positionen närmast till höger och så fortsätter det
raden ut. Adress 1063 är positionen längst till höger på första raden.
Positionen efter sista positionen på en rad är första positionen på raden
under.
 Föreställ dig att du vill kontrollera en studsande boll på skärmen. Bollen
är i mitten av skärmen, kolumn 20, rad 12. Formeln för beräkning av
minnespositionen är:

  PUNKT = 1024 + X + 40 * Y
                 ^        ^
               kolumn    rad

 Där X är kolumnen och Y är raden.
 Därför blir minnespositionen för bollen:

  1024 + 20 + 480  eller tillsammans 1524
         ^     ^
       kolumn rad(40*12)


 Rensa skärmen med <SHIFT> och <CLR/HOME> och skriv:

  POKE 55796, 1
  POKE 1524, 81
        ^     ^
    Position Teckenkod


[5.7] FÄRGMINNESKARTA

 En boll visar sig i mitten av skärmen. Du har placerat ett tecken direkt i
skärmminnet utan att använda PRINT-kommandot. Bollen som visade sig var vit.
Det finns emellertid ett sätt att ändra färg på ett objekt på skärmen genom
att ändra i ett annat minnesområde. Skriv:

  POKE 55796, 2
        ^     ^
    Position Färg

 Bollens färg ändrades till röd. För varje punkt på Commodore 64's skärm
finns det två minnespositioner, en för teckenkoden och en för färgkoden.
Färgminneskartan börjar vid minnesposition 55296 (övre vänstra hörnet), och
fortsätter vidare 1000 positioner till 56295.

                                 kolumn                             55335
      0             10             20             30            39 /
     +------------------------------------------------------------/
55296|                                                            |  0
55336|                                                            |
55376|                                                            |
55416|                                                            |
55456|                                                            |
55496|                                                            |
55536|                                                            |
55576|                                                            |
55616|                                                            |
55656|                                                            |
55696|                                                            | 10
55736|                                                            |
55776|                                                            |   rad
55816|                                                            |
55856|                                                            |
55896|                                                            |
55936|                                                            |
55976|                                                            |
56016|                                                            |
56056|                                                            |
56096|                                                            | 20
56136|                                                            |
56176|                                                            |
56216|                                                            |
56256|                                                            | 24
     +------------------------------------------------------------\
                                                                   56295

 Samma färgkoder från 0 till 15, som vi använde för att ändra ram och
bakgrundsfärger, kan användas här för att direkt ändra teckenfärger. Formeln
vi använde för att beräkna skärmminnespositioner kan modifieras för att ge
färgminnespositioner att användas tillsammans med POKE-kommandot. Den nya
formeln lyder:

  TECKENFÄRG = 55296 + X + 40*Y


[5.8] FLER STUDSANDE BOLLAR

 Här är ett omgjort studsande boll-program som skriver direkt på skärmen med
hjälp av POKE-kommandot, till skillnad mot tidigare program som använde
markörstyrning genom PRINT-kommandon. Som du kommer att se när du kört
programmet, är det mycket mer rörligt, och ger mer levande bilder.

start tok64 SID65.prg
10 PRINT"{clear}"
20 POKE 53280,7 : POKE 53281,13
30 x = 1 : y = 1
40 dx = 1 : dy = 1
50 POKE 1024 + x + 40*y,81
60 FOR t = 1 TO 10 : NEXT
70 POKE 1024 + x + 40*y,32
80 x = x + dx
90 IF x = 0 OR x = 39 THEN dx = -dx
100 y = y + dy
110 IF y = 0 OR y = 24 THEN dy = -dy
120 GOTO 50
stop tok64

 Rad 10 rensar skärmen och rad 20 ändrar bakgrunden till ljusgrön med gul
ram.
 X och Y variablerna på rad 30 håller rätt på bollens aktuella rad och
kolumnposition. Variablerna DX och DY på rad 40 är bollens horisontella och
vertikala rörelseriktningar. När + 1 adderas till X värdet, flyttar bollen
sig till höger. Om - 1 adderas rör sig bollen åt vänster. Om + 1 adderas
till Y flyttas bollen nedåt en rad, - 1 flyttar bollen uppåt en rad.
 Rad 50 skriver bollen på skärmen i aktuell position. Rad 60 är den gamla
bekanta fördröjningsslingan, vilken åstadkommer att bollen stannar på
skärmen lagom länge för att synas.
 Rad 70 raderar bollen genom att ersätta den med ett mellanslag (blanktecken,
kod 32) på den plats där bollen var på skärmen.
 Rad 80 adderar riktningsfaktor till X. Rad 90 testar för att se om bollen
nått någon av sidoväggarna och byter riktning om det är en studs. Raderna
100 och 110 gör samma för övre och undre väggarna.
 Rad 120 styr tillbaka programmet till skärmen för att rita ut bollen igen.
 Genom att ändra koden på rad 50 från 81 till en annan teckenkod kan du
ändra bollen till ett annat tecken. Om du ändrat DX eller DY till 0 studsar
bollen rakt istället för diagonalt.
 Vi kan också göra programmet smartare. Hittills har datorn endast
kontrollerat att X och Y värdena inte gått utanför väggarna. Lägg till
följande rader till programmet:

   21 FOR L = 1 TO 10
   25 POKE 1024 + INT(RND(1)*1000), 166   <------------------ CHR$-kod
   27 NEXT L
  115 IF PEEK(1024 + X + 40 * Y) = 166 THEN DX = -DX : GOTO 80

 Raderna 21 till 27 lägger ut 10 fyrkanter i slumpmässigt valda positioner
på skärmen. Rad 115 undersöker (PEEKar av) för att se om bollen är på väg
att studsa in i en fyrkant, och ändrar i så fall riktning.


[6.] SPRITEGRAFIK

* Introduktion av sprites
* Skapa sprites
* Mera information om sprites
* Binär aritmetik


[6.1] INTRODUKTION AV SPRITES

 När vi i tidigare kapitel utnyttjade grafik såg vi att grafiska symboler
kunde användas i PRINT-kommandon för att animera och göra bildliknande
figurer på skärmen.
 Ett sätt var också att använda POKE-kommandot för att placera ett tecken i
en bestämd minnesposition.
 Att skapa bilder på dessa sätt krävde en stor arbetsinsats eftersom
föremålen måste skapas från existerande grafiska symboler. Förflyttning av
figurer till en ny position krävde en mängd programsteg. Dessutom, beroende
på begränsningen att använda existerande grafiska symboler, blev formen och
detaljrikedomen hos figur rama inte alltid så bra som önskat.
 Användning av sprites i bildavsnitt eliminerar en stor del av dessa
problem. En sprits är ett i högupplösning programmerat objekt Figur) som kan
göras i önskad form--genom BASIC kommandon. Figuren kan lätt flyttas runt på
skärmen genom att enkelt tala om för datorn den position dit den ska
flyttas. Datorn tar hand om resten.
 Sprites kan mycket mer. Deras färger kan ändras; du kan få information om
de kolliderar med varandra; de kan programmeras att gå framför och bakom
varandra; och de kan lätt fås att ändra storlek. Detta till att börja med!
Nackdelarna med allt detta är minimala. Emellertid kräver användande av
sprites viss kännedom om hur Commodore 64 arbetar och hur tal behandlas
inuti datorn. Det är emellertid inte så komplicerat som det låter. Följ bara
exemplen och du kommer ganska snart att få dina egna sprites att Göra
fantastiska saker åt dia.


[6.2] SKAPA SPRITES

 Sprites kontrolleras av en speciell bildgenerator i Commodore 64. Denna
bildgenerator sköter om vad som visas på skärmen. Den tar hand om allt
arbete som fordras för att skapa och hålla ordning på tecken och grafik,
skapar färger och flyttar runt figurerna.
 Denna bildgeneratorkrets har 46 olika TILL/FRÅN positioner vilka fungerar
på liknande sätt som invändiga minnespositioner. Vardera av dessa positioner
består av 8 celler. Varje cell kan vara TILL eller FRÅN. Vi kommer att
behandla detta mer noggrant senare. Genom att med POKE-kommandot lägga in
ett lämpligt decimalvärde i en minnesplats kan du kontrollera formen och
rörelsen för din sprite-figur.
 Utöver att vi använder många av bildgeneratorns minnespositioner kommer vi
att använda en del av Commodore 64's huvudminne för att lagra information
(data) som definierar sprites. Dessutom finns det 8 minnespositioner direkt
efter skärmminnet som talar om för datorn var den ska hämta data för
respektive sprits.
 Eftersom vi går igenom några exempel, blir programmeringen ganska
okomplicerad och du kommer att förstå hur det går till.
 Låt oss nu börja med att skapa lite sprite-grafik. En spritefigur är 24
punkter bred och 21 punkter hög. Upp till 8 sprites kan hanteras samtidigt.
Sprites visas på skärmen i ett speciellt högupplösningsläge vilken ändrar
skärmen till ett 320 punkter brett och 200 punkter högt område.
 Tänk dig att du vill skapa en ballong och få den att sväva runt på skärmen.
Ballongen kan konstrueras i ett rutnät bestående av 24 gånger 21 celler (se
nedan).

                           SERIE | SERIE | SERIE
                             1   |   2   |   3
                                 |       |
                          1       1       1
                          2631    2631    2631
                          842684218426842184268421
                         +------------------------+
                       1 |.........#######........|
                       2 |.......###########......|
                       3 |......#############.....|
                       4 |......#####...#####.....|
                       5 |.....#####.###..####....|
                       6 |.....#####.###.#####....|
                       7 |.....#####.###..####....|
                       8 |......#####...#####.....|
                       9 |......#############.....|
                   R  10 |......#############.....|
                   A  11 |......#.#########.#.....|
                   D  12 |.......#.#######.#......|
                      13 |.......#..#####..#......|
                      14 |........#..###..#.......|
                      15 |........#..###..#.......|
                      16 |.........#..#..#........|
                      17 |.........#..#..#........|
                      18 |..........#####.........|
                      19 |..........#####.........|
                      20 |..........#####.........|
                      21 |...........###..........|
                         +------------------------+
                                   1    1    2   2
                          1   5    0    5    0   4

                                   KOLUMN


 Nästa steg är att omvandla bilden till data som Commodore 64 kan använda.
Tag ett anteckningsblock eller ett rutat papper och rita upp ett rutnät som
är 21 rutor högt och 24 rutor brett. I överkanten skriver du
128,64,32,16,8,4,2,1, tre gånger (som bilden visar), över samtliga 24 rutor.
Numrera vänstersidan med siffrorna 1--21 för varje rad. Skriv ordet DATA
över slutet på raderna. Nu kan du fylla i rutmönstret med någon figur eller
använd ballongen som vi har. Det är lättast att rita formen först och sedan
gå tillbaka och fylla i rutorna.
 Om du nu tänker på de rutor du fyller i som "TILL" så ersätt varje fylld
ruta med en etta. För de som inte är fyllda, de är "FRÅN", skriv en nolla.
 Med början på första raden måste du omvandla punkterna i tre separata
sektioner av data som datorn kan förstå. Varje sektion om 8 rutor motsvarar
en mängd data som kallas en BYTE. Med början från vänster på övre raden är
de första 8 rutorna blanka eller nollor, så värdet för den serien av tal är
noll.
 Den mellersta serien ser så här ut (fortfarande motsvarar 1 en fylld ruta,
0 en tom ruta).

              128    64    32    16    8     4     2     1    <--värde
            +-----+-----+-----+-----+-----+-----+-----+-----+
            |  0  |  1  |  1  |  1  |  1  |  1  |  1  |  1  | <--"ställning"
            +-----+-----+-----+-----+-----+-----+-----+-----+
               ^     ^     ^     ^     ^     ^     ^     ^    +--beräkning
               |     |     |     |     |     |     |     |    v
               0  +  64 +  32 +  16 +  8  +  4  +  2  +  1  =  127

 Den tredje serien på första raden innehåller endast blanka rutor så det
motsvarar noll. Därför blir data för första raden:

  DATA 0,127,0

 Serien för andra raden beräknas på följande sätt:

           +-----+-----+-----+-----+-----+-----+-----+-----+
  Serie 1: |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |
           +-----+-----+-----+-----+-----+-----+-----+-----+
                                                         1  =  1

           +-----+-----+-----+-----+-----+-----+-----+-----+
  Serie 2: |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
           +-----+-----+-----+-----+-----+-----+-----+-----+
              ^     ^     ^     ^     ^     ^     ^     ^
              |     |     |     |     |     |     |     |
             128 +  64 +  32 +  16 +  8  +  4  +  2  +  1  =  255

           +-----+-----+-----+-----+-----+-----+-----+-----+
  Serie 3: |  1  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |
           +-----+-----+-----+-----+-----+-----+-----+-----+
              ^     ^
              |     |
             128 +  64                                     =  192


 För rad 2 blir data följande:

  DATA 1,255,192

 På samma sätt förfares med de tre serierna av data på vardera av de
återstående raderna. De omvandlas till dess decimalvärde. Tag dig tid att
göra de återstående raderna i vårt exempel.
 Nu när du har data för ditt objekt, hur kan du få ut något av det? Skriv
följande program och se vad som händer.

start tok64 SID71.prg
1 REM ballong-flygning
5 PRINT"{clear}"
10 v=53248:REM start display chip
11 POKEv+21,4:REM start sprite 2
12 POKE 2042,13: REM sprite data fran block 13
20 FOR n = 0 TO 62:READ q:POKE 832+n,q:NEXT
30 FOR x = 0 TO 200
40 POKE v+4,x:REM uppdaterar x koordinaten
50 POKE v+5,x:REM uppdaterar y koordinaten
60 NEXT x
70 GOTO 30
200 DATA 0,127,0,1,255,192,3,255,224,3,231,224
210 DATA 7,217,240,7,223,240,7,217,240,3,231,224
220 DATA 3,255,224,3,255,224,2,255,160,1,127,64
230 DATA 1,62,64,0,156,128,0,156,128,0,73,0,0,73,0
240 DATA 0,62,0,0,62,0,0,62,0,0,28,0
stop tok64

* för mer info om READ och DATA se kapitel 8

 Om du skrivit allt korrekt, flyger din ballong sakta över skärmen:.

[Bild på en flygande ballong borttagen]

 För att du ska förstå vad som hände, behöver du först veta vilka
minnespositioner som behövs för bildgeneratorn. Dessa positioner, kallade
register, beskrivs nedan:

  Register  Beskrivning

   0        X-koordinat för sprite 0
   1        Y-koordinat för sprite 0
   2-15     Par som 0 och 1 för sprites 1-7
  16        Mest signifikanta biten -- X-koordinat
  21        Sprite synlig: 1=synlig, 0=osynlig
  29        Expandera sprite i "X"-riktningen
  23        Expandera sprite i "Y"-riktningen
  39-46     Sprite 0 till 7 färgval

 Utöver denna information behöver du veta från vilken 64 bytes minnessektion
varje serie av 8 minnesceller innehållande data för sprites ska hämtas
(serie 1 används inte).
 Dessa data tas om hand av 8 positioner direkt efter skärmminnet:

        +------+------+------+------+------+------+------+------+
        | 2040 | 2041 | 2042 | 2043 | 2044 | 2045 | 2046 | 2047 |
        +------+------+------+------+------+------+------+------+
            ^      ^      ^      ^      ^      ^      ^      ^
            |      |      |      |      |      |      |      |
     SPRITE 0      1      2      3      4      5      6      7

 Låt oss nu beskriva den exakta proceduren för att komma igång och slutligen
skriva ett program.

 Det krävs endast ett fåtal steg för att skapa och flytta runt ett objekt
(en sprite).

1. Genom använda POKE-kommandot i register 21 kan du få önskad(e) spriters)
   att bli synliga. 
2. Sätt sprite-pekaren (position 2040-2047) att peka ut varifrån data för
   aktuell sprite ska hämtas.
3. POKEa in aktuella sprite-data i minnet.
4. Med hjälp av en slinga uppdateras X- och Y-koordinaterna så att objektet
   rör sig.
5. Du kan, efter önskemål, expandera objektet, byta färg eller utföra olika
   specialfunktioner. Register 29 används för att expandera i X-led och
   register 23 i Y-led.

 Nu återstår endast några få punkter i programmet som du inte bekantat dig
med i den genomgång vi hittills gjort.
 På rad 10;
 V = 53248 
sätter V till starten på videokretsens minnesadresser. På detta sätt ökar vi
enbart V med registernumret så får vi den verkliga minnesadressen.
Registernumren är de som gavs i registertabellen ovan.

 På rad 11;
 POKE V + 21,4
 gör sprite 2 synlig genom att placera värdet 4 i vad som kallas
enable-register (21). Se det på följande sätt:

                                 SPRITES

                   Decimalvärde för varje spritenummer
       128      64      32      16      8       4       2       1

                               Spritenummer
        7       6       5       4       3       2       1       0
    +-------+-------+-------+-------+-------+-------+-------+-------+
 21 |   0   |   0   |   0   |   0   |   0   |   1   |   0   |   0   | = 4
    +-------+-------+-------+-------+-------+-------+-------+-------+
                                                ^
                                                |
                                Sätt en etta för den sprite(s) du önskar

 Varje sprite representeras i register 21 av spriteminnet och 4 motsvarar
där sprite nummer 2.
 Om du skulle använda sprite nummer 3 borde du sätta en 1 i minnescellen för
sprite 3 vilket görs med värdet 8. Om du samtidigt vill använda sprites 2
och 3 måste du sätta en etta i cellen för respektive sprites. Värdet som ska
läggas in i registret blir då 4 + 8 = 12. Du lägger alltså samman
decimalvärdena på samma satt som du gjorde med DATA på det rutade papperet
tidigare. Starta sprites 2 och 3 kan alltså skrivas V+21,12.

 På rad 12;
 POKE 2042,13
instruerar datorn att hämta data till sprite 2 (position 2042) från
minnesområde 13. Som du minns från det du gjorde dina sprites, behövs det 63
bytes (minnessektioner) för att lagra dess data. Du kanske inte lade märke
till det men de siffror du skrev över rutmonstret motsvarar 3 byte (ord) för
datorn. Med andra ord; vardera samling av följande tal, 128,64,32,16,8,4,2,1
motsvarar 1 byte av datorns minne.
 Med 21 rader med 3 bytes vardera behöver varje sprite 63 bytes.

  20 FOR N = 0 TO 62 : READ Q : POKE 832+N, Q : NEXT
                            ^               ^
                            |               |
                            +---------------+------- 1 byte

 Denna rad tar hand om data på din sprite. De 63 bytes med data som
representerade den sprite du skapade läses nu in i det trettonde
minnesblocket. Detta startar på adress 832.

  30 FOR X = 0 TO 200
  40 POKE V+4, X  <---- Sprite 2'S X-koordinat
  50 POKE V+5, X  <---- Sprite 2's Y-koordinat

 Som du kommer ihåg från skolan så representerar X-koordinaten ett objekts
horisontella rörelse över skärmen och Y-koordinaten representerar spritens
vertikala rörelse på skärmen. Då värdet på X förändras på rad 30 från 0 till
300 (en siffra i taget) flyttar sig spriten nedåt mot häger ett steg för
varje siffra. Siffrorna läses av datorn tillräckligt snabbt för att
uppfattas som en kontinuerlig rörelse, istället för ett steg i taget. Om du
behöver fler detaljer kan du se efter på registerkartan i bilaga O.
 När det handlar om att samtidigt flytta ett flertal objekt, skulle det vara
omöjligt för en minnessektion att uppdatera positionerna för alla 8
objekten. Därför har varje sprite sin egen uppsättning av 2 bytes för att
styra objekten över skärmen.
 Rad 70 startar om programmet efter objektet passerat skärmen en gång. Det
återstående av programmet är data för ballongen. Det ser verkligen
annorlunda ut på skärmen eller hur?
 Prova nu att lägga till följande rad:

  25 POKE V + 23,4: POKE V + 29,4: REM EXPANDERA

och kör programmet igen. Ballongen har expanderat till dubbel storlek! Vad
vi gjorde var enkelt. Genom att POKEa 4 (för att indikera sprite 2) i
registren 23 och 29 expanderades sprite 2 i X och Y-led.
 Det är viktigt att lägga märke till att objektet startar i övre vänstra
hörnet. När ett objekt expanderas i endera riktningen förblir startpunkten
densamma.
 För ytterligare prov lägg till följande rader:

  11 POKE V+21,12
  12 POKE 2042,13: POKE 2043,13
  30 FOR X = 1 TO 190
  45 POKE V + 6,X
  55 POKE V + 7,190-X

 En andra sprite (nummer tre) har nu startats genom att vi POKEat 12 i den
minnesposition som ger objekt synliga (V+21).12 startar sprites 3 och 2
(00001100 = 12).
 De nya raderna 45 och 55 flyttar kring sprite 3 genom att POKEa värden i
sprite 3's register för X- och Y-koordinater (V + 6 och V + 7).
 Vill du fylla himlen med ännu mer? Lägg då till följande:

  11 POKE V+21, 28  <-- 28 är i verkligheten 4(sprite 2) + 8(sprite 3) +
                        16 (sprite 4)
  12 POKE 2042, 13 : POKE 2043, 13 : POKE 2044, 13
  25 POKE V+23, 12 : POKE V+29, 12
  48 POKE V+8, X
  58 POKE V+9, 100

på rad 11 görs denna gång ytterligare en sprite (4) synlig genom att vi
POKEar 28 in i enable registret. Nu är sprites 2,3 och 4 till (00011100 =
28).
 Rad 12 indikerar att sprite 4 ska hämta sina data från samma minnesområde
(den 13de 63 bytessektionen) som de andra objekten. Detta sker genom POKE
2044,13
 På rad 25 expanderas sprite 2 och 3 genom att POKEa 12 (sprite 2 och 3) i X
och Y minnena för expansionsriktningen (V + 23 och V + 29).
 Rad 48 flyttar sprite 3 längs X-axeln. Rad 58 placerar sprite 3 halvvägs
ned på skärmen, till plats 100. Eftersom detta värde inte ändras, som det
gjorde tidigare med X = 1 TO 200 flyttar sig sprite 3 enbart horisontellt.


[6.3] MERA INFORMATION OM SPRITES

 Nu när du experimenterat med sprites kan ytterligare information lämnas. Du
kan ändra objektens färg till vilken som helst av de tillgängliga 16
standardfärgerna. Detta sker med hjälp av de färgkoder (0 till 1 5) som vi
använde för att ändra teckenfärg tidigare. Dessa kan du hitta i kapitel 5
eller bilaga G.
 Om du exempelvis vill ändra sprite 1 till ljusgrön, skriv: POKE V + 40, 13
(kom ihåg att sätta V = 53248).
 Du kanske lade märke till när du körde programexemplet för sprites att
objekten aldrig flyttades till den högra kanten på skärmen. Detta berodde på
att skärmen är 320 punkter bred och X-riktningsregistret kan endast lagra
värden upp till 255. Hur kan man då få objekt att röra sig över hela
skammen? Det finns en plats i minneskartan som inte omnämnts ännu. Register
16 (i minneskartan) kontrollerar något som kallas den mest signifikanta
biten (MSB) för sprites X-koordinat. Detta ger dig möjlighet att flytta till
en horisontell punkt mellan 256 och 320.
 Den mest signifikanta biten (MSB) i X registret fungerar enligt följande:
det att objektet har flyttats till X positionen 255, placeras ett värde i
register 16 som representerar den sprite du vill flytta. Om du exempelvis
vill flytta sprite 2 till en X-position mellan 255 och 1 320. POKEa värdet
för sprite 2, vilket är 4, in i register 16.

  POKE V + 16,4

 Nu kan du börja förflyttningen i det vanliga registret för X-riktningen för
sprite 2 (vilket är register 4) med början på 1 igen. Eftersom du endast ska
flytta ytterligare 64 steg, kommer X-värdet endast att variera mellan 0 och
63 denna gång.
 Hela denna idé beskrivs bäst med en version av originalprogrammet:

  10 V = 53248 : POKE V+21, 4 : POKE 2042, 13
  20 FOR N = 0 TO 62 : READ Q : POKE 832+N, Q : NEXT
  25 POKE V+5, 100
  30 FOR X = 0 TO 255
  40 POKE V+4, X
  50 NEXT
  60 POKE V+16, 4
  70 FOR X = 0 TO 63
  80 POKE V+4, X
  90 NEXT
 100 POKE V+16, 0
 110 GOTO 30

 Rad 60 sätter MSB för sprite 2. Rad 70 börjar på nytt ändra i det vanliga
X-riktningsregistret, vilket gör att objektet flyttas den återstående vägen
över skärmen.
 Rad 100 är viktig eftersom den stänger av den mest signifikanta biten så
att objektet kan starta från skärmens vänsterkant på nytt.
 For att definiera flera sprites, kan du behöva ytterligare block för sprite
data. Du kan använda en del av BASIC RAM genom att flytta BASIC. Innan du
skriver eller läser in ditt program skriv:

  POKE 44,16:POKE16*256,0:NEW

 Nu kan du använda block 32 till 41 (adress 2048 till 4095) för lagring av
spritedata.


[6.4] BINÄR ARITMETIK

 Det är utanför avsikten med denna bruksanvisning att i detalj beskriva hur
datorn behandlar tal. Vi kommer emellertid att ge dig en tillräcklig
introduktion för att förstå hur det går till och för att ge dig möjlighet
att gå vidare med kvalificerad animering.
 Men innan dess måste vi definiera några termer:
 BIT--Detta är den minsta mängd information en dator kan lagra. Jämför en
BIT med en omkopplare som är antingen "TILL" eller "FRÅN". När en BIT är
"TILL" har den värdet 1; när den är "FRÅN" har den värdet 0.

 Efter BIT är nästa storhet BYTE.
 BYTE--Detta definieras som en följd av BITar. Då en BYTE är uppbyggd av 8
BITar, kan du i verkligheten ha totalt 256 olika kombinationer av BITar. Med
andra ord, du kan ha alla BlTar "från" och då ser din BYTE ut så här:

          128      64      32      16      8       4       2       1
       +-------+-------+-------+-------+-------+-------+-------+-------+
       |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |
       +-------+-------+-------+-------+-------+-------+-------+-------+

och dess värde är 0. Alla BIT's "till" är:

          128      64      32      16      8       4       2       1
       +-------+-------+-------+-------+-------+-------+-------+-------+
       |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
       +-------+-------+-------+-------+-------+-------+-------+-------+

vilket är 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255.

 Nästa storhet kallas REGISTER.
 REGISTER--Definieras som en samling av sammanhängande BYTES. Men i detta
fall är varje REGISTER endast 1 BYTE långt. En serie av REGISTER bildar en
REGISTERKARTA. REGISTERKARTOR är kartor av den typ du använde när du
gjorde din ballong. Varje REGISTER kontrollerar olika funktioner. Det som
används att göra sprites synliga kallas enable (tillgänglig)-REGISTER. För
att göra ett objekt större i höjdled används EXPAND X REGISTER, och för att
objekten bredare används EXPAND Y REGISTER. Kom ihåg att ett REGISTER är en
BYTE som utför en specifik uppgift.
 Låt oss nu gå vidare till återstoden av BINÄR ARITMETIK.

BINÄR TILL DECIMAL OMVANDLING

+-----------------------------------------------------------------------+
|                             Decimalvärde                              |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|  128  |   64  |   32  |   16  |   8   |   4   |   2   |   1   |       |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|   0   |   0   |   0   |   0   |   0   |   0   |   0   |   1   |  2^0  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|   0   |   0   |   0   |   0   |   0   |   0   |   1   |   0   |  2^1  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|   0   |   0   |   0   |   0   |   0   |   1   |   0   |   0   |  2^2  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|   0   |   0   |   0   |   0   |   1   |   0   |   0   |   0   |  2^3  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|   0   |   0   |   0   |   1   |   0   |   0   |   0   |   0   |  2^4  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|   0   |   0   |   1   |   0   |   0   |   0   |   0   |   0   |  2^5  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|   0   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |  2^6  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+
|   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |  2^7  |
+-------+-------+-------+-------+-------+-------+-------+-------+-------+

 Genom att använda kombinationer av alla åtta bitarna, kan du erhålla
samtliga värden från 0 till 255. Börjar du förstå varför värdena vi POKEade
in i färgregister tidigare måste vara mellan 0 och 255? Varje minnesadress
innehåller en BYTE med information.
 Alla möjliga kombinationer av åtta 0:or och 1:or omvandlas till ett unikt
decimalvärde mellan 0 och 255. Om alla celler innehåller ettor kommer
decimalvärdet av en BYTE att vara 255. Enbart nollor motsvarar ett
BYTE-värde av 0; "00000011" motsvarar 3 och så vidare. Detta är grunden för
att skapa data som representerar sprites och för att styra dem.
 Exempelvis om följande BYTE representerade en del av en sprite (0 = tom
ruta, 1 = färgad ruta):

        7       6       5       4       3       2       1       0
       2       2       2       2       2       2       2       2
   +-------+-------+-------+-------+-------+-------+-------+-------+
   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
   +-------+-------+-------+-------+-------+-------+-------+-------+
      128  +   64  +   32  +   16  +   8   +   4   +   2   +   1   =  255

 Då skulle vi POKEa 255 i motsvarande minnesposition för att representera
den delen av objektet.

TIPS

 For att bespara dig besvarat att omvandla binära tal till decimaltal--du
kommer att gots det en hel del--han du låta följande program göra det åt
dig. Det är förståndigt att skriva programmet och spara det för framtida
bruk.

start tok64 SID78.prg
5 REM binar till decimal omvandlare
10 INPUT"skriv 8-bit binart tal:";a$
12 IF LEN(a$)<>8 THEN PRINT "8 bitar tack...":GOTO 10
15 tl=0:c=0
20 FOR x = 8 TO 1 STEP -1:c = c + 1
30 tl = tl + VAL(MID$(a$,c,1))*2^(x-1)
40 NEXT x
50 PRINT a$;" binart ";" = ";tl;"decimalt"
60 GOTO 10
stop tok64

 Detta program tar ditt binära tal, som skrivits in som textsträng, och
undersaker varje tecken i strängen, från vänster till höger (MID$
funktionen). Variabeln C pekar ut vilket tecken som ska bearbetas då
programmet körs.
 VAL-funktionen på rad 30, returnerar tecknets aktuella varde. Då vi arbetar
med numeriska tecken är teckenvärdet samma som talvärdet. Om exempelvis
första tecknet i A$ är 1 blir också värdet 1.
 Slutet på rad 30 multiplicerar det aktuella talvärdet med rätt exponent av
2. Då det första värdet är i "2 upphöjt till 7"-position i vårt exempel,
blir TL först lika med 1 * 128 = 128. Om BlTen är 0 blir värdet för den
biten också 0.
 Detta upprepas för alla 8 tecknen och TL håller rätt på aktuella summan av
binärtalet.


[7.] SKAPA LJUD

* Programmera ljud utan att vara programmerare
* Uppbyggnad av ljudprogram
* Ljuddemoprogram
* Gör musik med Commodore 64
* Viktiga ljudkontroller
* Spela ett stycke på Commodore 64
* Skapa ljudeffekter
* Enkla ljudeffekter du kan prova


[7.1] PROGRAMMERA LJUD UTAN ATT VARA PROGRAMMERARE

 De flesta programmerare använder datorljud av två orsaker: att skapa musik
och för att göra ljudeffekter. Innan vi börjar med djupsinnigheter i hur man
programmerar ljud ska vi se på hur ett typiskt ljudprogram är uppbyggt...
och ge dig ett kort ljudprogram som du kan experimentera med.


[7.2] UPPBYGGNAD AV LJUDPROGRAM

 Till att börja med finns det 5 inställningar som du måste känna till för
att skapa ljud med din Commodore 64: VOLYM, ATTACK/DECAY, SUSTAIN/RELEASE
(ADSR), VÅGFORMKONTROLL och HÖG FREKVENS/LÅG FREKVENS. De första tre
inställningarna görs vanligtvis EN GÅNG i början av ditt program. Hög och
låg frekvensinställning måste ställas om för varje ton du spelar.
Vågformkontrollen startar och stoppar varje ton. Här följer hur ett typiskt
Ijud/musik program är uppbyggt.


[7.3] LJUDDEMOPROGRAM

 Innan du börjar måste du välja en stämma. Det finns 3 stämmor. Varje stämma
kräver ljudinställningar för vågform etc. Du kan spela 1-, 2- eller
3-stämmigt men vårt lilla program använder enbart STÄMMA NUMMER 1. Skriv in
detta program rad för rad... kom ihåg att trycka RETURN efter varje rad.

1. Nollställ först ljudkretsen.

   5 FOR L=54272 TO 54296:POKE L,0:NEXT

2. Sätt på full VOLYM.

  10 POKE 54296, 15

3. Sätt ATTACK/DECAY nivå för att bestämma hur snabbt en ton ökar till och
   faller från sin högsta ljudstyrka (0 till 255).

  20 POKE 54277, 190

4. Sätt SUSTAIN/RELEASE värde för att bestämma nivån på den förlängda tonen
   och hastigheten den sedan ska tona ner med.

  30 POKE 54278, 248

5. Leta rätt på den not/ton du vill spela i tabellen i appendix M och skriv
   in HÖG. FREKVENS och LÅG-FREKVENS värde för den ton. (Varje ton kräver 2
   POKEvärden.)

  40 POKE 54273, 17:POKE 54272, 37

6. Starta VÅGFORM med en av 4 standardinställningar (17, 33, 65 eller 129).

  50 POKE 54276, 17

7. Skriv en fördröjningsloop för att bestämma VARAKTIGHETEN av tonen som
   spelas (en kvartsnot är ca. "250" men kan variera då längre program kan
   påverka tiden)

  60 FOR T=1 TO 250:NEXT

8. Stäng av TONEN

  70 POKE 54276,16

 För att lyssna till den ton du just skapade, skriv RUN och tryck på
<RETURN>. För att se eller ändra i programmet skriv LIST och tryck på
<RETURN> (Glöm inte att spara ditt demo-program på kassett eller disk.


[7.4] GÖR MUSIK MED COMMODORE 64

 Du behöver inte vara musiker för att kunna göra musik med din Commodore 64!
Allt du behöver kunna är några stycken enkla tal som talar om för din dator
hur stark volym, vilka toner, hur länge de ska ljuda etc. Men först... här
följer ett program som ger dig en snabb demonstration av Commodore 64
otroliga musikförmåga, genom att använda en av datorns 3 separata stämmor.
 Skriv ordet NEW och tryck <RETURN>. så raderas ditt tidigare program. Skriv
därefter in följande program och skriv RUN och tryck <RETURN>

    5 REM SKALA <------------------------- Programmets titel
    7 FOR L=54272 TO 54296:POKE L,0:NEXT
   10 POKE 54296,15 <--------------------- Sätter full volym
   20 POKE 54277,7:POKE 54278,133 <------- Sätter ADSR (varje ton)
   50 READ A <---------------------------- Läser första DATA i rad 110.
   60 READ B <---------------------------- Läser andra talet på rad 110
                                           DATA.
   70 IF B=-1 THEN END <------------------ Programmet stänger av de två
                                           stämmorna och avslutar när det
                                           läst -1 på rad 900.
   80 POKE 54273,A:POKE 54272,B <--------- POKEar det första talet från DATA
                                           på rad 110 (A=17) som HÖG
                                           FREKVENS och det andra talet
                                           (B=37) som LÅG FREKVENS. Nästa
                                           gång programmet loopat runt läser
                                           det A som 19 och B som 63, osv.
                                           Dessa tal POKEas in i HÖG och
                                           LÅG-FREKVENSREGISTREN. Adresserna
                                           är för HÖG FREKVENS=54273 och LÅG
                                           FREKVENS=54272 för stämma 1.
   85 POKE 54276,17 <--------------------- Startar tonen
   90 FOR T=1 TO 250:NEXT:POKE 54276,16 <- Spelar tonen och stänger därefter
                                           av den.
   95 FOR T=1 TO 50:NEXT <---------------- RELEASE-tiden.
  100 GOTO 20 <--------------------------- Loopar tillbaka för att
                                           återställa KONTROLLER och spela
                                           en ny ton.
  110 DATA 17,37,19,63,21,154,22,227 <---- Not-värde från tabell appendix 7.
  120 DATA 25,177,28,214,32,94,34,175 <--- Varje par siffror representerar
                                           en not. Exempelvis, 17 och 37
                                           representerar "C" i fjärde
                                           oktaven, 19 och 63 representerar
                                           "D" osv.
  900 DATA -1,-1 <------------------------ När programmet når -1 stängs
                                           HÖG/LÅGFREKVENSERNA av och
                                           programmet avslutas som
                                           instrueras på rad 70.
  
 För att förändra Ijudet till "cembalo", ändra så det står följande på rad
85:

  POKE 54276,33
och rad 90 till:
  FOR T=1 TO2 50:NEXT:POKE 54276,32

och kör programmet igen. (Ändra programmet genom att trycka ned
<RUN/STOP>-tangenten för att stoppa det, skriv därefter LIST och tryck
<RETURN>). Skriv därefter på nytt den programrad du vill ändra, den nya
raden ersätter automatiskt den tidigare med samma radnummer. Vad vi gjorde
här var att ändra VÅGFORMEN från triangelform till sågtandsform. Förändring
av vågformen kan drastiskt ändra Ijudet från Commodore 64... men... vågform
är endast en av flera inställningar du kan ändra för att skapa olika
musikaliska klanger och ljudeffekter! Du kan också ändra ATTACK/DECAY
förhållandet för varje ton... exempelvis kan du ändra "cembalo" att låta
mera "banjo"-likt genom att ändra rad 20 och lägga till rad 30.

  20 POKE 54277,193
  30 POKE 54278,8 <------------------- Sätter SUSTAIN till 0 för "banjoljud"

 Som du just sett, kan du få Commodore 64's ljud att låta som olika
musikinstrument. Låt oss studera hur varje ljudinställning fungerar.


[7.5] VIKTIGA LJUDKONTROLLER

 1. VOLYM -- För att starta ljudet och ställa in högsta ljudstyrka, skriv:
POKE54296,15. Volyminställningen sträcker sig från 0 till 15 men du kommer
vanligtvis att använda 15. För att stänga av Ijudet skriv:

  POKE54296,0

 Du behöver enbart ställa in volymen EN GÅNG i början av ditt program,
eftersom inställningen aktiverar alla tre stämmorna i Commodore 64.
(Förändring av volymen under det att en ton spelas eller i en ljudeffekt
hörs kan skapa ett intressant "sound" men är utanför vad vi tar upp i denna
bruksanvisning).

 2. ADSR och VÅGFORMKONTROLLINSTÄLLNING -- Du har redan konstaterat hur en
ändring av vågform kan ändra "soundet" från "xylofon" till "cembalo". Varje
stamma har sin egen VÅGFORMKONTROLL vilken låter dig bestämma en av fyra
vågformer: Triangel, sågtand, puls (fyrkant) och brus. Kontrollen aktiverar
också Commodore 64's ADSR funktion, men vi återkommer strax om detta. Ett
prov på vågformsstart kan se så här ut:

  POKE 54276,17

där det första talet (54276) representerar kontrollen för stämma 1 och det
andra talet (17) representerar start av triangelvågform. Inställningar för
varje stämma och vågformskombination visas i tabellen nedan.


[7.6] ADSR OCH VÅGFORMINSTÄLLNINGAR

TON START/STOPP VÄRDEN

              KONTROLL   TRIANGEL     SÅGTAND      PULS        BRUS 
 +-----------+---------+-----------+-----------+-----------+-----------+
 | STÄMMA 1  |  54276  |   17/16   |   33/32   |   65/64   |  129/128  |
 +-----------+---------+-----------+-----------+-----------+-----------+
 | STÄMMA 2  |  54283  |   17/16   |   33/32   |   65/64   |  129/128  |
 +-----------+---------+-----------+-----------+-----------+-----------+
 | STÄMMA 3  |  54290  |   17/16   |   33/32   |   65/64   |  129/128  |
 +-----------+---------+-----------+-----------+-----------+-----------+
 
 Även om KONTROLLREGISTREN är olika för varje stäma är vågformsvärdena samma
för varje typ av vågform. För att förstå hur detta fungerar, se på rad 85
och 90 i programmet som spelade skalan. l detta program, direkt efter att vi
satt frekvensen på rad 80 ställde in KONTROLLINSTÄLLNINGARNA för stämma 1 på
rad 85 genom: POKE54276,17. Detta startade stämma 1 med triangelvåg (17). På
rad 70 stoppade vi tonen genom POKE54276,16. Därefter ändrade vi
VÅGFORMS-startinställningen från 17 till 33 för att skapa en sågtandsform
och detta gav skalan cembalo-"sound". Nu förstår du hur KONTROLLREGISTRET
och VÅGFORM hor ihop. Att ställa in vågform görs på samma sätt som
volyminställning, med den skillnaden att varje stämma har sin egen
inställning och att istället för att POKEa ett volymvärde definierar vi
vågformen. Nu ska vi se på en annan aspekt på ljud... ADSR-egenskapen.

 3. ATTACK/DECAY-INSTÄLLNING -- om vi nämnde tidigare, styr
KONTROLLREGISTRET inte enbart vågorna utan aktiverar också ADSR, eller
ATTACK/DECAY/SUSTAIN/RELEASE egenskaperna hos Commodore 64. Vi ska börja med
att se på ATTACK/DECAY inställningen. Tabellen nedan visar de olika
ATTACK/DECAY nivåerna för varje stämma. Om du inte är bekant med
ljuduttrycken ATTACK och DECAY kan du föreställa dig ATTACK som ett mått på
den tid det tar för en ton att nå sin högsta Ijudstyrka. Decay är motsatsen,
ett mått på hur snabbt en ton faller från sin högsta Ijudstyrka tillbaka
till SUSTAIN nivå. Följande tabell visar ATTACK/DECAY inställning. Lägg
märke till att DU MÅSTE KOMBINERA ATTACK OCH DECAY INSTÄLLNINGARNA GENOM ATT
ADDERA DEM OCH SKRIVA IN TOTALA VÄRDET. Du kan exempelvis ställa in HÖG
ATTACK och LÅG DECAY genom att addera värdet för låg attack (64) med värdet
för låg decay (2). Summan (66) talar om för datorn att ställa in högt
attack- och lågt decay-förhållande. Du kan också öka attackförhållandet
genom att addera samman dem (128 + 64 + 32 + 16 = högsta möjliga
attackförhållande = 240).


[7.7] ATTACK/DECAY-INSTÄLLNINGAR

  ATTACK/DECAY-       HÖG   MEDIUM  LÅG   LÄGSTA  HÖG  MEDIUM LÅG  LÄGSTA
  INSTÄLLNING        ATTACK ATTACK ATTACK ATTACK DECAY DECAY DECAY DECAY
 +----------+-------+------+------+------+------+-----+-----+-----+-----+
 | STÄMMA 1 | 54277 |  128 |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
 +----------+-------+------+------+------+------+-----+-----+-----+-----+
 | STÄMMA 2 | 54284 |  128 |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
 +----------+-------+------+------+------+------+-----+-----+-----+-----+
 | STÄMMA 3 | 54291 |  128 |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
 +----------+-------+------+------+------+------+-----+-----+-----+-----+

 Om du ställer in ett attackförhållande utan decay blir decay automatiskt 0,
och omvänt. Exempelvis om du skriver POKE 54277,64 sätts medium attack med
noll decay för stämma 1. Skriver du POKE 54277,66 sätter du medium attack
och lågt decay förhållande (eftersom 66 = 64 + 2 sätts båda
inställningarna). Du kan också addera flera attackvärden, eller flera
decayvärden. Du kan exempelvis addera låg attack (32) och medium attack (64)
far ett kombinerat attackförhållande av 96, därefter addera medium decay med
4 och... hokuspokus.. POKE 54277,100.
 Nu är det bäst att demonstrera effekterna genom ett kort program. Skriv
ordet NEW, tryck <RETURN>. och skriv in detta program och kör det.

   5 FOR L=54272 TO 54296:POKE L,0:NEXT 
  10 PRINT "TRYCK EN TANGENT"
  20 POKE 54296,15
  30 POKE 54277,64
  50 POKE 54273,17 : POKE 54272,37
  60 GET K$ : IF K$ = "" THEN 60
  70 POKE 54276,17: FOR T=1 TO 200: NEXT
  80 POKE 54276,16: FOR T=1 TO 50: NEXT
  90 GOTO 20

 Här har vi använt STÄMMA 1 för att skapa en ton i taget... med medium
attack och noll decay. Nyckelraden är rad 30. Genom POKE med 64 av
attack/decay inställningen aktiveras ett medium attack förhållande.
Resultatet låter som någon som studsar en boll i ett tomt oljefat. Tryck
<RUN/STOP>-tangenten och stoppa programmet. Skriv LIST och tryck <RETURN>
Skriv följande rad och tryck <RETURN>. (den nya raden 30 ersätter automatisk
den gamla raden med samma radnummer):

  30 POKE 54277,190

 Skriv ordet RUN och tryck <RETURN> så får du se hur det låter. Vad vi gjort
nu är att vi kombinerat flera attack- och decay-inställningar.
Inställningarna är: HÖG ATTACK(128) + LÅG ATTACK(32) + LÄGSTA ATTACK(16) +
HÖG DECAY(8) + MEDIUM DECAY(4) + LÅG DECAY(2) = 190.
 Detta påverkar Ijudet att låta som en oboe eller något annat
rörblåsinstrument. Om du vill experimentera, prova med att ändra vågform och
attack/decay värden i programmet som spelade skalan för att höra hur en oboe
låter. Därigenom kan du se hur förändring av attack/decay kan användas för
att skapa olika typer av ljudeffekter.

 4. SUSTAIN/RELEASE INSTÄLLNINGEN. Så som ATTACK/DECAY aktiveras av
ADSR/VÅGFORM-kontrollregistret aktiveras även SUSTAIN/RELEASE av samma
register. SUSTAIN/RELEASE låter dig "förlänga" en del av ett speciellt ljud,
på samma sätt som sustain-pedalen på en orgel eller piano förlänger tiden
innan en ton klingat ut. Vilken som helst ton eller ljudeffekt kan förlängas
vid vilken som helst av 16 ljudnivåer... du kan även sätta SUSTAIN på
maximum (240) och låta tonen spelas oändligt. SUSTAIN/RELEASE-inställningen
kan användas i en FOR... NEXT-loop för att bestämma hur länge tonen ska
hållas på SUSTAIN Ijudstyrka innan den avslutas (RELEASE). Följande tabell
visar de tal som ska POKEas för att nå olika SUSTAIN/RELEASE-förhållande.


[7.8] SUSTAIN/RELEASE-INSTÄLLNINGAR

                      SUSTAIN/RELEASE RATE SETTINGS

  SUSTAIN/RELEASE      HÖG  MEDIUM  LÅG   LÄGSTA   HÖG MEDIUM LÅG  LÄGSTA
  KONTROLLADRESS               SUSTAIN          |        RELEASE
 +----------+-------+------+------+------+------+-----+-----+-----+-----+
 | STÄMMA 1 | 54278 |  128 |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
 +----------+-------+------+------+------+------+-----+-----+-----+-----+
 | STÄMMA 2 | 54285 |  128 |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
 +----------+-------+------+------+------+------+-----+-----+-----+-----+
 | STÄMMA 3 | 54292 |  128 |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
 +----------+-------+------+------+------+------+-----+-----+-----+-----+

 Om du exempelvis använder STAMMA 1, kan du ställa in ett högt SUSTAIN-värde
genom att skriva: POKE 54278, 128 eller du kan kombinera ett högt
SUSTAIN-värde med ett lågt RELEASE-värde genom att addera 128+2 och sedan
skriva POKE 54278,130. Här kommer samma demonstrationsprogram som vi använde
i ATTACK/DECAY avsnittet tidigare... nu utökat med SUSTAIN/RELEASE. Lägg
märke till skillnaden i "sound".

   5 FOR L=54272 TO 54296:POKE L,0:NEXT
  10 POKE 54296,15
  20 POKE 54277,64
  30 POKE 54278,128
  40 POKE 54273,17 : POKE 54272,37
  50 PRINT "TRYCK EN TANGENT"
  60 GET K$ : IF K$ = "" THEN 60
  70 POKE 54276,17: FOR T=1 TO 200: NEXT
  80 POKE 54276,16: FOR T=1 TO 50: NEXT
  90 GOTO 20

 På rad 30 ber vi datorn att förlänga (SUSTAIN) tonen med HÖG SUSTAIN-nivå
(128 från tabellen ovan), varefter tonen blir RELEASEad) på rad 80. Du kan
variera tiden för en ton genom att ändra TO-värdet i rad 70. For att se
effekten av att använda RELEASE prova med att ändra rad 30 till:
POKE54278,89 (SUSTAIN:80,RELEASE=9).

 5. VÄLJA STÄMMA OCH STÄLLA IN HÖG/LÅG FREKVENS Varje individuell ton hos
Commodore 64 kräver 2 separata POKE-instruktioner... en för HÖG FREKVENS och
en för LAG FREKVENS. Tabellen över musiktonernas värde finns i bilaga M
vilken visar vilka POKE-värden som erfordras för att spela de olika tonerna
inom Commodore 64's åtta oktavområden. HÖG och LÅG-FREKVENS-kommandona är
olika för varje stämma du använder. Detta medger att du kan programmera alla
tre stämmorna var för sig för att skapa 3-stämmig musik eller exotiska
ljudeffekter.
 HÖG och LÅG-FREKVENS POKE-värde för varje stämma visas i tabellen nedan,
vilken också innehåller tonvärden för den mellersta (femte) oktaven.

                                MUSIKTONER -- FEMTE OKTAVEN
STÄMMA och    POKE- +--+--+---+---+--+---+---+--+---+---+---+---+---+---+
FREKVENS      NUMMER| C|C#| D | D#| E| F | F#| G| G#| A | A#| B | C | C#|
+-------------------+--+--+---+---+--+---+---+--+---+---+---+---+---+---+
|STÄMMA 1/HÖG|54273 |34|36| 38| 40|43| 45| 48|51| 54| 57| 61| 64| 68| 72|
|STÄMMA 1/LÅG|54272 |75|85|126|200|52|198|127|97|111|172|126|188|149|169|
+-------------------+--+--+---+---+--+---+---+--+---+---+---+---+---+---+
|STÄMMA 2/HÖG|54280 |34|36| 38| 40|43| 45| 48|51| 54| 57| 61| 64| 68| 72|
|STÄMMA 2/LÅG|54279 |75|85|126|200|52|198|127|97|111|172|126|188|149|169|
+-------------------+--+--+---+---+--+---+---+--+---+---+---+---+---+---+
|STÄMMA 3/HÖG|54287 |34|36| 38| 40|43| 45| 48|51| 54| 57| 61| 64| 68| 72|
|STÄMMA 3/LÅG|54286 |75|85|126|200|52|198|127|97|111|172|126|188|149|169|
+-------------------+--+--+---+---+--+---+---+--+---+---+---+---+---+---+

 Som du ser, finns det två inställningar för varje stämma. En HÖG- och en
LAGFREKVENS inställning. För att spela en ton meste du POKEa ett värde i
HÖGFREKVENS- och ett värde i LÅGFREKVENS-registren. Genom att använda
ovanstående tabell finner vi att inställningen för tonen C i förste stämmans
femte oktav skrives:

  POKE 54273,34:POKE 54272,75

Samma ton i stämma 2 blir:

  POKE 54280,34:POKE 54279,75

Använder vi detta i programmet ser det ut så här:

   5 FORL=54272TO54296:POKEL,0:NEXT
  10 V=54296:W=54276:A=54277:  <---- Låter adresser motsvaras av bokstav
     S=54278:H=54273:L=54272
  20 POKE V,15:POKE A,190:POKE S,89 <Sätter VOLYN, ADSR
  30 POKE H,34:POKE L,75  <--------- HÖG/LÅG FREKVENS
  40 POKE W,33:FOR T=1 TO 200:NEXT < Startar tonen, låter den spela
  50 POKE W,32  <------------------- Stänger av tonen


[7.9] SPELA ETT STYCKE PÅ COMMODORE 64

 Följande kan användas för att komponera eller spela ett musikstycke med
stämma 1. Det är två viktiga lärdomar i detta program. Lägg märke till hur
vi namnger alla de långa registeradresserna i programmets första rad.
Därefter kan vi använda bokstaven W för "VÅGFORM" istället för 54276.
 Den andra lärdomen gäller det sätt vi använder DATA. Detta program är gjort
så att du ska skriva in tre värden för varje ton: HÖG FREKVENS, LAG FREKVENS
och TIDEN som tonen ska spelas.
 För detta stycke används en tidsfördröjning av 125 för en åttondelston, 250
för en fjärdedelston, 375 för en punkterad fjärdedelston, 500 för en halvton
och 1000 för en helton. Dessa värden kan ökas eller minskas för att passa
ett speciellt tempo, eller din egen musiksmak.
 För att förstå hur ett stycke skrivs in studera rad 100. Vi skrev in 34 och
75 som HÖG och LAG FREKVENS-inställning för att spela tonen "C" (från
tabellen på föregående sida) och därefter värdet 250 för en fjärdedelston.
Därför blir den första tonen i vårt stycke en fjärdedelston "C". Den andra
tonen är också en fjärdedel, denna gång tonen "E"... och så fortsätter det
till slutet på stycket. Du kan skriva in nästan vilket stycke som helst på
detta sätt och använda så många DATA rader du behöver. Du kan fortsätta
skriva ton och varaktighetsvärden över flera rader men varje ny programrad
måste börja med ordet "DATA". DATA-1,-1,-1 ska vara den sista raden i ditt
program. Denna rad avslutar stycket.
 Skriv ordet NEW för att radera tidigare program och skriv därefter in
följande program. Skriv RUN och tryck RETURN så för då höra melodin:

MICHAEL ROW THE BOAT ASHORE -- FÖRSTA TAKTEN

start tok64 SID88.prg
5 v=54296:w=54276:a=54277:hf=54273:lf=54272:s=54278:ph=54275:pl=54274
10 POKEv,15:POKEw,65:POKEa,190:POKEph,15:POKEpl,15
20 READh
30 READl
40 READd
50 IFh=-1THENEND
60 POKEhf,h:POKElf,l
70 FORx=d-50TOd-20:POKEs,136:NEXT
80 FORt=1TOd:NEXT:POKEhf,0:POKElf,0:POKEw,0
90 GOTO10
100 DATA34,75,250,43,52,250,51,97,375,43,52,125,51,97
105 DATA250,57,172,250
110 DATA51,97,500,0,0,125,43,52,250,51,97,250,57,172
115 DATA1000,51,97,500
120 DATA-1,-1,-1
stop tok64


[7.10] SKAPA LJUDEFFEKTER

 Till skillnad från musik är Ijudeffekter ofta knutna till en speciell
programhändelse så som explosion från ett rymdskepp när det krockar med en
barriär i ett rymdspel... eller varningssurr i ett seriöst program, varnande
för att du t.ex. är på väg att radera flexskivan.
 Du har möjligheter att själv skapa olika Ijudeffekter. Här följer 10
program-idéer som kan hjälpa dig igång att experimentera med Ijudeffekter:

1. Förändra volymen under tiden tonen spelas, för att exempelvis skapa en
   ekoeffekt.
2. Variera snabbt mellan två toner för att skapa "vibrato".
3. VÅGFORM... prova olika inställningar för varje stämma.
4. Attack/Decay... för att ändra hur snabbt ljudet stiger mot högsta volym
   och hur snabbt det avtar igen.
5. Sustain/Release... för att förlänga eller minska ljudet av en ljudeffekt,
   eller för att kombinera en serie av ljud. Prova med olika inställningar.
6. Flerstämmiga effekter... spela mer än en stämma samtidigt, varje stämma
   oberoende styrd, eller en stämma spelande längre eller kortare än en
   annan, eller som tjänar som ett eko eller svar på den första tonen.
7. Förändra toner I skalan, eller byt oktav, genom att använda toner ur
   tabellen MUSIKTONERS VÄRDE.
8. Använd pulsvågform och olika pulsinställningar för att skapa olika
   Ijudeffekter.
9. Använd brusvågform för att skapa "vitt brus" för att accentuera toner
   eller för att skapa explosioner, pistolskott eller fotsteg. Samma
   musikaliska toner som skapar musiken kan också användas tillsammans med
   BRUS för att skapa olika typer av vitt brus.
10 Kombinera flera HÖG/LÅG FREKVENSER i snabb följd över flera oktaver.
11 Filter... prova det extra POKEkommandona i bilaga M.


[7.11] ENKLA LJUDEFFEKTER DU KAN PROVA

 Följande program kan användas till i stort sett alla BASIC program. De har
tagits med för att ge dig några program-idéer och demonstrera Commodore 64's
Ijudeffektegenskaper.
 Lägg märke till den programmeringsgenväg vi använder på rad 10. Vi kan
förkorta långa besvärliga ljudregisternummer genom att definiera dem som
enkla, lättanvända bokstäver (numeriska variabler). Rad 10 betyder helt
enkelt att dessa lätt ihågkommna bokstäver kan användas i stället för de
långa nummer vi använda tidigare. Här betyder V = Volym, W = vågform, A =
attack/Decay, H = hög frekvens (stämma 1), L = låg frekvens (stämma 1). Vi
använder sedan dessa bokstäver istället för siffrorna i vårt program...
vilket gör vårt program kortare, inskrivningen kortare och
ljudinställningarna lättare att komma ihåg.

DOCKGRÅT

  10 V=54296 : W=54276 : A=54277 : H=54273 : L=54272
  20 POKE V,15 : POKE W,33 : POKE A,15
  30 FOR X = 200 TO 5 STEP -2 : POKE H,40 : POKE L,X : NEXT
  40 FOR X = 150 TO 5 STEP -2 : POKE H,40 : POKE L,X : NEXT
  50 POKE W,0

LJUD AV SKOTT... med hjälp av stämma 1, brus-vågform och avtagande volym.

  10 V=54296 : W=54276 : A=54277 : H=54273 : L=54272
  20 FOR X = 15 TO 0 STEP -1 : POKE V,X : POKE W,129:
     POKE A,15 : POKE H,40 : POKE L,200 : NEXT
  30 POKE W,0 : POKE A,0


[8.] AVANCERAD DATABEHANDLING	

* READ och DATA
* Medelvärde
* Fältvariabler
* DIMensionering
* Simulerat tärningskast med indexerade fält
* Tvådimensionella fält


[8.1] READ och DATA

 Du har sett hur man tilldelar värden till variabler direkt i program (A =
2), och hur du tilldelar olika värden under tiden programmet körs -- genom
INPUT-kommandot.
 Det är trots allt många tillfällen när ingen av dessa metoder passar det du
vill göra, speciellt om det innehåller en mängd information.
 Prova detta korta program:

  10 READ X
  20 PRINT "X ÄR NU :"; X
  30 GOTO 10
  40 DATA 1, 34, 10.5, 16, 234.56

  RUN
  X ÄR NU : 1
  X ÄR NU : 34
  X ÄR NU : 10.5
  X ÄR NU : 16
  X ÄR NU : 234.56
  ?OUT OF DATA  ERROR IN 10
  READY.

 På rad 10 läser datorn med hjälp av READ ett värde från DATA-satserna och
tilldelar värdet till variabeln X. Varje gång genom programmet läses nästa
värde i DATA-satserna och det värdet tilldelas X, varefter X skrives ut med
hjälp av PRINT. En pekare i datorn håller ordning på vilket värde som ska
läsas nästa gång:

           Pekare
             |
  40 DATA 1, 34, 10.5, 16, 234.56

 När alla värden har används och datorn inte finner mer data visas
felindikering "OUT OF DATA" eftersom det inte finns mer data att läsa
(READ).
 Det är viktigt att följa exakt rätt format vid DATAsatser:

  40 DATA 1, 34, 10.5, 16, 234.56
           ^                     ^
           |                     |
    Komma separerar         Inget komma
    olika data

 Datasatser kan innehålla heltal, decimaltal eller exponentierade tal. Men
du kan inte läsa andra variabler, eller ha matematiska uttryck som
DATA-satser. Följande är fel:

  40 DATA A, 23/56, 2*5

 Du kan emellertid använda en strängvariabel i READ-satsen och sedan placera
stränginformation i DATA-satsen. Följande är acceptabelt:

  NEW

  10 FOR X = 1 TO 3
  15 READ A$
  20 PRINT "A$ ÄR NU :"; A$
  30 NEXT
  40 DATA DETTA,ÄR,KUL

  RUN
  A$ ÄR NU :DETTA
  A$ ÄR NU :ÄR
  A$ ÄR NU :KUL
  READY.

 Lägg märke till att READ denna gång var placerat inom en FOR... NEXT-
slinga. Denna slinga utfördes sedan för att passa antalet data i
DATA-satsen. I flera fall vill man ändra antalet data i DATA-satserna varje
gång programmet körs. Ett sätt att slippa räkna antalet data i DATA-satserna
och ändå undvika 'OUT OF DATA'-felindikering är att placera en "flagga" som
sista värde i DATA-satserna. Detta kan vara ett värde som din data aldrig
kan anta, såsom ett negativt tal eller ett mycket stort eller mycket litet
tal. När det värdet lästs grenar programmet ut till nästa del.
 Det finns ett sätt att återanvända samma DATA senare i programmet genom
instruktionen RESTORE som återställer datapekaren till början av datalistan.
Lägg till rad 50 till det tidigare programmet:

  50 GOTO 10

 Du kommer att få, 'OUT OF DATA', felmeddelande eftersom programmet styrs
till. baka till rad 10 för att på nytt läsa data och datapekaren indikerar
då att alla data har använts. Lägg nu till:

  45 RESTORE

 och kör programmet igen. Datapekaren blir återställd (RESTOREad) och samma
data-sats kan läsas på nytt.


[8.2] GENOMSNITT

 Följande program illustrerar en praktisk användning av READ- och
DATA-instruktionen, genom att läsa ett antal värden och beräkna dess
medelvärde.

  NEW

   5 T = 0 : CT = 0
  10 READ X
  20 IF X = -1 THEN 50 : REM KONTROLL AV FLAGGA
  25 CT = CT + 1
  30 T= T + X : REM UPPDATERA TOTAL
  40 GOTO 10
  50 PRINT "DET HAR LÄSTS"; CT ;"VÄRDEN"
  60 PRINT "TOTAL = "; T
  70 PRINT "MEDELVÄRDE ="; T/CT
  80 DATA 75, 80, 62, 91, 87, 93, 78, -1

  RUN
  DET HAR LÄSTS 7 VÄRDEN
  TOTAL =  566
  MEDELVÄRDE = 80.8571429

 Rad 5 sätter CT, räknaren och T, total till 0. Rad 10 läser ett värde och
tilldelar värdet till X. Rad 20 kontrollerar om värdet är vår "FLAGGA" (här
-1). Om det lästa värdet är giltiga data ökas CT med 1 och X adderas till
total.
 När "FLAGGAN" lästs grenar programmet av till rad 50 vilken skriver ut
antalet inlästa värden. Rad 60 skriver ut totalvärdet och rad 70 delar
totalvärdet med antalet värden för att få medeltalet.
 Genom att använda en "FLAGGA" i slutet av DATA-satserna, kan du placera
godtyckligt antal data i DATA-satserna. Dessa kan sträcka sig över ett
flertal rader utan att du behöver besvära dig med att räkna antalet
inskrivna värden.
 En variation på READ-instruktionen innebär tilldelning ur samma DATA-rad
till olika variabler. Detta medger även blandning av teckensträngar och
numeriska variabler. Du kan göra allt detta i följande program som läser
(READ) ett namn, några poäng -- exempelvis i bowling -- och skriver ut namn,
poäng och medelpoäng:

  NEW

  10 READ N$, A, B, C
  20 PRINT N$;"'S POÄNG VAR:"; A ;" "; B ;" "; C
  30 PRINT "MEDELTALET VAR: ";(A+B+C)/3
  40 PRINT : GOTO 10
  50 DATA ROLF, 190, 185, 165, OVE, 225, 245, 190
  60 DATA KENT, 155, 185, 205, KJELL, 160, 179, 187

  RUN
  ROLF'S POÄNG VAR : 190   185   165
  MEDELTALET VAR:  180

  OVE'S POÄNG VAR: 225   245   190
  MEDELTALET VAR:  220

 Datasatserna är uppställda på det sätt som READ-instruktionen förväntar sig
informationen- ett namn (en teckensträng), därefter tre numeriska värden.
Med andra ord, N$ tilldelas ordet ROLF, A i READ satsen tilldelas 190 och B
och C får 185 respektive 165. Därefter repeteras Inläsningen i samma ordning
för återstoden av informationen. (Ove och hans poäng, Kent och hans poäng
och Kjell och hans poäng).


[8.3] INDEXERADE VARIABLER

 Tidigare har vi endast använt enkla BASIC-variabler såsom, A, A$ och NU för
att representera värden. Dessa var en enkel bokstav följd av en bokstav
eller siffra.
 Det är tveksamt om du i något av de program du skulle vilja skriva kommer
att behöva fler än de kombinationer av bokstäver och siffror som finns
tillgängliga. Men du är begränsad på det sätt variabler används i program.
 Låt mig nu visa dig på egenskaperna hos indexerade variabler eller
fältvariabler:

                               A(1)
                               ^ ^
                               | |___ Index
                               |_____ Variabel

 Ovanstående uttalas: A indexerat med 1. En indexerad variabel består av en
bok. stav följt av ett index inom parenteser. Lägg märke till skillnaden
mellan A, A1 och A(1). Alla är unika. Endast A(1) är en fältvariabel.
 Fältvariabler såväl som enkla variabler betecknar ett minnesutrymme inne i
datorn. Jämför indexerade variabler med lådor att lagra information i på
samma sätt som enkla variabler

        +------------------------+
  A(0)  |                        |
        +------------------------+
  A(1)  |                        |
        +------------------------+
  A(2)  |                        |
        +------------------------+
  A(3)  |                        |
        +------------------------+
  A(4)  |                        |
        +------------------------+

Om du skrev:

  10 A(0) = 25:A(3) = 55:A(4) = -45.3

då skulle minnet se ut så här:

        +------------------------+
  A(0)  | 25                     |
        +------------------------+
  A(1)  |                        |
        +------------------------+
  A(2)  |                        |
        +------------------------+
  A(3)  | 55                     |
        +------------------------+
  A(4)  | -45.3                  |
        +------------------------+

 En fältvariabel kallas också en matris. I detta fall en endimensionell
matris eller en vektor. Senare ska vi berätta om flerdimensionella matriser.
 Index kan också vara mer komplexa och innehålla andra variabler eller
beräkningar. Följande är acceptabla fältvariabler:

  A(X)  A(X + 1)  A(2 + 1)  A(1*3)

 Uttrycken inom parenteserna beräknas enligt reglerna för aritmetiska
operationer som vi studerade i kapitel 2.
 Nu när vi fått grundreglerna klara, hur kan vi använda fältvariabler? Ett
sätt är att lagra en lista med tal som läses in i datorn med INPUT- eller
READ-instruktioner.
 Låt oss använda fältvariabler för att beräkna medelvärde på ett nytt sätt.

   5 PRINT CHR$(147)
  10 INPUT " ANTAL TAL:"; X
  20 FOR A = 1 TO X
  30 PRINT "SKRIV TALET#"; A ;: INPUT B(A)
  40 NEXT
  50 SU = 0
  60 FOR A = 1 TO X
  70 SU = SU + B(A)
  80 NEXT
  90 PRINT : PRINT "MEDELTAL ="; SU/X

  RUN
  ANTAL TAL:? 5
  SKRIV TALET# 1 ? 125
  SKRIV TALET# 2 ? 167
  SKRIV TALET# 3 ? 189
  SKRIV TALET# 4 ? 167
  SKRIV TALET# 5 ? 158

  MEDELTAL = 161.2

 Det finns möjligen enklare sätt att utföra vad vi gjorde men detta program
illustrerar väl hur fältvariabler fungerar. Rad 10 frågar hur många
variabler som ska behandlas. Denna variabel "X" fungerar som räknare för
slingan som läser in talen vilka tilldelas variabeln B. Varje gång datorn
arbetar sig genom inläsningsslingan ökas A med ett så att nästa värde
tilldelas nästa element A. Exempelvis första gången programmet löper genom
loopen är A = 1 varför första värdet tilldelas variabeln B(1). Nästa gång
har värdet på A ökat till 2 varför nästa värde tilldelas B(2) och så vidare
tills samtliga värden har lästs in. Men nu kommer vi till den stora
skillnaden. När värdena en gång lästs in lagras de i en matris, redo att
användas för olika ändamål. Tidigare lagrades endast en adderad totalsumma
varje gång programmet gick genom INPUT- eller READ-slingan. Detta hindrade
oss att gå tillbaka till speciella data utan att läsa in alla informationer
på nytt.
 På rad 50 till 80 finns en slinga som adderar upp de olika elementen i
matrisen för att därefter visa genomsnittet på skärmen. Denna del av
programmet visar att alla värden är lagrade i minnet och kan nås om så
önskas.
 För att visa att alla de olika värden verkligen är separat lagrade i en
matris, skriv följande direkt efter att programmet har körts:

  FOR A=1 TO 5 : ? B(A), : NEXT
  125        167        189        167
  158

Skärmen visar dig aktuella värden då innehållet i matrisen skrivs ut.


[8.4] DIMENSIONERING

 Om du försökte att skriva in fler än tio nummer i det förra exemplet fick
du, "DIMENSION ERROR", felmeddelande. Matriser upp till 11 element (index 0
till 10 för en endimensionsmatris) kan användas när man vill, lika enkelt
som en vanlig variabel. Matriser med mer än 11 element måste DIMensioneras.
 Lägg till denna rad till ditt program:

   5 DIM B(100)

 Detta talar om för din dator att du kommer att behöva plats för maximalt
100 element i matrisen B.
 Dimensioneringsinstruktioner kan också användas tillsammans med en
variabel. Följande rad kan ersätta rad 5, (glöm inte att ta bort rad 5).

  15 DIM B(X)

 Detta DIMensionerar matrisen för exakt det antal värden som behövs. Var
emellertid försiktig. När en matris en gång är dimensionerad kan den inte
ändras i en annan del av programmet. Du kan emellertid ha flera matriser i
ett program och dimensionera dem alla på samma rad.

  10 DiM C(20), D(50), E(40)


[8.5] SIMULERAT TÄRNINGSKAST

 Då programmen blir större hjälper indexerade variabler till att begränsa
antalet erforderliga instruktioner och gör programmet enklare att skriva.
 En endimensionell matris kan användas, som i nedanstående exempel, för att
hålla rätt på hur många gånger en speciell sida kommer upp vid tärningskast:

start tok64 SID99.prg
1 PRINT CHR$(147):REM simulera tarningskast
10 INPUT"antal kast";x
20 FOR l = 1 TO x
30 r = INT(6*RND(1))+1
40 f(r)=f(r)+1
50 NEXTl
60 PRINT"sida","antal ganger"
70 FOR c = 1 TO 6 :PRINT c, f(c):NEXT
stop tok64

 Matrisen S, för sida, används för att hålla reda på hur många gånger en
speciell sida kommer upp. Exempelvis varje gång en tvåa kommer upp, ökas
S(2) med 1. Genom att använda index som numret på den sida som kommer upp,
har vi eliminerat behovet av sex andra variabler (en för varje sida) och ett
antal instruktioner för att kontrollera vilket nummer som kom upp.
 Rad 10 frågar hur många kast du önskar simulera.
 Rad 20 sätter upp en slinga för att simulera, (d.v.s. "låtsas" vara en
tärning genom att generera ett slumptal från 1 till 6) ett tärningskast och
räkna upp rätt variabel beroende på vilken sida som kommer upp.
 Efter alla kast är klara skriver rad 60 ut överskriften och rad 70 det
antal gånger varje sida kommit upp.
 En körning kan se ut så här:

  ANTAL KAST? 1000
  SIDA       ANTAL GÅNGER
   1          174
   2          168
   3          179
   4          156
   5          162
   6          161

 Bara som en jämförelse ska vi se hur vi kan skriva programmet utan att
använda matriser. Bry dig inte om att skriva in det, men lägg märke till de
ytterligare programinstruktioner som erfordras.

  10 INPUT "ANTAL KAST"; X
  20 FOR L = 1 TO X
  30 R = INT(6*RND(1))+1
  40 IF R = 1 THEN F1 = F1 + 1 : NEXT
  41 IF R = 2 THEN F2 = F2 + 1 : NEXT
  42 IF R = 3 THEN F3 = F3 + 1 : NEXT
  43 IF R = 4 THEN F4 = F4 + 1 : NEXT
  44 IF R = 5 THEN F5 = F5 + 1 : NEXT
  45 IF R = 6 THEN F6 = F6 + 1 : NEXT
  60 PRINT "SIDA", "ANTAL GÅNGER"
  70 PRINT 1, F1
  71 PRINT 2, F2
  72 PRINT 3, F3
  73 PRINT 4, F4
  74 PRINT 5, F5
  75 PRINT 6, F6

 Programmet har dubblat sin storlek från 8 till 16 rader. I större program
kommer, om matriser används, besparingar att bli ännu mer dramatiska.


[8.6] TVÅDIMENSIONELLA FÄLT

 Tidigare i detta kapitel experimenterade du med endimensionella fält. Denna
typ beskrevs som en grupp av efter varandra följande lådor som vardera
lagrade ett element i fältet. Hur tror du att ett tvådimensionellt fält ser
ut?
 Ett två-dimensionellt fält skrivs enligt följande:

                              A(4,6)
                              ^ ^ ^
                              | | |
                              | Index
                              |
                          Fältbeteckning

och kan beskrivas som en tvådimensionell matris i minnet:

             0       1       2       3       4       5       6
         +-------+-------+-------+-------+-------+-------+-------+
    0    |       |       |       |       |       |       |       |
         +-------+-------+-------+-------+-------+-------+-------+
    1    |       |       |       |       |       |       |       |
         +-------+-------+-------+-------+-------+-------+-------+
    2    |       |       |       |       |       |       |       |
         +-------+-------+-------+-------+-------+-------+-------+
    3    |       |       |       |       |       |       |       |
         +-------+-------+-------+-------+-------+-------+-------+
    4    |       |       |       |       |       |       |       |
         +-------+-------+-------+-------+-------+-------+-------+

 Indexen kan ses som de motsvarade rad- och kolumnnumren i ovanstående figur
där fältens olika element lagras.

                              A(3,4) = 255
                                ^ ^
                                | |___ Kolumn
                                |
                               Rad

 Om vi tilldelade värdet 255 till A(3,4) kan vi se det som värdet 255
placerades i tredje radens fjärde kolumn i ovanstående figur.
 Tvådimensionella fält följer samma regler som vi lärt för de
endimensionella fälten:

De måste dimensioneras:                   DIM A(20,20)
Kan tilldelas data:                       A(1,1) = 255
Kan tilldela data till andra variabler:   AB = A(1,1)
Kan skriva ut värden:                     PRINT A(1,1)

 Om två-dimensionella fält fungerar på samma sätt som endimensionella fält
vilka ytterligare fördelar ger då dessa större fält?
 Prova detta: Kan du tänka ut ett sätt att använda ett tvådimensionellt fält
för att ställa upp svaren på en frågelista för din klubb? Listan innehåller
fyra frågor med upp till tre svar på varje fråga. Problemet kan skrivas så
här:

                           FRÅGOR TILL MEDLEMMARNA

                          1. FÖREDRAR DU FÖRSLAG 1?

                          _1-JA  _2-NEJ  _3-VET EJ

                             ... och så vidare.

matrisen för detta problem kan ritas upp på detta sätt:

                                        SVAR

                        JA              NEJ            VET EJ

                +----------------+----------------+----------------+
  FRÅGA 1       |                |                |                |
                +----------------+----------------+----------------+
  FRÅGA 2       |                |                |                |
                +----------------+----------------+----------------+
  FRÅGA 3       |                |                |                |
                +----------------+----------------+----------------+
  FRÅGA 4       |                |                |                |
                +----------------+----------------+----------------+

 Själva programmet som utför uppställningen för frågeformuläret kan se ut
så här:

start tok64 SID103.prg
20 PRINT"{clear}":REM clr/home
30 FOR r = 1 TO 4
40 PRINT"fraga nr:";r
50 PRINT"1-ja{space*2}2-nej{space*2}3-vet ej"
60 PRINT"vilket var svaret ?";
61 GET c:IF c <1 OR c >3 THEN 61
65 PRINTc:PRINT
70 a(r,c) = a(r,c) + 1:REM uppdatera element
80 NEXT r
85 PRINT
90 PRINT"vill du skriva ytterligare svar":PRINT"(j/n)";
100 GETa$:IF a$ = "" THEN 100
110 IF a$="j" THEN 20
120 IF a$<> "n"THEN 100
130 PRINT"{clear}";"totala antalet svar var:":PRINT
140 PRINT SPC(19);"svar":PRINT
141 PRINT"fraga","ja","nej","vet ej"
142 PRINT"{-*5}{space*2}{-*29}"
150 FOR r = 1 TO 4
160 PRINT r,a(r,1),a(r,2),a(r,3)
170 NEXT r
stop tok64

  RUN

  FRÅGA NR: 1
  1-JA  2-NEJ  3-VET EJ
  VILKET VAR SVARET ? 1
  FRÅGA NR: 2
  1-JA  2-NEJ  3-VET EJ
  VILKET VAR SVARET ? 1


  och så vidare...


  TOTALA ANTALET SVAR:

  FRÅGA     JA       NEJ       VET EJ
  -----  ----------------------------
   1        4         3        2
   2        4         2        3
   3        6         1        2
   4        5         4        0

 Detta program använder sig av flera av de programmeringsrutiner vi gått
igenom tidigare. Även om du inte har någon användning för det aktuella
programmet bör du försöka förstå funktionen.
 Programmets kärna är ett 4 gånger 3 två-dimensionellt fält, A(4,3). Totala
antalet svar för varje möjlig variant av svar lagras i motsvarande
fältelement. För att göra det enklare använder vi inte första raden och
kolumnen A(0,0) till A(0,4). Kom emellertid ihåg att dessa element alltid
finns med när du gör matriser.
 I verkligheten, om svaret på fråga 1 är JA, Ökas A(1,1) med 1 -- rad 1 för
fråga ett och kolumn 1 för JA-svar. Resten av frågor och svar följer samma
monster.
 Ett NEJ-svar för fråga 3 skulle alltså addera 1 till elementet A(3,2) och så
vidare.


BILAGOR


[A.] BILAGA A

EXTRAUTRUSTNINGAR FOR DITT SYSTEM

 Från Commodore kan du få många olika extra utrustningar, utvidgar din
dators kapacitet. Det kan t ex vara:

* lagringsenheter
* skrivare och ritare
* monitorer
* modem för telekommunikation
* speltillsatser
* tal- och grafik-tillsatser


LAGRINGSENHETER

Diskettstationer

 Commodore's diskettstationer låter dig lagra stora mängder information på
5¼-tumsdisketter. Disketter ger snabb lagring och återhämtning och de håller
automatiskt reda på alla dina filer i en katalog eller innehållsförteckning,
som du kan ta fram och se på bildskärm eller skrivare.
 Dessutom kan du öka ut systemet med extra diskettstationer genom att
kedjekoppla dem till din dator. Kedjekoppling innebär att man förbinder en
diskettstation med datorn och därefter ansluter en annan diskettstation till
denna o s v.
 Genom att skaffa dig Commodore 64 IEEE Expansionskort (SUPERBOX) kan du
också använda en IEEE-station som t ex Commodore's CBM 8050 eller 4040
dubbeldiskettstationer till din C-64.
 Kapitel 2 innehåller detaljerad information om hur du använder
diskettstationer.


UTSKRIFTS- OCH RITNINGS-ENHETER

Skrivare

 Du kan ansluta Commodore's skrivare till din C-64. Dessa är billiga
matrisskrivare. Genom att använda Commodore 64 IEEE Expansionskort
(SUPERBOX), kan du också ansluta varje IEEE-skrivare som t ex Commodore's
6400 skönskrivare eller höghastighetsskrivaren 8023 till C-64.

Skrivare/Ritare

 Commodore's 1520 Skrivare/Ritare skriver ut och ritar grafik i fyra färger
(svart, blad, rött och grönt). Med 1520 kan du rita stapeldiagram,
"tårtdiagram" och varierande invecklad grafik.


MONITORN 1701/1702

 Commodore's 14-tums färgmonitor erbjuder en överlägsen färgbild med hög
upplösning som underlättar ditt arbete vid datorn. Monitorn kan anslutas
till C64:an med en 8-stifts DIN-kabel. Användarhandboken för 1701/1702
Färgmonitor som medföljer förklarar anslutningarna utförligt. Du kan också
se i Appendix I för information om kontaktstiften i 8-stiftskontakten.


TILLSATSER FÖR SPEL OCH ANDRA ANVÄNDNINGAR

 Commodore har sk joysticks (manöverspakar) och paddles (manöverrattar i
par), som underlättar spelstyrning på din dator. Dessa tillsatser kan också
användas i andra tillämpningar.
 Det finns också en ljuspenna, som med lämpligt program låter dig
kommunicera med datorn via bildskärmen.


COMMODORE'S GRAFIK-HJÄLPMEDEL

 Commodore tillhandahåller en stor mängd hjälpmedel för grafikprogrammering,
inklusive SIMONS' BASIC som ökar ut BASIC med 114 nya kraftfulla kommandon
och LOGO, ett lättlärt programspråk för s k TURTLE-grafik.
 Dessutom finns den i dag bästa versionen av programspråket COMAL i en
plugin-modul till C-64. COMAL erbjuder strukturerad "riktig" programmering,
såväl som grafikinstruktioner liknande och bättre än dem i LOGO.


MUSIKTILLSATSER

 Commodore erbjuder också ett särskilt tangentbord för musik och en 3-delad
trumtillsats som kallas DlGI-DRUM(tm). Båda produkterna kommer med särskilda
programpaket. Dessa tillsatser kommer att öka möjligheterna att producera
musik i din C-64.


UPPKOPPLING MOT ETT STEREO-SYSTEM

 Ljud- och musik-möjligheterna hos C-64 kan ytterligare förbättras genom att
man förbinder sin dator med ett högklassigt förstärkar- och stereosystem.
Den B-poliga DIN-kabeln, som nämndes i samband med 1701/1702 Färgmonitor,
kan också användas för att förbinda datorn med en förstärkare.


UPPSÄTTNING AV ETT DATORSYSTEM FOR DINA BEHOV

 Commodore erbjuder en mängd yttre enheter, som låter dig skapa ditt eget
personliga datorsystem. Vi erbjuder olika slags lagrings-, utskrifts- och
telekommunikationsenheter så att du kan välja det som passar bäst för dig.
För mer information om dessa enheter, hör med din Commodore-handlare!


[B.] BILAGA B

AVANCERAD KASSETTHANTERING

 Förutom att spara kopior av dina program på kassettband, kan Commodore 64
också lagra variabler och annan data, i en grupp som kallas "fil". Detta
medger att du kan lagra mer information än sådan som på en gång kan lagras i
datorns arbetsminne.
 Instruktioner som används vid bruk av datafiler är OPEN, CLOSE, PRINT#,
INPUT# och GET#. Systemvariabeln ST (status) används för att kontrollera
tapemarkeringar.
 När man skriver data till bandstationen används samma system som när man
visar information på skärmen. Men i stället för att skriva på skärmen skrivs
informationen på bandet med hjälp av en variant av PRINT-kommandot --
PRINT#.
 Följande program visar hur det går till:

10 PRINT "SKRIV TILL TAPE PROGRAM"
20 OPEN 1,1,1,"DATA FILE"
30 PRINT "SKRIV DATA ELLER STOPP"
50 PRINT
60 INPUT "DATA";A$
70 PRINT#1,A$
80 IF A$<>"STOPP" THEN 50
90 PRINT
100 PRINT "STÄNG FIL"
110 CLOSE 1

 Det första vi måste göra är att öppna en fil (i detta fall en DATA FILE).
Rad 20 utför detta.
 Programmet bäntar på rad 60 på den data du vill spara på tape. Rad 70
skriver vad du skrivt in -- i form av variabel A$ -- till bandet. Denna
fortsätter kontinuerligt.
 Om du skriver "STOPP", stänger rad 110 filen.
 För att återfå informationen, spola tillbaka bandet, och prova följande:

10 PRINT "READ TAPE PROGRAM"
20 OPEN 1,1,0,"DATAFIL"
30 PRINT "FILE OPEN"
40 PRINT
50 INPUT#1,A$
60 PRINT A$
70 IF A$="STOPP" THEN END
80 GOTO 40

 Även här öppnas först en "DATAFIL". Rad 50 hämtar in data från bandet uner
variabelbeteckningen A$ occh rad 60 skriver ut A$ på skrämen. Detta
fortsätter till dess "STOPP" läses vilket avslutar programmet.
 En variation av GET -- GET# -- kan också användas för att läsa tillbaka
data från bandet. Ersätt raderna 50-80 i ovanstående program med:

50 GET#1,A$
60 IF A$="" THEN END
70 PRINT A$, ASC(A$)
80 GOTO 50


[C.] BILAGA C:

Commodore 64 BASIC

 Denna handbok har hittills introducerat för dig ett fåtal kommandon i
språket BASIC. Du vet litet om programmering och hur program ser ut. l denna
bilaga finns en komplett lista på alla regier (dvs den SYNTAX) som gäller
för de olika BASIC-kommandona, plus en beskrivning av vad de utför. Du
rekommenderas an experimentera med alla kommandon för att komma ihåg att du
inte kan skada din C-64 genom att skriva program. Det bästa sättet att lära
sig är att undersöka saker.
 Denna bilaga har delats upp i fyra olika delar. Dessa delar är:

1. Variabler och operationer: beskriver olika typer av variabler och de
   olika aritmetiska och logiska operationer som kan göras på dessa.
2. Kommando: beskriver de kommandon som används för att arbeta med
   programmen, editera, spara och radera dem.
3. Programinstruktioner: beskriver de kommandon som används i programmen.
4. Funktioner: beskriver sträng- och numeriska utskriftsfunktioner.

 I varje sektion finner du kommandona listade i bokstavsordning. En komplett
beskrivning av alla BASIC-kommandon finner du i C-64ans
programmeringshandbok. Den finns där du köpte din dator.


1. VARIABLER OCH OPERATIONER

a. Variabler

 C-64an använder tre typer av variabler i BASIC. Dessa är: decimaltal,
heltal och strängvariabler.
 DECIMALTAL är numeriska variabler inom området 10E-38 till 10E+38 med en
noggrannhet av nio siffror. När talet blir längre än 9 siffror skrivs det ut
i exponentform: Ett tal med en siffra och 8 decimaler följt av ett E och ett
tal som är 10-exponenten av talet. Till exempel, kommer talet 123456789001
att skrivas som 1.2345689E+11.
 HELTAL är variabler för tal inom intervallet -32768 till 32767, utan
decimaler. En heltalsvariabel kräver mindre plats i minnet. Skillnaden är
inte värd att lägga märke till om du inte har stora mängder med variabler i
så kallade matriser. Exempel på heltal är 5, 10 och -103.
 STRÄNGAR eller TEXTSTRÄNGAR används för att lagra tecken av olika slag,
bokstäver, siffror eller andra tecken som VIC kan skriva ut. Ett exempel på
en strängvariabel är "Commodore 64".
 Ett variabelnamn kan bestå av en eller två bokstäver eller också av en
bokstav följt av en siffra. Egentligen kan det vara längre, men datorns
Basic "ser" bara de två första tecknen.
 En heltalsvariabel specificeras genom att variabelnamnet följs av ett
%-tecken. Strängvariabler har ett $-tecken som sista tecken i namnet.

EXEMPEL:
Namn på: A, A5, BZ
Namn på heltal: A%, A5%, BZ%
Namn på strängar: A$, A5$, BZ$

 MATRISER används för att samla ihop en större mängd variabler under samma
namn. Detta gör man genom att använda ett antal extra siffror i
variabelnamnet. Vilken typ av variabel och hur många anges i DlM-kommandot.
Alla typer av variabler kan användas. Efter DlM-kommandot anges
variabelnamnen och inom parentes hur många variabler de får innehålla.

EXEMPEL: DIM A(7), BZ%(11), A$(87)

 Matriserna kan ha mer än en dimension. En tvådimensionell matris kan ses
som en tabell med rader och kolumner där första siffran innanför parentesen
anger raden och den andra kolumnen.

EXEMPEL: DIM A(7,2), BZ%(2,3,4), Z$(3,2)

Det finns tre variabelnamn som är reserverade för C-64ans interna bruk och
normalt inte kan användas. Dessa variabler är ST, Tl och TI$. ST är en
status(läges)variabel för kommandon som berör in/ut-operationer. Värdet på
ST kommer till exempel att ändra sig när det är problem med en
programladdning från kassettband eller flexskivminne. En mera detaljerad
beskrivning av ST finns i programmeringshandboken för C-64an.
 Tl OCH TI$ är variabler som berör den inbyggda klocka som finns i C-64an.
Variabeln Tl ökas med 1 varje 1/60 sekund. Den börjar på noll när din C-64
slås på. Värdet kan endast ändras genom att förändra värdet i Tl$.
 Tl$ är en sträng som kontinuerligt uppdateras av systemet. De första två
tecknen innehåller antalet timmar, det tredje och fjärde antalet minuter och
det femte och sjätte antalet sekunder. Denna variabel kan ges ett annat
värde (så länge tecknen är siffror) och kommer automatiskt att uppdateras
från detta tal.

EXEMPEL: Tl$ = "101530" ställer klockan till 10:15:30.

 Klockan nollställs när datorn slås på.


b. OPERATIONER

De aritmetiska operationerna anges med följande tecken:

  +  addition
  -  subtraktion
  *  multiplikation
  /  division
  ^  exponentiering eller potensupphöjning

 På en rad som innehåller flera utförs operationerna i en bestämd ordning.
Om flera operatorer används tillsammans ger datorn följande
prioritetsordning på dem: Först exponering, sedan multiplikation och
division, och sist addition och subtraktion. Om du vill att operationerna
skall ske i en viss ordning, tillåter C-64ans BASIC att du isolerar en
beräkning genom att omge den med parenteser. Operationer inom parentes görs
först av alla. Var noga med att formeln innehåller lika många
vänsterparenteser som högerparenteser, annars får du ett "SYNTAX ERROR" när
du kör programmet.

Det finns också operatorer för att jämföra två värden:

  =            lika med
  <            mindre än
  >            större än
  <= eller =<  mindre eller lika med
  >= eller =>  större eller lika med
  <> eller <>  inte lika med

Till slut så finns det tre logiska operaturer:

  AND
  OR
  NOT

 Dessa används oftast för att lägga ihop flera villkor i ett
IF...THEN-kommando.

EXEMPEL:

IF A=B AND C=D THEN 100 både A=B och C=D skall vara sanna.
IF A=B OR C=D THEN 100 någon av A=B eller C=D skall vara sann.


2. KOMMANDON

CONT (continue = fortsätt)

 Kommandot används för att starta upp ett program där programmet blev
avbrutet t ex genom att STOP-tangenten trycktes, ett STOP eller END-kommando
i programmet. Programmet körs igång på samma ställe där det blev avbrutet.
 CONT fungerar inte om du ändrat något i programmet inte ens om du bara
flyttat markören upp till en rad och tryckt RETURN utan att ändra någonting
i raden. Inte ens om programmet stannades genom ett fel, eller om du gör ett
fel innan du kör igång programmet med CONT. I dessa fall svarar C-64an med
"CAN'T CONTINUE  ERROR".

LIST

 LIST-kommandot tillåter att du tittar på de programrader som du skrivit
eller laddat in i C-64ans minne. Skriver du LlST-kommandot utan några
siffror kommer hela programmet att listas ut på din skärm.
(Listningshastigheten kan sänkas genom att trycka på CTRL eller stoppas
genom att trycka på STOP-tangenten.) Om LIST fölls av ett radnummer listas
endast raden med det numret ut. Anges två nummer med ett streck emellan
listas alla rader mellan dessa två nummer ut. Skriver du LIST med ett nummer
följt av ett streck listas raderna från och med denna rad till programmets
slut. Och skriver du LIST med ett streck och ett nummer listas alla rader
till och med det numret. Med dessa variationer på kommandot kan du lista
vilken del av programmet du vill och få fram raderna på skärmen för att göra
ändringar.

EXEMPEL:

  LIST        Listar hela programmet.
  LIST 10-    Listar rad 10 till programmets slut.
  LIST 10     Listar rad 10.
  LIST -10    Listar programmet från början till rad 10.
  LIST 10-20  Listar rad 10 till 20.

LOAD

 Detta kommando används när du har ett program på kassettband eller
flexskiva och vill hämta programmet för att köra det. Om du bara skriver
LOAD och trycker RETURN, kommer C-64an att ladda in det första program den
hittar på kassettbandet. Programmet kan du sedan köra, lista eller göra vad
du vill med. Du kan också skriva LOAD följt av ett programnamn mellan
citationstecken. Efter citationstecknet kan du lägga till ett kommatecken
och ett tal eller en numerisk variabel som visar varifrån programmet skall
laddas. Om inget nummer anges antar C-64an att den skall ladda från enhet nr
1, kassettenheten.
 En annan vanlig enhet som program laddas in från är flexskivminnet, enhet
nr 8.

EXEMPEL:

  LOAD             Läser in första programmet från kassettbandet.
  LOAD "HEJSAN"    Söker efter programmet med namnet "HEJSAN" på
                   kassettbandet och läser in det om den hittar det.
  LOAD A$          Söker efter programmet med namnet som finns i A$ och
                   läser in det.
  LOAD "HEJSAN",8  Söker efter programmet med namnet HEJSAN" flexskiveminnet.
  LOAD "*",8       Laddar in det första programmet på flexskivan.

 LOAD-kommandot kan användas i ett program för att ladda in och köra nästa
program på bandet.

NEW

 Detta kommando raderar hela programmet som ligger i C-64ans minne och
nollställer alla variabler som har använts. Om du inte tidigare sparat undan
programmet på kassettband eller flexskiva så är ditt program borta för evigt
om du inte skriver in det igen. VAR FÖRSIKTIG när du använder detta
kommando!
 NEW-kommandot kan också användas i programmet. När C-64an kommer fram till
detta kommando raderar den allt som finns i minnet och stannar. Detta är bra
om man vill lämna allt städat och klart när ett program har körts.

RUN

 När du har ett program i minnet och vill köra det, skriver du RUN och
C-64an börjar utföra alla kommandon i programmet. Om inget radnummer anges
börjar C-64an på raden med det lägsta numret. Om numret finns börjar
körningen på det radnumret.

EXEMPEL:

  RUN      Programmet kör igång från första raden.
  RUN 100  Programmet kör igång i rad 100.
  RUN X    SYNTAX ERROR (Du måste alltid skriva ut numret och inte använda
           bokstäver.)

SAVE

 Detta kommando sparar undan det program som för tillfället finns i C-64ans
minne på kassettband eller flexskiva. Skriver du bara SAVE försöker C-64an
att spara programmet på kassettbandet. Det finns ingen kontroll att bandet
redan innehåller ett program, så var försiktig så inget program går förlorat
när du sparar ditt program. Om du anger ett namn efter SAVE-kommandot så
skrivs det namnet in på bandet eller flexskivan. Det blir då enklare att
hitta programmet när du skall hämta det igen. Efter namnet, mellan
citationstecknen, kan du lägga till ett kommatecken och ett nummer eller en
variabel. Numret talar om på vilken enhet som programmet skall sparas. Enhet
nummer 1 är kassettenheten och nummer 8 är flexskivminnet. Efter det första
numret kan det läggas ett kommatecken och ett nummer till, som kan vara 1
eller 2. Om numret är en 2:a skrivs end slut på bandet markering (end of
tape) in på bandet. Om C-64an söker efter ett program och finner denna
markering så skriv "FILE NOT FOUND ERROR" ut.

EXEMPEL:

  SAVE              Sparar programmet på kassettband utan namn.
  SAVE "HEJSAN"     Sparar programmet med namnet HEJSAN på bandet.
  SAVE A$           Sparar programmet med namnet som finns i A$.
  SAVE "HEJSAN",8   Sparar programmet med namnet HEJSAN på flexskivan.
  SAVE HEJSAN",1,2  Sparar programmet med namnet HEJSAN och lägger in en
                    "end of tape" dvs bandslut-markering på bandet.

VERIFY

 Detta kommando gör att C-64an går tillbaka och jämför programmet på bandet
eller flexskivan med det i minnet. Har programmet utförts utan klagomål så
är det ett bevis på att ditt program blev sparat korrekt. Det kunde ha varit
ett dåligt band du sparade programmet på. Detta kommando är bra om du vill
lägga in ett program på första tomma position på bandet. Vad du gör är att
säga åt VIC att jämföra det sista programmet med det i minnet. Detta kommer
den att göra och upptäcka att programmen inte stämde överens, vilket du
redan visste. Nu är bandet där du vill ha det. Nu kan du spara nästa program
utan någon risk att förstöra något annat program.
 Enbart VERIFY gör att C-64an jämför det första program den hittar på
bandet, oavsett namn, med det som finns i minnet. VERIFY med ett namn eller
citationstecken söker efter programmet med det namnet för att jämföra det
med minnet. Dessutom kan du lägga till ett kommatecken och ett nummer elkar
en variabel som talar om för C-64an vilken enhet den skall söka på (1 för
kassettband, 8 för flexskiva).

EXEMPEL:

  VERIFY             Jämför med nästa program på band.
  VERIFY "HEJSAN"    Söker efter "HEJSAN" på band, och jämför det med
                     minnet.
  VERIFY "HEJSAN",8  Söker efter "HEJSAN" på flexskiva, och jämför det med
                     minnet.


3. PROGRAMINSTRUKTIONER

CLOSE

 Detta kommando stänger en fil som du tidigare öppnat med OPEN-kommandot.
Det nummer som följer efter kommandot är det filnummer som skall stängas.

EXEMPEL:

  CLOSE 2  Endast fil nr 2 stängs.

CLR

 Kommandot raderar alla variabler som finns i minnet, men lämnar programmet
intakt. Detta kommando utförs automatiskt när du kör i gång programmet
(RUN).

CMD

 Ändrar den normala utenheten (skärmen) till en annan. Alla PRINT- och
LlST-utskrifter kommer istället att göras på den angivna enheten. Denna
enhet kan vara en skrivare, kassettenhet, flexskivminne eller något annat.
Innan CMD-kommandot utföres måste en fil öppnas till önskad enhet (OPEN). I
CMD-kommandot skall anges filnumret som använts i OPEN-satsen.

EXEMPEL:

  OPEN 1,4  Öppnar en fil till enhet nr 4 (skrivare).
  CMD 1     All normal utskrift går nu till skrivaren.
  LIST      Listningen av programmet går ut till skrivaren, inte till
            skärmen - till och med ordet LIST.

 För att få tillbaka utskriften till skärmen, stäng bara filen, men
observera att före CLOSE-satsen måste skrivas en PRINT#-sats till den
aktuella filen.

DATA

 Kommandot följs av en lista med data som används av kommandot READ. Data
kan vara numeriska variabler eller text och separeras med kommatecken. Text
behöver inte omges av citationstecken, om inte texten innehåller något av
följande tecken: Blanktecken, kolon, kommatecken. Om det finns två
kommatecken utan någonting mellan dem, tas det som värdet 0 eller en tom
textsträng.

EXEMPEL:

DATA 100,100,FRED,"HEJ MAMMA",,3.14,ABC123

 Eftersom DATA-kommandot inte behöver utföras för att data skall bli läsbar,
så är det en god idé att lägga alla DATA-kommandon sist i programmet. Detta
gör att ditt program går fortare att köra.

DEF FN

 Med detta kommando kan du definiera en komplex funktion som du sedan kan
anropa i programmet på ett enkelt sätt. Så här kan mycket plats sparas i
programmet om det innehåller samma beräkning flera gånger.
 Funktionens namn blir FN plus ett variabelnamn (1 eller 2 tecken). Först
måste funktionen definieras genom att du skriver DEF följt av
funktionsnamnet. Efter namnet följer ett par med parenteser med en variabel
innanför (i exemplet ett X). Därefter kommer likhetstecknet och formeln för
funktionen. När du vill använda funktionen byter du ut X mot det aktuella
värdet, som i rad 20 i exemplet nedan:

EXEMPEL:

  10 DEF FNA(X)=12*(34.75-X/.3) <--- Asterisk används som
                          ^-.        multiplikationstecken
  20 PRINT FNA(7) <---------+- Talet 7 byts mot X i formeln

DIM

 Innan du kan använda matrisvariabler som har fler än 11 variabler, måste
ett DlM-kommando utföras för matrisvariabeln. DlM-kommandot följs av
variabelnamnet på matrisen (ett normalt variabelnamn, 1 eller 2 tecken).
Efter namnet kommer två parenteser med värden (eller numeriska variabler)
innanför, som betecknar antalet variabler i varje dimension. Antalet
dimensioner är inte begränsat, men kom ihåg att minnesutrymmet inte räcker
till för hur stora matriser som helst. För att beräkna antalet variabler som
ett DlM-kommando skapar så multiplicerar du antalet element i varje
dimension i matrisen.

EXEMPEL:

  10 DIM A$(40),B7(15),CC%(4,4,4)  <-- 125 element
           ^       ^
   41 element    16 element

 Du kan dimensionera fler matriser i samma DlM-kommando genom att separera
dem med kommatecken. Om programmet försöker att utföra ett DlM-kommando på
samma variabel mer än en gång, får du ett felmeddelande. Det är bäst att
placera DlM-kommandot i början på programmet.

END

 När C-64an kommer till detta kommando på en rad slutar den att köra
programmet precis som om det vore sista raden i programmet. Du kan använda
CONT-kommandot för att starta upp programmet igen.

FOR...TO...STEP

 Detta kommando används tillsammans med NEXT för att lägga upp en sektion i
programmet som skall repeteras ett antal gånger (en loop eller slinga). Du
vill kanske bara att C-64an räknar upp till ett högt tal, för att få den att
vänta ett tag (tidsfördröjning), eller du kanske vill räkna någonting. Detta
är det mest förekommande BASIC-kommandot i programmen.
 Uppställningen för kommandot är följande:
 FOR (loopvariabel) = (startvärde) TO (slutvärde). Loopvariabel är en helt
vanlig variabel som kan ändras under pågående loop. Start och slutvärdet är
gränserna för loopvariabeln.
 Följande händer vid FOR-kommandot. Loopvariabel tilldelas värdet
"startvärde". Slutvärdet lagras undan i C-64an för senare referens. När
datorn kommer fram till ett NEXT-kommando, ökar den värdet av loopvariabeln
med 1. Variabeln jämförs sedan med slutvärdet. Om loopvariabeln inte är
större än slutvärdet hoppar C-64an tillbaka till raden efter FOR-kommandot.
Är loopvariabeln större fortsätter C-64an med nästa rad efter
NEXT-kommandot.

EXEMPEL:

  10 FOR L=1 TO 10
  20 PRINT L
  30 NEXT L
  40 PRINT "FÄRDIG! L="L

 Detta program skriver ut talen från 1 till 10 på skärmen följt av
meddelandet "FÄRDIG! L=11". Förstår du hur det fungerar? Om inte, läs då
igenom texten och följ med i programmet steg för steg.
 Slutvärdet kan följas av ordet STEP och ett värde eller en variabel. I
detta fall kommer C-64an att använda värdet och addera till loopvariabeln
vid NEXT-kommandot (istället för 1). Detta gör det möjligt att räkna
baklänges eller med decimaler.
 Du kan lägga upp slingor inuti en annan slinga. Detta kallas för kapslade
slingor. Du skall vara försiktig vid kapslade slingor och komma ihåg att den
första slingan slutar sist.

EXEMPEL:

  10 FOR L=1 TO 100
  20 FOR A=5 TO 11 STEP 2  <--+- Denna FOR...NEXT-loop är nästlad innanför
  30 NEXT A   <---------------'  den större
  40 NEXT L

Felaktigt:

  10 FOR L=1 TO 100
  20 FOR A=5 TO 11 STEP 2
  30 NEXT L
  40 NEXT A

GET

 GET-kommandot används för att läsa data från tangentbordet, ett tecken i
taget. När GET-kommandot utföres läses det tecken som trycks på
tangentbordet in. Har ingen tangent tryckts ned, fås ett "tomtecken"
tillbaks. RETURN-tangenten behöver inte tryckas ned för att inläsning skall
ske (jämför INPUT). RETURN kan också läsas av.
 Efter ordet GET så följer ett variabelnamn, vanligen en strängvariabel.
Används en numerisk variabel kommer C-64an att svara med ett felmeddelande
(om någon annan än en siffertangent trycks ned). GET används mest för att
konstruera en slinga som väntar på att en tangent skall tryckas ned.

EXEMPEL:

  10 GET A$:IF A$="" THEN 10 <--- Denna rad väntar på att en tangent ska
                                  tryckas ned. Trycks någon tangent
                                  fortsätter programmet.

GET#

 Används tillsammans med en tidigare öppnad fil (OPEN) för att läsa in ett
tecken i taget.

EXEMPEL:

  GET#1,A$

GOSUB

 Detta kommando gör likadant som GOTO men den kommer dessutom ihåg var den
kom ifrån. När C-64an kommer till en rad med kommandot RETURN, så hoppar den
tillbaka till raden efter det senaste GOSUB-kommandot. Detta är användbart
om du vill ha samma programsektion utförd på flera ställen i programmet.
Istället för att upprepa programsektionen på varje ställe så läggs
GOSUB-kommandot in med ett efterföljande radnummer, som visar var
programsektionen ligger. GOSUB 800 betyder att C-64an hoppar till rad 800
och fortsätter programkörningen där.

GOTO eller GO TO

 När C-64 kommer till ett GOTO-kommando, hoppar den till raden som anges
efter kommandot.

IF...THEN

 IF...THEN-kommandot gör det möjligt för C-64an att analysera en situation
och välja en av två möjliga vägar. Om uttrycket som beräknas blir sant (dvs
<>0), utförs ordet som står efter THEN. Ordet kan vara ett tal som C-64an då
hoppar till. Det kan också vara ett kommando av något slag. Om uttrycket är
falskt (dvs >0) fortsätter C-64an på nästa programrad (inte nästa kommando
på raden).
 Uttrycket som undersöks kan vara en variabel eller en formel, där sant är
skilt från noll (<>0) och falskt lika med noll (=0). Ofta används
relationsoperanderna i uttrycken (=, <, >, AND, OR, NOT). Om uttrycket är
sant blir värdet -1 och falskt 0. Se kapitlet om relationsoperatorer och hur
de fungerar.

INPUT

 INPUT-kommandot gör det möjligt för C-64an att låta personen som sitter vid
tangentbordet skriva in värdet på en variabel. Programmet stannar, skriver
ut ett frågetecken och väntar på att personen i fråga skall skriva in svaret
och trycka på RETURN-tangenten.
 Kommandot följs av ett eller flera variabler separerade med kommatecken.
Det kan också förekomma ett meddelande mellan citationstecknen innan
variablerna. Detta meddelande (eng.prompt) måste följas av ett semikolon
efter sista citationstecknet. Om fler variabler skall skrivas in måste de
separeras med kommatecken vid inskriften.

EXEMEPL:

  10 INPUT "SKRIV ETT VÄRDE PÅ A";A
  20 INPUT "OCH DITT NAMN TACK";A$
  30 INPUT B$
  40 PRINT "NU HADE DU INGEN ANING OM VAD JAG VILLE VETA"

INPUT#

 Fungerar som INPUT men tar data från en tidigare öppnad (OPEN) fil.

LET

 Ordet LET används mycket sällan i program, eftersom det inte har någon
praktisk betydelse, men det är faktiskt grunden till alla BASIC-program.
Variabeln som skall få resultatet av beräkningen finns på vänstra sidan av
likhetstecknet medan formeln och värdena finns på den högra.

EXEMPEL:

  10 LET A=5
  20 B=6
  30 C=A*B+3
  40 D$="HEJSAN"

NEXT

 NEXT-kommandot används alltid tillsammans med FOR-kommandot. När programmet
kommer till ett NEXT-kommando går det tillbaka till FOR-kommandot för att
kontrollera slingan. (Se FOR-kommandot för mera information.) Om slingan är
slut fortsätter programmet till nästa kommando efter NEXT. NEXT kan följas
av ett variabelnamn eller flera variabelnamn separerade med kommatecken. Om
inget variabelnamn anges utförs den senast påbörjade slingan. Om flera
variabler anges utförs de från vänster till höger.

EXEMPEL:

  10 FOR L=1 TO 10:NEXT
  20 FOR L=1 TO 10:NEXT L
  30 FOR L=1 TO 10:FOR M=1 TO 10:NEXT M,L

ON

 Detta kommando gör GOTO och GOSUB till specialvarianter av IF-kommandot.
Ordet ON följs av en formel som ger ett värde. Efter ordet GOTO eller GOSUB
följer en lista med radnummer skilda åt med kommatecken. Om resultatet av
beräkningen blir 1, hoppar programmet till det första radnumret i listan. Är
resultatet 2 hoppar den till det 2:a radnumret. Om resultatet är negativt, 0
eller större än antalet radnummer i listan, hoppar programmet till raden
efter ON-kommandot.

EXEMPEL:

  10 INPUT X
  20 ON X GOTO 10,50,50,50
  30 PRINT "NäHä"
  40 GOTO 60
  50 PRINT "HÄPP!"
  60 ON X GOTO 10,30,30

OPEN

 OPEN-kommandot gör att C-64an kan kommunicera med andra enheter såsom
kassettenhet, flexskivminne, skrivare eller skärmen. Ordet OPEN följs av ett
nummer som övriga BASIC-kommandon refererar till. Detta nummer är mellan 1
och 255. Efter det första numret kommer ett andra separerat med kommatecken.
Detta är enhetsnumret, 0 för tangentbordet, 1 för kassettenheten, 2 för
RS232, 3 för bildskärm, 4 för skrivare och 8 för flexskivminne. Det är bäst
att använda samma filnummer som enhetsnummer, det blir lättare att hålla
reda på filerna då. Efter det andra numret kan ett kommatecken och ett
tredje nummer förekomma, vilket är sekundäradressen. Detta talar om för
kassettenheten om den ska skriva eller läsa. 0 för läsning, 1 för skrivning
och 2 för skrivning med "end of tape"-markering på slutet. Är enheten
flexskivminne så betyder numret ett visst buffer- eller kanalnummer. I
skrivaren betyder numret olika kommandon. (Se C-64ans programmeringshandbok
för mera detaljer om detta.) Efter det tredje numret kan det dessutom finnas
en sträng med text som ger ett kommando till flexskivminnet eller ger ett
programnamn på kassetten.

EXEMPEL

  10 OPEN 1,0        Öppnar en fil till skärmen.
  20 OPEN 2,1,0,"D"  Öppnar en fil för läsning på kassettenheten. Filen som
                     den skall söka efter heter "D".
  30 OPEN 3,4        Öppnar en fil till skrivaren.
  40 OPEN 4,8,15     Öppnar kommandokanalen till skivminnet.

 Se också: CLOSE, CMD, GET#, INPUT#, PRINT#, systemvariabeln ST och appendix
B.

POKE

 POKE-kommandot följs alltid av två stycken nummer eller formler. Det första
numret är positionen i C-64ans minne. Positionsnumret kan vara mellan 0 och
65000. En del av positionerna kan du använda till att ändra på färg eller
ljud som du sett i tidigare kapitel. En del positioner använder C-64an för
att hålla reda på progrannet och så vidare. Om du experimenterar med
POKE-kommandot kan du säkert få en del intressanta effekter. Om någonting
händer och du inte kan stoppa det, är det bara att stänga av datorn eller
trycka på STOP och RESTORE.
 Det andra numret har ett värde mellan 0 och 255, och placeras i den
position som angavs i det första numret.

EXEMPEL:

  10 POKE 36879, 8
  20 POKE 9*16^3+15, 27

PRINT

 PRINT-kommandot är det första kommando som de flesta lär sig att använda,
men det finns många finesser med kommandot som man får lära sig använda.
Tillsammans med PRINT-kommandot kan man ha:

Text mellan citationstecken
Variabelnamn
Funktioner
Formateringstecken

 Tecken innanför citationstecken skrivs ut som de är. Namn utanför
citationstecken tas för ett variabelnamn och värdet på denna variabel skrivs
ut. Funktionernas värden kommer också att skrivas ut. Formateringstecken
används för att få en snygg utskrift. Kommat används för att dela in skärmen
i fyra delan, medan semikolon inte ger några blanktecken alls mellan
utskrifterna. Båda tecknen kan användas sist i kommandot. Detta får då
effekten att nästa utskrift skrivs ut som om den fanns på samma rad.

EXEMPEL:

  10 PRINT "HEJSAN"
  20 PRINT "HEJSAN," A$
  30 PRINT A+B
  50 PRINT J;
  60 ? A,B,C,D

 Se också: POS()-, SPC()-, TAB()-funktionerna

PRINT#

 Det finns några skillnader mellan det vanliga PRINT-kommandot och
PRINT#-kommandot. För det första följs kommandot av ett nummer som refererar
till en fil som du nyss öppnade (OPEN) till någon enhet. Efter numret kommer
ett kommatecken och en lista med de saker som skall skrivas ut. Kommatecknet
och semikolonet har samma effekt, de adderar blanktecken. TAB och SPC kan på
vissa enheter fungera dåligt.

EXEMPEL:

  100 PRINT#1,"HEJSAN DU!";A$,B$

READ

 Detta kommando används för att läsa information från rader med
DATA-kommandon och lägga in information i variabler. Du bör se upp med att
försöka läsa in text när READ-kommandot vill ha ett numeriskt värde. Om så
sker svarar datorn med "TYPE MISMATCH ERROR" (dvs typefel).

REM

 REMark (anmärkning) används för att lägga in kommentarer i programmet.
Detta gör att den som läser programmet har lättare att förstå vad
programmeraren menat med sina kommandon. REM-kommandot påverkar inte på
något sätt programmet utom att det blir större. Texten efter kommandot kan
vara vilken text som helst, men grafiska tecken ger konstiga resultat. (Se
Programmerarens handbok för mera information).

RESTORE

 Den pekare, som anger vilket objekt i DATA-kommandot som ligger på tur för
att läsas av READ-kommandot, nollställs till det första objektet när detta
kommando utförs.. Detta gör det möjligt att läsa om informationen från
början. Kommandot RESTORE skall stå ensamt på en rad för sig utan extra
text.

RETURN

 Detta kommando används alltid tillsammans med GOSUB-kommandot. När C-64an
kommer till ett RETURN-kommando hoppar den tillbaka till första kommandot
efter GOSUB. Om inget GOSUB-kommando fanns före, svarar den med "RETURN
WITHOUT GOSUB ERROR" (dvs ett RETURN utan GOSUB-fel). Ingen extra text på
RETURN.

STOP

 Detta kommando stannar programmet. C-64an skriver ut, "BREAK IN LINE xxxx"
(dvs avbrott på rad xxxx), där xxxx är raden som innehåller STOP-kommandot.
Med CONT-kommandot kan programmet startas om igen där det stannade.
STOP-kommandot används för att leta fel i program.

SYS

 Kommandot följs av ett nummer eller en numerisk variabel i området 0-65535.
När C-64an får detta kommando hoppar den ner i minnet och utför det
maskinspråksprogram som finns på den angivna adressen. Det påminner om
USR-funktionen, men den kan inte överföra parametrar.

WAIT

 Kommandot används för att stanna programmet till dess en viss
minnesposition ändrar sitt värde på ett specificerat sätt. Ordet WAIT följs
av ett nummer som är den position som skall kontrolleras. Därefter kommer
ett kommatecken och ett nummer. Det kan även finnas ännu ett kommatecken och
ett tredje nummer. Dessa två sista nummer måste vara inom området 0-255.
 På innehållet i minnespositionen görs först en exklusive-OR med det tredje
numret om det finns, sedan görs AND med det andra numret. Om resultatet är 0
går C-64an tillbaka och kontrollerar innehållet igen. Är resultatet inte 0
fortsätter programmet till nästa kommando.


4. FUNKTIONER

a. NUMERISKA

ABS(X)

 Du får tillbaka absolutvärdet av talet, utan tecken. resultatet är alltid
positivt.

ATN(X)

 Ger vinkeln i radianer, vars tangent är X, (dvs arcus tangens för X).

COS(X)

 Ger cosinus för vinkel X i radianer.

EXP(X)

 Ger värdet av den matematiska konstanten e (2.71827183) upphöjd med X.


FNXX(X)

 Ger värdet av den användardefinierade funktionen XX skapad genom
FNXX-kommandot.

INT(X)

 Ger ett avkortat värde av X, det vill säga utan decimaler. Resultatet blir
alltid mindre eller lika med värdet av X. Detta gäller även negativa tal.
 Om INT-funktionen används för att avrunda uppåt eller nedåt ser formeln ut
så här.

EXEMPEL:

  X = INT(X*100+.5)/100  Avrundar till närmaste öre.

LOG(X)

 Ger den naturliga logaritmen av X. Naturliga logaritmen har basen e (Se
EXP(X)). För att konvertera till bas 10 så dividerar du med LOG(10).

PEEK(X)

 Detta används för att ta reda på innehållet i minnespositionen X
(X=0-65535). Resultatet blir 0-255. Denna funktion används ofta tillsammans
med POKE-kommandot.

RND(X)

 Denna funktion ger som resehat ett slumptal mellan 0 och 1. Detta är
användbart i spel, där du vill simulera tärningskast eller olika utfall. Det
kan också användas i vissa statistiska sammanhang. Det första slumptalet bör
genereras genom formeln RND(-TI), så att det första värdet blir olika varje
gång. Efter detta bör värdet X vara 1 eller något positivt värde. Om X är 0
blir resultatet samma som föregående slumptal. Ett negativt värde sätter ett
nytt "frö" i slumpgeneratorn. Användningen av samma negativa tal ger samma
sekvens av slumptal.
 För att simulera ett tärningskast använd formeln INT(RND(1)*6+1). Först
multipliceras slumptalet från 0-1 med 6 och intervallet utökas till 0-6
(större än 0 och mindre än 6). Addering med 1 ger 1-7. INT-funktionen tar
bort alla decimaler och kvar finns ett heltal mellan 1 och 6.
 För att simulera 2 tärningar adderar du värdet från två stycken slumptal
enligt ovanstående formel.

EXEMPEL:

  100 X=INT(RND(1)*6)+ INT(RND(1)*6)  Simulerar två tärningar
  100 X=INT(RND(1)*1000)+1            Ett heltal från 1-1000.
  100 X=INT(RND(1)*150)+100           Ett heltal från 100-249.

SGN(X)

 Ger tecknet på värdet X, om det är positivt, negativt eller lika med 0.
Resultatet blir +1 om positivt, 0 om noll och -1 om negativt,

SIN(X)

 Ger sinus av vinkeln X. Vinkel X anges i radianer.

SQR(X)

 Ger kvadratroten ur värdet X. Om X är positivt. Om X är negativt svarar
datorn med "ILLEGAL QUANTITY ERROR".

TAN(X)

 Ger tangenten av X där X är vinkeln i radianer.

USR(X)

 När denna funktion används hoppar C-64an till ett maskinspråksprogram vars
startadress finns i minnespositionerna 785 och 786. Parametern X överförs
till maskinspråksprogrammet, vilken kommer att ge tillbaka ett annat värde.
Se C-64ans PROGRAMMERINGSHANDBOK för mera detaljer om detta och
maskinspråksprogram.


b. STRÄNGFUNKTIONER

ASC(X$)

 Funktionen ger som resultat ASCII-koden för första tecknet i X$.

CHR$(X)

 Detta är motsatsen till ASC, den ger tecknet vars ASCII-kod är X.

LEFT$(X$,X)

 Ger X stycken tecken av den vänstra delen av X$.

LEN(X$)

 Ger antal tecken i X$ (inkluderar blanktecken och symboler).

MID$(X$,S,X)

 Ger som resultat X stycken tecken ur strängen X$ med början i det S-te
tecknet.

RIGHT$(X$,X)

 Ger X stycken tecken av den högra delen av X$.

STR$(X)

 Ger en sträng som motsvarar den utskrift du får av variabeln X.

VAL(X$)

 Denna funktion är motsatsen till STR$. Funktionen omvandlar en sträng till
ett numeriskt värde. Strängen söks av från vänster till höger så länge den
innehåller numeriskt format. Upptäcker C-64an ett tecken som inte hör dit
slutar den att konvertera.

EXEMPEL:

  10 X=VAL("123.456")      X = 123.456
  10 X=VAL("12A13B")       X = 12
  10 X=VAL("RIUO17")       X = 0
  10 X=VAL("-1.23.23.23")  X = -1.23


C. ÖVRIGA FUNKTIONER

FRE(X)

 Denna funktion ger antalet lediga minnespositioner, oavsett värdet på X.

POS(X)

 Funktionen visar i vilken kolumn (0-39) nästa utskrift kommer att börja. X
kan vara vilket värde som helst och används inte.

SPC(X)

 Används i PRINT-kommandot för att skriva ut X stycken blanktecken.

TAB(X)

 Används i PRINT-kommandot för att påbörja nästa utskrift i kolumnen X.


[D.] BILAGA D

FÖRKORTNINGAR FÖR BASIC-ORD

 För att spara tid när du skriver in programkommandon tillåter C-64an att du
förkortar de flesta ord. Förkortningen för PRINT är ett frågetecken.
Förkortningen för de övriga orden görs genom att skriva första eller de två
första tecknen i ordet och sedan hålla SHIFT nedtryckt medan du trycker
nästa tecken. När förkortningen används i programmet kommer den att skrivas
ut i sin längre form när programmet listas. Notera att en del ord innehåller
första parantesen, andra gör det inte.

                      Ser ut så här |                       Ser ut så här
Kommando Förkortning  på skärmen    | Kommando Förkortning  på skärmen
------------------------------------+------------------------------------
 ABS     A <SHIFT+B>                |  NOT     N <SHIFT+O>
 AND     A <SHIFT+N>                |  ON      NONE               ON
 ASC     A <SHIFT+S>                |  OPEN    O <SHIFT+P>
 ATN     A <SHIFT+T>                |  OR      NONE               OR
 CHR$    C <SHIFT+H>                |  PEEK    P <SHIFT+E>
 CLOSE   CL <SHIFT+O>               |  POKE    P <SHIFT+O>
 CLR     C <SHIFT+L>                |  POS     NONE               POS
 CMD     C <SHIFT+M>                |  PRINT   ?                  ?
 CONT    C <SHIFT+O>                |  PRINT#  P <SHIFT+R>
 COS     NONE              COS      |  READ    R <SHIFT+E>
 DATA    D <SHIFT+A>                |  REM     NONE               REM
 DEF     D <SHIFT+E>                |  RESTORE RE <SHIFT+S>
 DIM     D <SHIFT+I>                |  RETURN  RE <SHIFT+T>
 END     E <SHIFT+N>                |  RIGHT$  R <SHIFT+I>
 EXP     E <SHIFT+X>                |  RND     R <SHIFT+N>
 FN      NONE              FN       |  RUN     R <SHIFT+U>
 FOR     F <SHIFT+O>                |  SAVE    S <SHIFT+A>
 FRE     F <SHIFT+R>                |  SGN     S <SHIFT+G>
 GET     G <SHIFT+E>                |  SIN     S <SHIFT+I>
 GET#    NONE              GET#     |  SPC(    S <SHIFT+P>
 GOSUB   GO <SHIFT+S>               |  SQR     S <SHIFT+Q>
 GOTO    G <SHIFT+O>                |  STATUS  ST                 ST
 IF      NONE              IF       |  STEP    ST <SHIFT+E>
 INPUT   NONE              INPUT    |  STOP    S <SHIFT+T>
 INPUT#  I <SHIFT+N>                |  STR$    ST <SHIFT+R>
 INT     NONE              INT      |  SYS     S <SHIFT+Y>
 LEFT$   LE <SHIFT+F>               |  TAB(    T <SHIFT+A>
 LEN     NONE              LEN      |  TAN     NONE               TAN
 LET     L <SHIFT+E>                |  THEN    T <SHIFT+H>
 LIST    L <SHIFT+I>       SAVE     |  TIME    TI                 TI
 LOAD    L <SHIFT+O>                |  TIME$   TI$                TI$
 LOG     NONE              LOG      |  USR     U <SHIFT+S>
 MID$    M <SHIFT+I>                |  VAL     V <SHIFT+A>
 NEW     NONE              NEW      |  VERIFY  V <SHIFT+E>
 NEXT    N <SHIFT+E>                |  WAIT    W <SHIFT+A>


[E.] BILAGA E

SKÄRMKODER

Följande tabell visar alla tecken som finns inbyggda i Commodore 64.
Tabellen, visar vilket nummer du skall lägga in (POKE) i skärmminnet för att
få det önskade tecknet. Det visar också vilket värde tecknet får om du
PEEKar (läser av) minnespositionen. Skärmens adress är 1024-2023.
 Det finns två uppsättningar med tecken, men du kan bara använda en i taget.
Med detta menas att tecken från den ena uppsättningen inte kan visas
samtidigt som tecken från den andra. Du byter teckenuppsättning genom att
hålla skift nedtryckt och trycka på <C=>-tangenten.
 Från BASIC kan du ändra teckensats med POKE-kommando. POKE 53272,29 ändrar
till stora bokstäver och grafik. POKE 53272,31 ändrar till små och stora
bokstäver (gemener och VERSALER).
 Alla tecken i tabellen kan också visas i omvänd form (reverse mode). De
omvända tecknen erhålles genom att addera 128 till de angivna värdena.
 Om du vill visa en fylld cirkel i skärmpositionen 1504, så lägg in koden
för fylld cirkel (81) i minnespositionen 1504: POKE 1504,81.
 Det finns en motsvarande minnesposition för att kontrollera färgen på varje
tecken som visas på skrämen (positionerna 55296-56295). För att förändra
cirkelns färg till gul (färgkod 7) måste motsvarande minnesposition (55776)
innehålla denna teckenfärg. Skriv därför: POKE 55776,7
 Se även BILAGA G [G.] för kompletta skärm- och färgminneskartor samt
färgkoder.

SKÄRMKODER

  SET 1   SET 2   POKE  |  SET 1   SET 2   POKE  |  SET 1   SET 2   POKE
------------------------+------------------------+-----------------------
    @               0   |    +              43   |            V      86
    A       a       1   |    ,              44   |            W      87
    B       b       2   |    -              45   |            X      88
    C       c       3   |    .              46   |            Y      89
    D       d       4   |    /              47   |            Z      90
    E       e       5   |    0              48   |                   91
    F       f       6   |    1              49   |                   92
    G       g       7   |    2              50   |                   93
    H       h       8   |    3              51   |                   94
    I       i       9   |    4              52   |                   95
    J       j      10   |    5              53   |  SPACE            96
    K       k      11   |    6              54   |                   97
    L       l      12   |    7              55   |                   98
    M       m      13   |    8              56   |                   99
    N       n      14   |    9              57   |                  100
    O       o      15   |    :              58   |                  101
    P       p      16   |    ;              59   |                  102
    Q       q      17   |    <              60   |                  103
    R       r      18   |    =              61   |                  104
    S       s      19   |    >              62   |                  105
    T       t      20   |    ?              63   |                  106
    U       u      21   |                   64   |                  107
    V       v      22   |            A      65   |                  108
    W       w      23   |            B      66   |                  109
    X       x      24   |            C      67   |                  110
    Y       y      25   |            D      68   |                  111
    Z       z      26   |            E      69   |                  112
    [              27   |            F      70   |                  113
    £              28   |            G      71   |                  114
    ]              29   |            H      72   |                  115
    ^              30   |            I      73   |                  116
    <-             31   |            J      74   |                  117
  SPACE            32   |            K      75   |                  118
    !              33   |            L      76   |                  119
    "              34   |            M      77   |                  120
    #              35   |            N      78   |                  121
    $              36   |            O      79   |                  122
    %              37   |            P      80   |                  123
    &              38   |            Q      81   |                  124
    '              39   |            R      82   |                  125
    (              40   |            S      83   |                  126
    )              41   |            T      84   |                  127
    *              42   |            U      85   |
------------------------+------------------------+-----------------------

Koderna 128-255 är omvända (reverserade) versioner av koderna 0-127.


[F.] BILAGA F

ASCII OCH CHR$-KODER

Denna tabell visar vad som skrivs ut när du ger kommandot PRINT CHR$(X), där
X är alla värden mellan 0 och 255. Den visar också viket värde du får om du
skriver PRINT ASC("X") är X är vilket tecken som helst. Detta är användbart
när du skall analysera tecken från ett GET-kommando, eller konvertera
stora/små bokstäver.

+-----------------+-----------------+-----------------+-----------------+
|  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |  PRINTS   CHR$  |
+-----------------+-----------------+-----------------+-----------------+
|             0   |    0       48   |            96   | {svart}   144   |
|             1   |    1       49   |            97   |  {upp}    145   |
|             2   |    2       50   |            98   | {rvs off} 146   |
|             3   |    3       51   |            99   | {clear}   147   |
|             4   |    4       52   |           100   |  {inst}   148   |
|   {vit}     5   |    5       53   |           101   |  {brun}   149   |
|             6   |    6       54   |           102   | {ljusröd} 150   |
|             7   |    7       55   |           103   |  {grå 1}  151   |
| disSHIFT+C= 8   |    8       56   |           104   |  {grå 2}  152   |
| enaSHIFT+C= 9   |    9       57   |           105   | {ljusgrön}153   |
|            10   |    :       58   |           106   | {ljusblå} 154   |
|            11   |    ;       59   |           107   |  {grå 3}  155   |
|            12   |    <       60   |           108   | {violett} 156   |
|  return    13   |    =       61   |           109   | {vänster} 157   |
|  gemener   14   |    >       62   |           110   |  {gul}    158   |
|            15   |    ?       63   |           111   |  {cyan}   159   |
|            16   |    @       64   |           112   |  SPACE    160   |
|  {ned}     17   |    A       65   |           113   |           161   |
| {rvs on}   18   |    B       66   |           114   |           162   |
|  {home}    19   |    C       67   |           115   |           163   |
|  {del}     20   |    D       68   |           116   |           164   |
|            21   |    E       69   |           117   |           165   |
|            22   |    F       70   |           118   |           166   |
|            23   |    G       71   |           119   |           167   |
|            24   |    H       72   |           120   |           168   |
|            25   |    I       73   |           121   |           169   |
|            26   |    J       74   |           122   |           170   |
|            27   |    K       75   |           123   |           171   |
|  {röd}     28   |    L       76   |           124   |           172   |
| {höger}    29   |    M       77   |           125   |           173   |
|  {grön}    30   |    N       78   |           126   |           174   |
|  {blå}     31   |    O       79   |           127   |           175   |
|  SPACE     32   |    P       80   |           128   |           176   |
|    !       33   |    Q       81   | {orange}  129   |           177   |
|    "       34   |    R       82   |           130   |           178   |
|    #       35   |    S       83   |           131   |           179   |
|    $       36   |    T       84   |           132   |           180   |
|    %       37   |    U       85   |    f1     133   |           181   |
|    &       38   |    V       86   |    f3     134   |           182   |
|    '       39   |    W       87   |    f5     135   |           183   |
|    (       40   |    X       88   |    f7     136   |           184   |
|    )       41   |    Y       89   |    f2     137   |           185   |
|    *       42   |    Z       90   |    f4     138   |           186   |
|    +       43   |    [ (Å)   91   |    f6     139   |           187   |
|    ,       44   |    £ (Ä)   92   |    f8     140   |           188   |
|    -       45   |    ] (Ö)   93   |shift+ret. 141   |           189   |
|    .       46   |    ^       94   | versaler  142   |           190   |
|    /       47   |{arrow left}95   |           143   |           191   |
+-----------------+-----------------+-----------------+-----------------+

Koderna 192-223 är samma som  96-127
Koderna 224-254 är samma som 160-190
Koden   255     är samma som 126


[G.] BILAGA G

SKÄRM- OCH FÄRGMINNESKARTOR

 Följande rutnät visar vilka minnespositioner som kontrollerar de tecken som
visas på skärmen, och de minnespositioner som används för de individuella
tecknens teckenfärg. Dessutom finns en tabell med teckenfärgkoderna.

                           SKÄRMMINNESKARTA

                                 KOLUMN                             1063
      0             10             20             30            39 /
     +------------------------------------------------------------/
1024 |                                                            |  0
1064 |                                                            |
1104 |                                                            |
1144 |                                                            |
1184 |                                                            |
1224 |                                                            |
1264 |                                                            |
1304 |                                                            |
1344 |                                                            |
1384 |                                                            |
1424 |                                                            | 10
1464 |                                                            |
1504 |                                                            |   RAD
1544 |                                                            |
1584 |                                                            |
1624 |                                                            |
1664 |                                                            |
1704 |                                                            |
1744 |                                                            |
1784 |                                                            |
1824 |                                                            | 20
1864 |                                                            |
1904 |                                                            |
1944 |                                                            |
1984 |                                                            | 24
     +------------------------------------------------------------\
                                                                   \
                                                                    2023

 De värden som används för att POKEa i färgminnespositionerna för att ändra
ett teckens färg är:

  0  SVART                          8  ORANGE
  1  VIT                            9  BRUN
  2  RÖD                           10  LJUS RÖD
  3  CYAN                          11  GRÅ 1
  4  PURPUR                        12  GRÅ 2
  5  GRÖN                          13  LJUS GRÖN
  6  BLÅ                           14  LJUSBLÅ
  7  GUL                           15  GRÅ 3

 För att som exempel ändra färgen på tecken, placerat i skärmens övre vänstra
hörn, till rött, skriv: POKE 55296,2

                            FÄRGMINNESKARTA

                                 COLUMN                             55335
      0             10             20             30            39 /
     +------------------------------------------------------------/
55296|                                                            |  0
55336|                                                            |
55376|                                                            |
55416|                                                            |
55456|                                                            |
55496|                                                            |
55536|                                                            |
55576|                                                            |
55616|                                                            |
55656|                                                            |
55696|                                                            | 10
55736|                                                            |
55776|                                                            |   ROW
55816|                                                            |
55856|                                                            |
55896|                                                            |
55936|                                                            |
55976|                                                            |
56016|                                                            |
56056|                                                            |
56096|                                                            | 20
56136|                                                            |
56176|                                                            |
56216|                                                            |
56256|                                                            | 24
     +------------------------------------------------------------\
                                                                   56295


[H.] BILAGA H

HÄRLEDDA MATEMATISKA FUNKTIONER

 Funktioner som inte innefattas i Commodore 64 BASIC kan beräknas på
följande sätt:

+-------------------------------+---------------------------------------+
|           FUNKTION            |         C-64 BASIC MOTSVARANDE        |
+-------------------------------+---------------------------------------+
| SECANT                        | SEC(X)=1/COS(X)                       |
| COSECANT                      | CSC(X)=1/SIN(X)                       |
| COTANGENT                     | COT(X)=1/TAN(X)                       |
| INVERSE SINE                  | ARCSIN(X)=ATN(X/SQR(-X*X+1))          |
| INVERSE COSINE                | ARCCOS(X)=-ATN(X/SQR(-X*X+1))+{pi}/2  |
| INVERSE SECANT                | ARCSEC(X)=ATN(X/SQR(X*X-1))           |
| INVERSE COSECANT              | ARCCSC(X)=ATN(X/SQR(X*X-1))           |
|                               |   +(SGN(X)-1*{pi}/2                   |
| INVERSE COTANGENT             | ARCOT(X)=ATN(X)+{pi}/2                |
| HYPERBOLIC SINE               | SINH(X)=(EXP(X)-EXP(-X))/2            |
| HYPERBOLIC COSINE             | COSH(X)=(EXP(X)+EXP(-X))/2            |
| HYPERBOLIC TANGENT            | TANH(X)=EXP(-X)/(EXP(X)+EXP(-X))*2+1  |
| HYPERBOLIC SECANT             | SECH(X)=2/(EXP(X)+EXP(-X))            |
| HYPERBOLIC COSECANT           | CSCH(X)=2/(EXP(X)-EXP(-X))            |
| HYPERBOLIC  COTANGENT         | COTH(X)=EXP(-X)/(EXP(X)-EXP(-X))*2+1  |
| INVERSE HYPERBOLIC SINE       | ARCSINH(X)=LOG(X+SQR(X*X+1))          |
| INVERSE HYPERBOLIC COSINE     | ARCCOSH(X)=LOG(X+SQR(X*X-1))          |
| INVERSE HYPERBOLIC TANGENT    | ARCTANH(X)=LOG((1+X)/(1-X))/2         |
| INVERSE HYPERBOLIC SECANT     | ARCSECH(X)=LOG((SQR(-X*X+1)+1/X)      |
| INVERSE HYPERBOLIC COSECANT   | ARCCSCH(X)=LOG((SGN(X)*SQR(X*X+1/X)   |
| INVERSE HYPERBOLIC COTANGENT  | ARCCOTH(X)=LOG((X+1)/(X-1))/2         |
+------------------------------+----------------------------------------+


[I.] BILAGA I

KONTAKTDON FÖR I/O

 Denna bilaga är gjord för att visa vilka anslutningar som kan göras till
Commodore 64.

1. SPEL I/O                        4. SERIE I/O (Skivminne och skrivare)
2. Kassettslits                    5. Modulatorutgång
3. Audio/video                     6. Kassett
                                   7. Användarport

KONTROLLPORT 1
+-------+-----------+-----------+         /---------------------\
| Stift |    Typ    |   Anm.    |         |  1   2   3   4   5  |
+-------+-----------+-----------+         |  O   O   O   O   O  |
|   1   |   JOYA0   |           |          |                   |
|   2   |   JOYA1   |           |          |   O   O   O   O   |
|   3   |   JOYA2   |           |           |  6   7   8   9  |
|   4   |   JOYA3   |           |            \_______________/
|   5   |   POT AY  |           |
|   6   |  KNAPP A/ |           |
|       | LJUSPENNA |           |
|   7   |    +5V    | MAX. 50mA |
|   8   |    GND    |           |
|   9   |   POT AX  |           |
+-------+-----------+-----------+

KONTROLLPORT 2
+-------+-----------+-----------+
| Stift |    Typ    |   Anm.    |
+-------+-----------+-----------+
|   1   |   JOYB0   |           |
|   2   |   JOYB1   |           |
|   3   |   JOYB2   |           |
|   4   |   JOYB3   |           |
|   5   |   POT BY  |           |
|   6   |  KNAPP B  |           |
|   7   |    +5V    | MAX. 50mA |
|   8   |    GND    |           |
|   9   |   POT AX  |           |
+-------+-----------+-----------+

Minnesexpansion/spelkassettslists
+--------+-----------+                         +--------+--------------+
|  Stift |    Typ    |                         |  Stift |     Typ      |
+--------+-----------+                         +--------+--------------+
|   12   |   BA      |                         |    1   |   GND        |
|   13   |   /DMA    |                         |    2   |   +5V        |
|   14   |   D7      |                         |    3   |   +5V        |
|   15   |   D6      |                         |    4   |   /IRQ       |
|   16   |   D5      |                         |    5   |   R/W        |
|   17   |   D4      |                         |    6   |   Dot Clock  |
|   18   |   D3      |                         |    7   |   I/O1       |
|   19   |   D2      |                         |    8   |   /GAME      |
|   20   |   D1      |                         |    9   |   /EXROM     |
|   21   |   D0      |                         |   10   |   I/O2       |
|   22   |   GND     |                         |   11   |   /ROML      |
+--------+-----------+                         +--------+--------------+

+--------+-----------+                         +--------+--------------+
|  Stift |    Typ    |                         |  Stift |     Typ      |
+--------+-----------+                         +--------+--------------+
|   N    |   A9      |                         |   A    |   GND        |
|   P    |   A8      |                         |   B    |   /ROMH      |
|   R    |   A7      |                         |   C    |   /RESET     |
|   S    |   A6      |                         |   D    |   /NMI       |
|   T    |   A5      |                         |   E    |   02         |
|   U    |   A4      |                         |   F    |   A15        |
|   V    |   A3      |                         |   H    |   A14        |
|   W    |   A2      |                         |   J    |   A13        |
|   X    |   A1      |                         |   K    |   A12        |
|   Y    |   A0      |                         |   L    |   A11        |
|   Z    |   GND     |                         |   M    |   A10        |
+--------+-----------+                         +--------+--------------+

    2 2 2 1 1 1 1 1 1 1 1 1 1
    2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1
+---@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@---+
|                                                 |
+---@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@-@---+
    Z Y X W V U T S R P N M L K J H F E D C B A

Audio/Video                                                ++ ++
+--------------------------+------------------+           / +-+ \
|  Stift |      Typ        |       Anm.       |          /       \
+--------+-----------------+------------------+         +         +
|    1   |  LUMINANS       |                  |         |3O     O1|
|    2   |  GND            |                  |         |         |
|    3   |  AUDIO UT       |                  |         +  O   O  +
|    4   |  VIDEO UT       |                  |          \5  O  4/
|    5   |  AUDIO IN       |                  |           \  2  /
+--------+-----------------+------------------+            +---+

SERIE I/O                                                  ++ ++
+---------------------------------------------+           / +-+ \
|  Stift |                Typ                 |          /5     1\
+--------+------------------------------------+         +  O   O  +
|    1   |  SERIAL /SRQIN                     |         |    6    |
|    2   |  GND                               |         |    O    |
|    3   |  SERIAL ATN OUT                    |         |         |
|    4   |  SERIAL CLK IN/OUT                 |         +  O   O  +
|    5   |  SERIAL DATA IN/OUT                |          \4  O  2/
|    6   |  /RESET                            |           \  3  /
+--------+------------------------------------+            +---+

KASSETT
+-------+-------------------------------------+
| Stift |                Typ                  |
+-------+-------------------------------------+
|  A-1  |  GND                                |         1 2 3 4 5 6
|  B-2  |  +5V                                |     +---@-@-@-@-@-@---+
|  C-3  |  Kassettmotor                       |     |                 |
|  D-4  |  Kassett  READ                      |     +---@-@-@-@-@-@---+
|  E-5  |  Kassett  WRITE                     |         A B C D E F
|  F-6  |  Kassett  SENSE                     |
+-------+-------------------------------------+

Användarport
+------+------------------+-------------------+
| Stift|       Typ        |       Anm.        |
+------+------------------+-------------------+
|   1  |  GND             |                   |
|   2  |  +5V             | MAX. 100 mA       |
|   3  |  /RESET          |                   |
|   4  |  CNT1            |                   |
|   5  |  SP1             |                   |
|   6  |  CNT2            |                   |
|   7  |  SP2             |                   |
|   8  |  /PC2            |                   |
|   9  |  SER. ATN IN     |                   |
|  10  |  9 VAC           | MAX. 100 mA       |
|  11  |  9 VAC           | MAX. 100 mA       |
|  12  |  GND             |                   |
+------+------------------+-------------------+

+------+------------------+-------------------+
|  Pin |      Type        |       Note        |
+------+------------------+-------------------+
|   A  |  GND             |                   |
|   B  |  /FLAG2          |                   |
|   C  |  PB0             |                   |
|   D  |  PB1             |                   |
|   E  |  PB2             |                   |
|   F  |  PB3             |                   |
|   H  |  PB4             |                   |
|   I  |  PB5             |                   |
|   K  |  PB6             |                   |
|   L  |  PB7             |                   |
|   M  |  PA2             |                   |
|   N  |  GND             |                   |
+------+------------------+-------------------+

                     1 1 1
   1 2 3 4 5 6 7 8 9 0 1 2
+--@-@-@-@-@-@-@-@-@-@-@-@--+
|                           |
+--@-@-@-@-@-@-@-@-@-@-@-@--+
   A B C D E F H J K L M N


[J.] BILAGA J

PROGRAM DU KAN PRÖVA

 Vi har inkluderat ett program som du kan pröva med din Commodore 64. Detta
program är både underhållande och användbart.

start tok64 pianokey.prg
 90 REM piano keyboard
 100 PRINT"{CLEAR} {REVERSE ON} {RIGHT} {RIGHT} {194} {RIGHT} {RIGHT} \
     {RIGHT} {194} {RIGHT} {RIGHT} {194} {RIGHT} {RIGHT} "
 110 PRINT" {REVERSE ON} {RIGHT} {RIGHT} {194} {RIGHT} {RIGHT} {RIGHT} \
     {194} {RIGHT} {RIGHT} {194} {RIGHT} {RIGHT} "
 120 PRINT" {REVERSE ON} {RIGHT} {RIGHT} {194} {RIGHT} {RIGHT} {RIGHT} \
     {194} {RIGHT} {RIGHT} {194} {RIGHT} {RIGHT} "
 130 PRINT" {REVERSE ON} {194} {194} {194} {194} {194} {194} {194} \
     {194} {194} {194} {194} {194} "
 140 PRINT" {REVERSE ON}q{194}w{194}e{194}r{194}t{194}y{194}u{194} \
     i{194}o{194}p{194}@{194}*{194}^"
 150 PRINT"{DOWN}'space' for solo or polyphonic"
 160 PRINT"{DOWN}'f1,f3,f5,f7' octave selection"
 170 PRINT"{DOWN}'f2,f4,f6,f8' waveform{DOWN}"
 180 PRINT"hang on, setting up frequency table..."
 190 S=13*4096+1024: DIM F(26): DIM K(255)
 200 FOR I=0 TO 28: POKE S+I,0: NEXT
 210 F1=7040: FOR I=1 TO 26: F(27-I)=F1*5.8+30: F1=F1/2^(1/12): NEXT
 220 K$="q2w3er5t6y7ui9o0p@-*\^"
 230 FOR I=1 TO LEN(K$): K(ASC(MID$(K$,I)))=I: NEXT
 240 PRINT "{UP}{SPACE*38}"
 250 AT=0:DE=0:SU=15:RE=9:SV=SU*16+RE:AV=AT*16+DE:WV=16:W=0:M=1:OC=4:\
     HB=256:Z=0
 260 FOR I=0 TO 2: POKE S+5+I*7,AT*16+DE: POKES+6+I*7,SU*16+RE
 270 POKE S+2+I*7,4000 AND 255: POKE S+3+I*7,4000/256: NEXT
 280 POKE S+24,15: REM+16+64:poke s+23,7
 300 GET A$:IF A$="" THEN 300
 310 FR=F(K(ASC(A$)))/M: T=V*7: CR=S+T+4: IF FR=Z THEN 500
 320 POKE S+6+T,Z: REM finish dec/sus
 325 POKE S+5+T,Z: REM finish att/rel
 330 POKE CR,8: POKE CR,0: REM fix off
 340 POKE S+T,FR-HB*INT(FR/HB): REM set lo
 350 POKE S+1+T,FR/HB: REM set hi
 360 POKE S+6+T,SV: REM set dec/sus
 365 POKE S+5+T,AV: REM set att/rel
 370 POKE CR,WV+1: FOR I=1 TO 50*AT: NEXT
 375 POKE CR,WV: REM pulse
 380 IF P=1 THEN V=V+1: IF V=3 THEN V=0
 400 GOTO 300
 500 IF A$="{F1}" THEN M=1: OC=4: GOTO 300
 510 IF A$="{F3}" THEN M=2: OC=3: GOTO 300
 520 IF A$="{F5}" THEN M=4: OC=2: GOTO 300
 530 IF A$="{F7}" THEN M=8: OC=1: GOTO 300
 540 IF A$="{F2}" THEN W=0: WV=16: GOTO 300
 550 IF A$="{F4}" THEN W=1: WV=32: GOTO 300
 560 IF A$="{F6}" THEN W=2: WV=64: GOTO300
 570 IF A$="{F8}" THEN W=3: WV=128: GOTO300
 580 IF A$=" " THEN P=1-P: GOTO 300
 590 IF A$="{CLEAR}" THEN 200
 600 GOTO 300
 800 PRINT"hit a key"
 810 GET A$: IF A$="" THEN 810: WAIT FOR A KEY
 820 PRINT A$: RETURN
stop tok64

begin 644 pianokey.prg
M`0@6"%H`CR!024%.3R!+15E"3T%21``Z"&0`F2*3(!(@'2`=(,(@'2`=(!T@
MPB`=(!T@PB`=(!T@(@!="&X`F2(@$B`=(!T@PB`=(!T@'2#"(!T@'2#"(!T@
M'2`B`(`(>`"9(B`2(!T@'2#"(!T@'2`=(,(@'2`=(,(@'2`=("(`HPB"`)DB
M(!(@PB#"(,(@PB#"(,(@PB#"(,(@PB#"(,(@(@#&"(P`F2(@$E'"5\)%PE+"
M5,)9PE7"2<)/PE#"0,(JPEXB`.T(E@"9(A$G4U!!0T4G($9/4B!33TQ/($]2
M(%!/3%E02$].24,B`!0)H`"9(A$G1C$L1C,L1C4L1C<G($]#5$%612!314Q%
M0U1)3TXB`#0)J@"9(A$G1C(L1C0L1C8L1C@G(%=!5D5&3U)-$2(`8@FT`)DB
M2$%.1R!/3BP@4T545$E.1R!54"!&4D51545.0UD@5$%"3$4N+BXB`(@)O@!3
MLC$SK#0P.3:J,3`R-#H@AB!&*#(V*3H@AB!+*#(U-2D`HPG(`($@2;(P(*0@
M,C@Z()<@4ZI)+#`Z(((`X0G2`$8QLC<P-#`Z(($@2;(Q(*0@,C8Z($8H,C>K
M22FR1C&L-2XXJC,P.B!&,;)&,:TRKB@QK3$R*3H@@@`!"MP`2R2R(E$R5S-%
M4C54-EDW54DY3S!00"TJ7%XB`"<*Y@"!($FR,2"D(,,H2R0I.B!+*,8HRBA+
M)"Q)*2DILDDZ(((`5PKP`)D@(I$@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("(`I@KZ`$%4LC`Z1$6R,#I35;(Q-3I21;(Y.E-6LE-5
MK#$VJE)%.D%6LD%4K#$VJD1%.E=6LC$V.E>R,#I-LC$Z3T.R-#I(0K(R-38Z
M6K(P`-L*!`&!($FR,""D(#(Z()<@4ZHUJDFL-RQ!5*PQ-JI$13H@EU.J-JI)
MK#<L4U6L,3:J4D4`"PL.`9<@4ZHRJDFL-RPT,#`P(*\@,C4U.B"7(%.J,ZI)
MK#<L-#`P,*TR-38Z(((`+@L8`9<@4ZHR-"PQ-3H@CRLQ-BLV-#I03TM%(%,K
M,C,L-P!%"RP!H2!!)#J+($$DLB(B(*<@,S`P`'D+-@%&4K)&*$LHQBA!)"DI
M*:U-.B!4LE:L-SH@0U*R4ZI4JC0Z((L@1E*R6B"G(#4P,`"9"T`!ER!3JC:J
M5"Q:.B"/($9)3DE32"!$14,O4U53`+D+10&7(%.J-:I4+%HZ((\@1DE.25-(
M($%45"]214P`UPM*`9<@0U(L.#H@ER!#4BPP.B"/($9)6"!/1D8`^@M4`9<@
M4ZI4+$92JTA"K+4H1E*M2$(I.B"/(%-%5"!,3P`6#%X!ER!3JC&J5"Q&4JU(
M0CH@CR!3150@2$D`-`QH`9<@4ZHVJE0L4U8Z((\@4T54($1%0R]355,`4@QM
M`9<@4ZHUJE0L058Z((\@4T54($%45"]214P`<@QR`9<@0U(L5U:J,3H@@2!)
MLC$@I"`U,*Q!5#H@@@"'#'<!ER!#4BQ75CH@CR!054Q310"F#'P!BR!0LC$@
MIR!6LE:J,3H@BR!6LC,@IR!6LC``L`R0`8D@,S`P`-`,]`&+($$DLB*%(B"G
M($VR,3H@3T.R-#H@B2`S,#``\`S^`8L@022R(H8B(*<@3;(R.B!/0[(S.B")
M(#,P,``0#0@"BR!!)+(BAR(@IR!-LC0Z($]#LC(Z((D@,S`P`#`-$@*+($$D
MLB*((B"G($VR.#H@3T.R,3H@B2`S,#``40T<`HL@022R(HDB(*<@5[(P.B!7
M5K(Q-CH@B2`S,#``<@TF`HL@022R(HHB(*<@5[(Q.B!75K(S,CH@B2`S,#``
MD@TP`HL@022R(HLB(*<@5[(R.B!75K(V-#H@B3,P,`"S#3H"BR!!)+(BC"(@
MIR!7LC,Z(%=6LC$R.#H@B3,P,`#/#40"BR!!)+(B("(@IR!0LC&K4#H@B2`S
M,#``X@U.`HL@022R(I,B(*<@,C`P`.P-6`*)(#,P,`#]#2`#F2)(250@02!+
M15DB`"`.*@.A($$D.B"+($$DLB(B(*<@.#$P.B"2(($@02!+15D`+`XT`YD@
(020Z((X`````
`
end


[K.] BILAGA K

ÄNDRING AV STANDARD BASIC-PROGRAM TILL COMMODORE 64 BASIC

 Om du har ett program skrivet i en annan BASIC-dialekt än Commodore BASIC,
kan en del mindre justeringar erfordras innan det kan köras på Commodore 64.
Vi har tagit med en del tips hur man gör denna ändring.


STRÄNG-DIMENSIONERING

 Avlägsna alla uttryck som används för att deklarera längden på strängar.
Ett uttryck som DIM A$(I, J), som dimensionerar en sträng J anta, element av
längden I, ska ändras till Commodore BASIC uttrycket DIM A$(J).
 En del BASIC-dialekter använder ett komma eller & för att sammanfoga
strängar.
 Vid Commodore BASIC används MID$-, RIGHT$- och LEFT$-funktionerna för att
ta ut delar av strängar. Uttryck såsom A$(I) för att ta ut I:te tecknet i
strängen A$, eller A$(I,J) för att ta ut en delsträng från tecknet I till J,
måste andras enligt följande:

ANNAN BASIC    COMMODORE 64 BASIC
A$(I) = X$     A$ = LEFT$(A$, I-1) + X$ + MID$(A$, I+1)
A$(I,J) = X$   A$ = LEFT$(A$, I-1) + X$ + MID$(A$, J+1)


MULTIPEL TILLDELNING

 För att sätta B och C till 0, används vissa uttryck med formen:

  10 LET B=C=0

 Commodore 64 kommer att tolka det sista likhetstecknet som en logisk
operand och sätta C = -1 om C = 0. Ändra istället detta uttryck till:

  10 C=0:B=0


MULTIPEL INSTRUKTIONER

 En del BASIC-dialekter använder snedstreck för att separera flera
instruktioner på samma rad. Vid Commodore BASIC separeras instruktionerna
med kolon (:).


 MAT-FUNKTIONEN

 Program som använder MAT funktionen som finns i vissa BASIC-dialekter måste
skrivas om och använda FOR...NEXT-loopar för att arbeta riktigt.


[L.] BILAGA L

FELMEDDELANDEN

Denna bilaga innehåller en komplett lista på felmeddelanden som ges av 64,
med en beskrivning av orsaken.

BAD DATA... Textdata lästes in av en fil, men programmet väntade sig
numeriska data.

BAD SUBSCRIPT... Programmet försökte referera till ett element i en matris
som ligger utanför området i DIM-kommandot.

CAN'T CONTINUE... CONT-kommandot fungerar inte om, programmet aldrig körts,
det har blivit ett fel eller en rad har blivit redigerad.

DEVICE NOT PRESENT... Den begärda in/ut-enheten finns inte tillgänglig för
ett OPEN, CLOSE, CMD, PRINT#, INPUT#, eller GET#.

DIVISION BY ZERO... Division med noll är en matematisk orimlighet och
tillåts inte.

EXTRA IGNORED... För många svar har givits in på ett INPUT-kommando. Endast
de första svaren räknas.

FILE NOT FOUND... Filen som specificerades i ett CLOSE, CMD, PRINT#, INPUT#
eller GET#, har ej hittats.

FILE NOT OPEN Den fil som specificerats i ett CLOSE, CMD, PRINT#, INPUT#
eller GET#, måste först öppnas.

FILE OPEN... Ett försök att öppna en fil med ett nummer som redan används av
en annan fil.

FORMULA TOO COMPLEX... Uttrycket bör delas upp i minst två separata delar.

ILLEGAL DIRECT... Input-kommandot kan endast användas i program och inte i
direktmode.

ILLEGAL QUANTITY... Ett värde som använts som parameter i en funktion ligger
utanför det tillåtna området.

LOAD... Det är problem med läsning av programmet från bandet.

NEXT WITHOUT FOR... Detta orsakas av oriktigt kapslade slingor eller att
variabeln i NEXT-kommandot inte stämmer överens med den i FOR-kommandot.

NOT INPUT FILE... Ett försök att göra INPUT eller GET till en fil som
öppnats för enbart skrivning.

NOT OUTPUT FILE... Ett försök har gjorts att använda PRINT till en fil som
öppnats enbart för läsning.

OUT OF DATA... Ett READ-kommando utförs utan att det finns data kvar som är
oläst.

OVERFLOW... Resultatet av en operation är större än det största tal som
tillåts, vilket är 1.70141884E+38

REDIM'D ARRAY... En matris kan bara dimensioneras en gång. Om en
matrisvariabel används innan den dimensioneras sker en automatdimensionering
och sätter antalet element till 10 och ett efterföljande DIM-kommando
orsakar detta fel.

REDO FROM START... Text skrevs in i ett INPUT-kommando där det förväntades
ett numeriskt värde. Skriv bara om ditt svar så fortsätter programmet av sig
själv.

STRING TOO LONG... En sträng får inte vara längre än 255 tecken.

SYNTAX... Ett kommando är givet som inte C-64an kan förstå. En missad
parentes eller ett felstavat kommando.

TYPE MISMATCH... Detta förekommer när en sträng skrivs istället för en
numerisk variabel eller tvärtom.

UNDEF'D FUNCTION... En användardefinierad funktion har använts utan att den
tidigare har definierats.

UNDEF'D STATEMENT... Ett försök att göra ett GOTO, GOSUB eller ett
RUN-kommando till en programrad som inte finns.

VERIFY... Program på band eller diskett stämmer inte överens med det i
C-64ans minne.


[M.] MUSIKTONERS POKE-VÄRDEN

 Denna bilaga innehåller en komplett lista på NOT#(nummer), notbeteckningar
och de värden som ska POKEas in i "ljudchipet's" HÖG- och
LÅG-frekvensregister för att skapa önskad ton

---------------------------------------------
 NOT#  NOT-OKTAV  HÖG FREKVENS  LÅG FREKVENS
---------------------------------------------
   0     C-0           1             18
   1    C#-0           1             35
   2     D-0           1             52
   3    D#-0           1             70
   4     E-0           1             90
   5     F-0           1            110
   6    F#-0           1            132
   7     G-0           1            155
   8    G#-0           1            179
   9     A-0           1            205
  10    A#-0           1            233
  11     B-0           2              6
  12     C-1           2             37
  13    C#-1           2             69
  14     D-1           2            104
  15    D#-1           2            140
  16     E-1           2            179
  17     F-1           2            220
  18    F#-1           3              8
  19     G-1           3             54
  20    G#-1           3            103
  21     A-1           3            155
  22    A#-1           3            210
  23     B-1           4             12
  24     C-2           4             73
  25    C#-2           4            139
  26     D-2           4            208
  27    D#-2           5             25
  28     E-2           5            103
  29     F-2           5            185
  30    F#-2           6             16
  31     G-2           6            108
  32    G#-2           6            206
  33     A-2           7             53
  34    A#-2           7            163
  35     B-2           8             23
  36     C-3           8            147
  37    C#-3           9             21
  38     D-3           9            159
  39    D#-3          10             60
  40     E-3          10            205
  41     F-3          11            114
  42    F#-3          12             32
  43     G-3          12            216
  44    G#-3          13            156
  45     A-3          14            107
  46    A#-3          15             70
  47     B-3          16             47
  48     C-4          17             37
  49    C#-4          18             42
  50     D-4          19             63
  51    D#-4          20            100
  52     E-4          21            154
  53     F-4          22            227
  54    F#-4          24             63
  55     G-4          25            177
  56    G#-4          27             56
  57     A-4          28            214
  58    A#-4          30            141
  59     B-4          32             94
  60     C-5          34             75
  61    C#-5          36             85
  62     D-5          38            126
  63    D#-5          40            200
  64     E-5          43             52
  65     F-5          45            198
  66    F#-5          48            127
  67     G-5          51             97
  68    G#-5          54            111
  69     A-5          57            172
  70    A#-5          61            126
  71     B-5          64            188
  72     C-6          68            149
  73    C#-6          72            169
  74     D-6          76            252
  75    D#-6          81            161
  76     E-6          86            105
  77     F-6          91            140
  78    F#-6          96            254
  79     G-6         102            194
  80    G#-6         108            223
  81     A-6         115             88
  82    A#-6         122             52
  83     B-6         129            120
  84     C-7         137             43
  85    C#-7         145             83
  86     D-7         153            247
  87    D#-7         163             31
  88     E-7         172            210
  89     F-7         183             25
  90    F#-7         193            252
  91     G-7         205            133
  92    G#-7         217            189
  93     A-7         230            176
  94    A#-7         244            103
---------------------------------------------


FILTERINSTÄLLNINGAR

 Adress  Innehåll
 54293   Undre gränsfrekvens (0-7)
 54294   Övre gränsfrekvens (0-255)
 54295   Resonans (bit 4-7)
         Filter stämma 3 (bit 2)
         Filter stämma 2 (bit 1)
         Filter stämma 1 (bit 0)
 54296   Högpass (bit 6)
         Bandpass (bit 5)
         Lågpass (bit 4)
         Volym (bit 0-3)


[N.] BILAGA N

LITTERATURFÖRTECKNING

handic           Programmeringshandbok, 3 delar
Förlagsgruppen   BASIC på C 64
Förlagsgruppen   Grafik och ljud på C 64
Förlagsgruppen   System - 64
Förlagsgruppen   Grafisk konst
Förlagsgruppen   Avancerad programmering
Förlagsgruppen   Matematik på C 64
Förlagsgruppen   Comal på C-64, lärobok för nybörjare


[O.] BILAGA O

SPRITEREGISTERKARTA

+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|Register#|     |     |     |     |     |     |     |     |             |
| Dec Hex | DB7 | DB6 | DB5 | DB4 | DB3 | DB2 | DB1 | DB0 |             |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  0   0  |S0X7 |     |     |     |     |     |     |S0X0 |SPRITE 0 X   |
|         |     |     |     |     |     |     |     |     |Komponent    |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  1   1  |S0Y7 |     |     |     |     |     |     |S0Y0 |SPRITE 0 Y   |
|         |     |     |     |     |     |     |     |     |Komponent    |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  2   2  |S1X7 |     |     |     |     |     |     |S1X0 |SPRITE 1 X   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  3   3  |S1Y7 |     |     |     |     |     |     |S1Y0 |SPRITE 1 Y   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  4   4  |S2X7 |     |     |     |     |     |     |S2X0 |SPRITE 2 X   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  5   5  |S2Y7 |     |     |     |     |     |     |S2Y0 |SPRITE 2 Y   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  6   6  |S3X7 |     |     |     |     |     |     |S3X0 |SPRITE 3 X   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  7   7  |S3Y7 |     |     |     |     |     |     |S3Y0 |SPRITE 3 Y   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  8   8  |S4X7 |     |     |     |     |     |     |S4X0 |SPRITE 4 X   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
|  9   9  |S4Y7 |     |     |     |     |     |     |S4Y0 |SPRITE 4 Y   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 10   A  |S5X7 |     |     |     |     |     |     |S5X0 |SPRITE 5 X   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 11   B  |S5Y7 |     |     |     |     |     |     |S5Y0 |SPRITE 5 Y   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 12   C  |S6X7 |     |     |     |     |     |     |S6X0 |SPRITE 6 X   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 13   D  |S6Y7 |     |     |     |     |     |     |S6Y0 |SPRITE 6 Y   |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 14   E  |S7X7 |     |     |     |     |     |     |S7X0 |SPRITE 7 X   |
|         |     |     |     |     |     |     |     |     |Komponent    |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 15   F  |S7Y7 |     |     |     |     |     |     |S7Y0 |SPRITE 7 Y   |
|         |     |     |     |     |     |     |     |     |Komponent    |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 16  10  |S7X8 |S6X8 |S5X8 |S4X8 |S3X8 |S2X8 |S1X8 |S0X8 |MSB of X     |
|         |     |     |     |     |     |     |     |     |COORD.       |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 17  11  | RC8 | ECM | BMM |BLNK |RSEL |YSCL2|YSCL1|YSCL0|Y SCROLL     |
|         |     |     |     |     |     |     |     |     |Mode         |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 18  12  | RC7 | RC6 | RC5 | RC4 | RC3 | RC2 | RC1 | RC0 |RASTER       |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 19  13  |LPX7 |     |     |     |     |     |     |LPX0 |Ljuspenna X  |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 20  14  |LPY7 |     |     |     |     |     |     |LPY0 |Ljuspenna Y  |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 21  15  | SE7 |     |     |     |     |     |     | SE0 |SPRITE       |
|         |     |     |     |     |     |     |     |     |ENABLE       |
|         |     |     |     |     |     |     |     |     |(ON/OFF)     |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 22  16  |N.C. |N.C. | RST | MCM |CSEL |XSCL2|XSCL1|XSCL0|SCROLL/MODE  |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 23  17  |SEX7 |     |     |     |     |     |     |SEX0 |SPRITE       |
|         |     |     |     |     |     |     |     |     |EXPAND Y     |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 24  18  |VS13 |VS12 |VS11 |VS10 |CB13 |CB12 |CB11 |N.C. |SCREEN       |
|         |     |     |     |     |     |     |     |     |Char         |
|         |     |     |     |     |     |     |     |     |Memory       |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 25  19  |IRQ  |N.C. |N.C. |N.C. |LPIRQ|ISSC |ISBC |RIRIQ|Interrupt    |
|         |     |     |     |     |     |     |     |     |Request's    |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 26  1A  |N.C. |N.C. |N.C. |N.C. |MLPI |MISSC|MISBC|MRIRQ|Interrupt    |
|         |     |     |     |     |     |     |     |     |Request      |
|         |     |     |     |     |     |     |     |     |MASKS        |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 27  1B  |BSP7 |     |     |     |     |     |     |BSP0 |Background   |
|         |     |     |     |     |     |     |     |     |Sprite       |
|         |     |     |     |     |     |     |     |     |PRIORITY     |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 28  1C  |SCM7 |     |     |     |     |     |     |SCM0 |MULTICOLOR   |
|         |     |     |     |     |     |     |     |     |SPRITE       |
|         |     |     |     |     |     |     |     |     |SELECT       |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 29  1D  |SEXX7|     |     |     |     |     |     |SEXX0|SPRITE       |
|         |     |     |     |     |     |     |     |     |EXPAND X     |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 30  1E  |SSC7 |     |     |     |     |     |     |SSC0 |Sprite-Sprite|
|         |     |     |     |     |     |     |     |     |COLLISION    |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+
| 31  1F  |SBC7 |     |     |     |     |     |     |SBC0 |Sprite-      |
|         |     |     |     |     |     |     |     |     |Background   |
|         |     |     |     |     |     |     |     |     |COLLISION    |
+---------+-----+-----+-----+-----+-----+-----+-----+-----+-------------+

           FÄRGKODER
            DEC  HEX    FÄRG
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 32  20  |  0    0     BLACK     |EXT 1|     |     |     |EXTERIOR COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 33  21  |  1    1     WHITE     |BKGD0|     |     |     |BACKGROUND 0 |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 34  22  |  2    2     RED       |BKGD1|     |     |     |BACKGROUND 1 |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 35  23  |  3    3     CYAN      |BKGD2|     |     |     |BACKGROUND 2 |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 36  24  |  4    4     PURPLE    |BKGD3|     |     |     |BACKGROUND 3 |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 37  25  |  5    5     GREEN     |SMC 0|     |     |     |   SPRITE    |
|         |                       |     |     |     |     |MULTICOLOR 0 |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 38  26  |  6    6     BLUE      |SMC 1|     |     |     |   SPRITE    |
|         |                       |     |     |     |     |MULTICOLOR 1 |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 39  27  |  7    7     YELLOW    |S0COL|     |     |     |SPRITE 0 COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 40  28  |  8    8     ORANGE    |S1COL|     |     |     |SPRITE 1 COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 41  29  |  9    9     BROWN     |S2COL|     |     |     |SPRITE 2 COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 42  2A  | 10    A     LT RED    |S3COL|     |     |     |SPRITE 3 COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 43  2B  | 11    B     GRAY 1    |S4COL|     |     |     |SPRITE 4 COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 44  2C  | 12    C     GRAY 2    |S5COL|     |     |     |SPRITE 5 COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 45  2D  | 13    D     LT GREEN  |S6COL|     |     |     |SPRITE 6 COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
| 46  2E  | 14    E     LT BLUE   |S7COL|     |     |     |SPRITE 7 COL |
+---------+-----------------------+-----+-----+-----+-----+-------------+
|         | 15    F     GRAY 3    |     |     |     |     |             |
+---------+-----------------------+-----+-----+-----+-----+-------------+

LEGEND:
ONLY COLORS 0-7 MAY BE USED IN MULTICOLOR CHARACTER MODE.


[P.] BILAGA P

COMMODORE 64 LJUDREGISTER

 Denna tabell ger dig de viktiga värdena du behöver använda i dina
ljudprogram, beroende på vilka av Commodore 64s stämmor du vill använda. För
att sätta eller ändra ljudkontrollvärde i ditt BASIC-program, behöver du
endast POKEa en adress från tabellens andra kolumn följt av ett komma(,) och
ett värde från tabellen...så här: POKE 54296,17 (välj triangelvåg åt stämma
1).
 Kom ihåg att att du måste sätta på VOLYM innan du kan generera ljud. POKE
54296 följt av ett tal från 0 till 15 sätter gemensam volym för samtliga
stämmor.
 Det krävs 2 separata POKEs för att generera varje musikton. Exempelvis:
POKE 54273,34: POKE 54272,75 skapar låga C enligt skalan på sidan 153 [M.].
 Dessutom är du inte begränsad av de tal som står i tabellen. Om 34 inte
låter "rent" för ett lågt C kan du prova 35. För att möjliggöra ett högre
attack- eller sustain-förhållande än vad som visas, kan du addera två eller
flera SUSTAINvärden tillsammans. Exempelvis: POKE 54277,96 kombinerar två
attackförhållande (32 och 64) för att ge ett kombinerat högre värde.

+----------------------------------------------------------------------------+
|VOLYMINSTÄLLNING -- SAMMA FÖR ALLA 3 STÄMMORNA                              |
+--------------+---------+---------------------------------------------------+
|Volymkontroll |POKE54296| Inställning från 0 (FRÅN) till 15 (FULL VOLYM)    |
+--------------+---------+---------------------------------------------------+
                              STÄMMA nummer 1
+--------------+---------+---------------------------------------------------+
|För att       |POKEa    |           FÖLJT AV ETT AV DESSA VÄRDEN:           |
|styra         |denna    |  (0 till 15 ... eller ... 25 beroende på område)  |
+--------------+---------+---------------------------------------------------+
|Spela en not  |      C  | C#| D | D#| E | F | F#| G | G#| A | A#| B | C | C#|
|Hög frekvens  |54273 34 | 36| 38| 40| 43| 45| 48| 51| 54| 57| 61| 64| 68| 72|
|Låg frekvens  |54272 75 | 85|126|200| 52|198|127| 97|111|172|126|188|149|169|
+--------------+---------+------------+------------+------------+------------+
|Vågform       |  POKE   |  TRIANGEL  |  SÅGTAND   |    PULS    |   BRUS     |
|              |  54276  |     17     |     33     |     65     |    129     |
+--------------+---------+------------+------------+------------+------------+
|Pulsform (puls vågform)                                                     |
|Hög puls      |  54275  |  Ett värde mellan 0 och 15 (Endast för pulsform)  |
|Låg puls      |  54274  |  Ett värde mellan 0 och 255(Endast för pulsform)  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+
|Attack/Decay  |  POKE   | ATK4 | ATK3 | ATK2 | ATK1 | DEC4| DEC3| DEC2| DEC1|
|              |  54277  | 128  |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+
|Sustain/      |  POKE   | SUS4 | SUS3 | SUS2 | SUS1 | REL4| REL3| REL2| REL1|
|       Release|  54278  | 128  |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+
                              STÄMMA nummer 2
+--------------+---------+---------------------------------------------------+
|Spela en not  |      C  | C#| D | D#| E | F | F#| G | G#| A | A#| B | C | C#|
|Hög frekvens  |54280 34 | 36| 38| 40| 43| 45| 48| 51| 54| 57| 61| 64| 68| 72|
|Låg frekvens  |54279 75 | 85|126|200| 52|198|127| 97|111|172|126|188|149|169|
+--------------+---------+------------+------------+------------+------------+
|Vågform       |  POKE   |  TRIANGEL  |  SÅGTAND   |    PULS    |   BRUS     |
|              |  54283  |     17     |     33     |     65     |    129     |
+--------------+---------+------------+------------+------------+------------+
|Pulsform (puls vågform)                                                     |
|Hög puls      |  54282  |  Ett värde mellan 0 och 15 (Endast för pulsform)  |
|Låg puls      |  54281  |  Ett värde mellan 0 och 255(Endast för pulsform)  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+
|Attack/Decay  |  POKE   | ATK4 | ATK3 | ATK2 | ATK1 | DEC4| DEC3| DEC2| DEC1|
|              |  54284  | 128  |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+
|Sustain/      |  POKE   | SUS4 | SUS3 | SUS2 | SUS1 | REL4| REL3| REL2| REL1|
|       Release|  54285  | 128  |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+
                              STÄMMA nummer 3
+--------------+---------+---------------------------------------------------+
|Spela en not  |      C  | C#| D | D#| E | F | F#| G | G#| A | A#| B | C | C#|
|Hög frekvens  |54287 34 | 36| 38| 40| 43| 45| 48| 51| 54| 57| 61| 64| 68| 72|
|Låg frekvens  |54286 75 | 85|126|200| 52|198|127| 97|111|172|126|188|149|169|
+--------------+---------+------------+------------+------------+------------+
|Vågform       |  POKE   |  TRIANGEL  |  SÅGTAND   |    PULS    |   BRUS     |
|              |  54290  |     17     |     33     |     65     |    129     |
+--------------+---------+------------+------------+------------+------------+
|Pulsform (puls vågform)                                                     |
|Hög puls      |  54275  |  Ett värde mellan 0 och 15 (Endast för pulsform)  |
|Låg puls      |  54274  |  Ett värde mellan 0 och 255(Endast för pulsform)  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+
|Attack/Decay  |  POKE   | ATK4 | ATK3 | ATK2 | ATK1 | DEC4| DEC3| DEC2| DEC1|
|              |  54291  | 128  |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+
|Sustain/      |  POKE   | SUS4 | SUS3 | SUS2 | SUS1 | REL4| REL3| REL2| REL1|
|       Release|  54292  | 128  |  64  |  32  |  16  |  8  |  4  |  2  |  1  |
+--------------+---------+------+------+------+------+-----+-----+-----+-----+

PROVA FÖLJANDE INSTÄLLNINGAR FÖR ATT SIMULERA OLIKA INSTRUMENT

+------------+----------+--------------+---------------+----------------+
| Instrument | Vågform  | Attack/Decay |Sustain/Release| Pulsform       |
+------------+----------+--------------+---------------+----------------+
| Piano      | Pulse    |       9      |        0      | Hög-0, Låg-255 |
| Flöjt      | Triangel |      96      |        0      | --             |
| Cembalo    | Sågtand  |       9      |        0      | --             |
| Xylofon    | Triangel |       9      |        0      | --             |
| Orgel      | Triangel |       0      |      240      | --             |
| Dragspel   | Triangel |     102      |        0      | --             |
| Trumpet    | Sågtand  |      96      |        0      | --             |
+------------+----------+--------------+---------------+----------------+

FÖRKLARING AV LJUDTERMER:
ADSR    -- Attack/Decay/Sustain/Release
Attack  -- Tiden till ljudet når sin högsta styrka
Decay   -- Tiden för ljudet att falla till sustainnivå
Sustain -- Förlänga tonen på en speciell nivå
Release -- Tiden för ljudet att avta från sustainnivå
Vågform -- "Formen" på ett ljud
Puls    -- Tonkvalitet på pulsvågform

OBS. Attack/Decay- och Sustain/Release-inställningarna ska alltid POKEas i
programmet INNAN vågformen POKEas in.


*********

End of the International Project 64 etext of the Swedish edition of the
Commodore 64 user's guide.

*********
