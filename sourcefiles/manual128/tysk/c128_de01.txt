*********

Welcome to iDOC= - the international CBM documentation project!

The goal of iDOC= is to preserve (non-English) Commodore related documents
in electronic text format that might otherwise cease to exist with the rapid
advancement of computer technology and declining interest in 8-bit computers
on the part of the general population. If you would like to help by
converting Commodore related hardcopy documents to electronic texts please
contact the manager of iDOC=, Peter Karlsson, at pk@abc.se.

Extensive efforts were made to preserve the contents of the original
document. However, certain portions, such as diagrams, program listings, and
indexes may have been either altered or sacrificed due to the limitations of
plain vanilla text. Diagrams may have been eliminated where ASCII-art was
not feasible. Program listings may be missing display codes where
substitutions were not possible. Tables of contents and indexes may have
been changed from page number references to section number references.
Please accept our apologies for these limitations, alterations, and possible
omissions.

Document names consists of a reasonably short unique title, followed by the
document language. Two optional fields follow; first the document version (0
for incomplete texts, version 1 is usually unnumbered), and then the
document source, if there are more than one. Finally, the document is given
a .txt extension.

The author(s) of the original document and members of iDOC= make no
representations about the accuracy or suitability of this material for any
purpose. This etext is provided "as-is". Please refer to the warranty of the
original document, if any, that may included in this etext. No other
warranties, express or implied, are made to you as to the etext or any
medium it may be on. Neither the author(s) nor the members of iDOC= will
assume liability for damages either from the direct or indirect use of this
etext or from the distribution of or modification to this etext. Therefore
if you read this document or use the information herein you do so at your
own risk.

*********

The iDOC= etext of the Commodore 128 German User's Manual, converted to text
by Christian Janoff <mepk@c64.org> et al.

c128_de01.txt, November 1999, etext #58.

Note from the etexters (in German): 

========================
= ÜBER DIESES HANDBUCH =
========================

Dies ist (die erste :-) Version 0.01 des deutschen Commodore 128-Handbuchs.
und kann deshalb noch viele Fehler enthalten. Insbesondere die Formatierung
ist noch nicht fertiggestellt. Ebenso sind diverse andere Unzulänglichkeiten
zwar bekannt, jedoch noch nicht beseitigt. Es sind jedoch alle Kapitel
und Anhänge (mehr oder weniger gut formatiert) vorhanden. Deshalb kann diese
Version des C128-Handbuchs schon jetzt eine große Hilfe für Leute sein, die
zwar einen C128 besitzen, denen jedoch das Handbuch fehlt.

Außerdem enthält dieser E-Text das vollständige Kapitel 7 ("CP/M-Handbuch"),
das im Original-Handbuch nicht vorhanden ist (wohl aufgrund der über 120
Seiten), sondern als eigenständiges Handbuch separat mitgeliefert wurde.

Es wird natürlich, Stück für Stück, weiter an diesem E-Text gearbeitet,
die endgültige, fertige Version wird Version 1.00 sein.

Die jeweils aktuelle Version dieses Handbuchs kann man jederzeit
kostenlos bei iDOC (http://www.softwolves.pp.se/idoc/) herunterladen.

Korrektur-/Formatiervorschläge und sonstige Hinweise sind stets willkommen!
(bitte per E-Mail an mich: mepk@c64.org)

================
= FORMATIERUNG =
================

- Bei der Formatierung aller Kapitel und Anhänge diente das Original-
  Handbuch als Vorbild. Die Formatierung wurde jedoch nicht vollständig
  übernommen, um ein einheitliches Aussehen des ASCII-Textes zu
  gewaehrleisten. Ziel war also, eine lesbare ASCII-Version schaffen.

- Überschriften bzw. Fettschrift wurden im ASCII-Text, wo es sinnvoll
  erschien, GROSSGESCHRIEBEN, um sie hervorheben zu können. Zukünftige
  HTML-Versionen dieses E-Textes sollten deshalb auch das Original-Handbuch
  als Vorbild haben, um statt der Großbuchstaben wieder Fettdruck verwenden
  zu können (usw.).

- Farblich (d.h. blau) hinterlegter Text wurde umrahmt.

- Die Seitenzahlen entsprechen denen im Original-Handbuch und stehen,
  wie dort, am Anfang jeder Seite. Im E-Text wurden sie in eckige Klammern
  gesetzt. Mit Hilfe eines Textbetrachters (z.B. "less" unter Unix)
  kann dann nach "[SEITE" gesucht werden, um so leicht von Seite zu
  Seite blättern zu können.
  Eine Seitenzahl besteht aus der Zeichenkette "SEITE", der Nummer des
  Kapitels bzw. dem Buchstaben des Anhangs, gefolgt von einem Bindestrich
  und der eigentlichen Seitenzahl des jeweiligen Kapitels bzw. dem
  Buchstaben des Anhangs. (z.B. "[SEITE 2-11]")
  Seitenzahlen unterbrechen im E-Text, anders als im Original-Handbuch,
  keinen Satz bzw. Absatz, sondern erscheinen erst NACH dem Satz bzw.
  Absatz (zur Erhhoehung der Lesbarkeit). In diesem Fall steht dann
  ein ^ hinter der Seitenzahl, um dies
  zu kennzeichnen (z.B. steht bei Kapitel 2, Seite 2 "[SEITE 2-2]^"),
  andernfalls entspricht die Seitenzahl exakt der im Original-Handbuch.
  Eine Seite, die mit ^ gekennzeichnet ist, beginnt also de facto im
  Absatz vor der Seitenzahl.

- Die Zeilenlaenge wurde auf 78 Zeichen begrenzt.

- "Knäuel-Listings" wurden Leerzeichen hinzugefügt, um sie lesbar zu
  machen.

===============================
= FEHLER IM ORIGINAL-HANDBUCH =
===============================

Die meisten Fehler des Original-Handbuchs sind in diesem E-Text
bereits korrigiert, ohne daß es besonders vermerkt wurde. Die meisten
davon waren Rechtschreibfehler, inhaltliche Fehler und Fehler beim
Referenzieren von Kapiteln.

Dank gebührt hier Marco Baye (für die Fehlerliste) sowie den fleißigen
Helfern, die beim Abtippen (bzw. Einscannen) sehr gut aufgepaßt haben!

Außerdem wurden:

- beim C128 existierende Befehle hinzugefügt, wenn sie nicht im Handbuch
  vermerkt waren.

- unzulässige Wort-Trennungen (z.B. "B- yte") korrigiert (übrigens
  wurde durchweg nach der "alten" Rechtschreibung korrigiert).

=========
= DANKE =
=========

Besonderer Dank geht an alle, die zum Entstehen des Handbuchs beigetragen
haben (in alphabetischer Reihenfolge):

Jürgen Barth
Marco Baye (stellte seine lange Fehlerliste zur Verfügung!)
Martin Brunner
Jens Erler
Mathias Gygax
Marc-Jano Knopp
Stephan Lesch
Kurt Ziegenbein

...und nun viel Spaß mit dem Handbuch!

Christian Janoff.
mepk@c64.org

*********

                 +-----------------------------------------+
                 |                                         |
                 |   C= Commodore 128  PERSONAL COMPUTER   |
                 |                                         |
                 |   C= Commodore 128D PERSONAL COMPUTER   |
                 |                                         |
                 |           BEDIENUNGSHANDBUCH            |
                 |                                         |
                 +-----------------------------------------+
                   (C) Copyright der deutschen Ausgabe bei
                Commodore Büromaschinen GmbH, Frankfurt 1985.

GLIEDERUNG DES C128-HANDBUCHES

Inhalt

1. Einführung .......................................................... 1-  1

2. Allgemeine Eigenschaften von BASIC
  2.1   Betriebsarten von BASIC ........................................ 2-  1
  2.2   BASIC-Zeilenformat und -Zeichenvorrat .......................... 2-  2
  2.3   Reservierte Wörter ............................................. 2-  3
  2.4   BASIC-Konstanten ............................................... 2-  5
  2.5   BASIC-Variablen ................................................ 2-  6
  2.5.1 Variablennamen und -Typen ...................................... 2-  6
  2.5.2 Feldvariablen .................................................. 2-  7
  2.6   Genauigkeit numerischer Werte .................................. 2-  8
  2.7   Numerische Ausdrücke und Operatoren ............................ 2-  9
  2.7.1 Arithmetische Operatoren ....................................... 2-  9
  2.7.2 Vergleichsoperatoren ........................................... 2-  9
  2.7.3 Logische Operatoren ............................................ 2- 11
  2.7.4 Funktionsoperatoren ............................................ 2- 13
  2.7.5 Mathematische Hierarchie ....................................... 2- 13
  2.8   Ausdrücke und Operatoren mit Zeichenketten ..................... 2- 14
  2.8.1 Verkettungsoperatore ........................................... 2- 15
  2.8.2 Zeichenkettenfunktionen ........................................ 2- 15

3. Eingeben und Verwalten von BASIC-Programmen
  3.1   Tastatur ....................................................... 3-  1
  3.2   Eingeben von Programmzeilen .................................... 3-  4
  3.3   Ersetzen oder Ändern von Programmzeilen ........................ 3-  6
  3.3.1 Ändern von Zeilen mit dem Bildschirmeditor ..................... 3-  6
  3.3.2 Ändern von Zeilen mit Syntax-Fehler ............................ 3-  6
  3.4   Speichern von BASIC-Programmen ................................. 3-  7
  3.5   Laden von BASIC-Programmen ..................................... 3-  7

4. C128-Modus
  4.1   Erweiterte Tastaturfunktionen im C128-Modus .................... 4-  1
  4.2   Erweiterte Bildschirmfunktionen im C128-Modus .................. 4-  8
  4.3   BASIC 7.0 im C128-Modus ........................................ 4-  9
  4.4   Struktur von BASIC ............................................. 4- 10
  4.5   Struktur und Syntax der Beschreibungen ......................... 4- 11
  4.6   Befehle, Anweisungen, Funktionen und Variablen ................. 4- 12
  4.7   Farben, Sprites und grafische Effekte .......................... 4-135
  4.8   Klänge und Musik mit dem C128 .................................. 4-152

5. C64-Modus
  5.1   BASIC 2.0 im C64-Modus ......................................... 5-  1
  5.2   Befehle, Anweisungen, Funktionen und Variable .................. 5-  1
  5.3   Farben und Grafik im C64-Modus ................................. 5- 74
  5.3.1 Sprite-Grafik im C64-Modus ..................................... 5- 84
  5.4   Musik im C64-Modus ............................................. 5- 94

6. Floppy-Disk-Betrieb mit BASIC
  6.1   Formatierung von Disketten ..................................... 6-  1
  6.2   Speicherung von Programmen ..................................... 6-  3
  6.3   Verwendung von Jokerzeichen in Dateinamen ...................... 6-  4
  6.4   Laden von Programmen ........................................... 6-  5
  6.5   Diskettenverzeichnisse ......................................... 6-  6
  6.6   Öffnen und Schließen von Dateien ............................... 6-  9
  6.7   Schreib-/Lesezeiger in Relativdateien .......................... 6- 11
  6.8   Löschen von Diskettendateien ................................... 6- 13
  6.9   Weitere Verwaltungsfunktionen .................................. 6- 14
  6.9.1 Diskettenbelegung überprüfen und bereinigen .................... 6- 14
  6.9.2 Datei kopieren ................................................. 6- 15
  6.9.3 Verkettung sequentieller Dateien ............................... 6- 15
  6.9.4 Datei umbenennen ............................................... 6- 16
  6.9.5 Diskette duplizieren ........................................... 6- 17

7. CP/M-Modus
  7.1 Einleitung ....................................................... 7-  1
  7.2 Starten von CP/M 3.0 ............................................. 7-  3
  7.3 CP/M Dateien ..................................................... 7-  8
  7.4 Kopieren der CP/M-Disketten und Dateien .......................... 7- 15
  7.5 Steuern der Ein- und Ausgabe ..................................... 7- 19
  7.6 Arbeiten unter CP/M .............................................. 7- 24
  7.7 Erweiterungen des CP/M 3.0 ....................................... 7- 28
  7.8 CP/M 3.0-Befehlsübersicht ........................................ 7- 34
  7.9 CP/M 3.0-Befehlsbeschreibungen ................................... 7- 39

8. Fehlermeldungen
  8.1   BASIC-Fehlermeldungen .......................................... 8-  1
  8.2   Floppy-Disk-Fehlermeldungen .................................... 8-  6

  Anhang A: Zeichencode-Tabellen, Steuercodes
  Anhang B: Speicherorganisation
  Anhang C: Maschinensprache-Monitor
  Anhang D: Besonderheiten der DIN-Tastatur
  Anhang E: Registerzuordnungen beim SID und VIC
  Anhang F: Musiknotentabelle
  Anhang G: Besonderheiten im C64-Modus (Funkt.-Tasten, Grafik)
  Anhang H: Organisation der zero page
  Anhang I: BASIC-Abkürzungen
  Anhang J: Definition von anwenderspezifischen Zeichensätzen
  Anhang K: Abgeleitete mathematische Funktionen
  Anhang L: Steckerbelegungen
  Anhang M: Übertragung von BASIC4-Programmen nach BASIC7

ALLGEMEINE HINWEISE ZU DIESEM HANDBUCH

Das Bildsignal des 80-ZEICHEN-MODUS  IST NUR AM RGBI-AUSGANG vorhanden,  nicht
am Video- bzw.  Fernsehausgang,  d.h.  bei Anschluß eines  Fernsehgerätes oder
eines  Monitors  an der Fernsehbuchse bzw.   an  der Videobuchse  kann  nur im
40-Zeichen-Modus gearbeitet werden.  Umgekehrt  ist der 40-Zeichen-Modus nicht
am RGBI-Ausgang verfügbar.

Die mitgelieferte CP/M-Systemdiskette ist  beidseitig beschreiben. Wir empfeh-
len  Ihnen, von jeder Seite eine   Arbeitskopie anzufertigen und die Original-
diskette an einem sicheren Ort aufzubewahren.

ALLE INFORMATIONEN, DIE IN DIESEM HANDBUCH UNTER C128 BESCHRIEBEN SIND, GELTEN
EBENFALLS FÜR DEN C128D.

[SEITE 1-1]

*********************
*                   *
*   1. EINFÜHRUNG   *
*                   *
*********************

Machen Sie Bekanntschaft mit dem neuen C128 von Commodore, dem "großen Bruder"
des weltweit bekannten C64.

Der neue C128 erlaubt Ihnen die Auswahl zwischen drei Betriebsarten, so daß er
nahezu all Ihren speziellen Wünschen und Anforderungen gerecht wird.

  * Der C128-Modus - Hierfür gibt es das neue BASIC 7.0. Eine um viele
    Funktionen und Befehle erweiterte BASIC-Version, die einen Speicher
    von 128 kByte unterstützt.

  * Der C64-Modus - Ist absolut kompatibel zum C64. Es ist möglich, alle
    Software des C64 zu nutzen.

  * Der CP/M-Modus - Ermöglicht den Einsatz sämtlicher Software, die für die
    Betriebssysteme CP/M 3.0 und CP/M 2.2 geschreiben wurde.

Die Umschaltung zwischen den Betriebs-Modi kann programmiert erfolgen.

Aufgrund  der Softwarekompatibilität zum  C64  und zum Betriebssystem CP/M 3.0
ist ein fast unübersehbares Softwareangebot einsetzbar.

Damit ist der Commodore 128 einzigartig in seiner Klasse.

[SEITE 1-2]

DIE KENNZEICHEN DES COMMODORE 128D

  * 128 kByte Arbeitsspeicher
  * Erweiterbar bis 512 kByte Speicherkapazität
  * 40 und 80 Zeichen pro Zeile (80 Zeichen nur in Verbindung mit RGBI-
    oder Monochrom-Monitor zur Darstellung von 80 Zeichen pro Zeile)
  * 16 Farben mit hochauflösender Grafik
  * Integriertes BASIC 7.0 mit mehr als 150 Befehlen
  * BASIC-Befehle für Grafik und Sound

DAS KEYBOARD DES COMMODORE 128D

  * Ergonomische Tastatur
  * Numerischer Tastenblock mit 14 Tasten

DAS INTEGRIERTE 5,25-ZOLL FLOPPY-LAUFWERK

  * Doppelseitige Speicherung
  * MFM Double Density (CP/M)
  * Lesen von EPSON, IBM, KAYPRO und OSBORNE CP/M-Disketten
  * Speicherkapazität 336 kByte (formatiert)
  * Serielle Commodore Schnittstelle
  * Datenübertragungsrate bis zu 5200 Zeichen/Sekunde
  * Kompatibel zum Commodore 1541 Floppy-Disk-Drive
  * Enthält DOS Shell Utility auf der Test-Demo-Diskette

DREI VERSCHIEDENE BETRIEBSSYSTEME

  * COMMODORE 64 (BASIC 2.0)
  * COMMODORE 128 (BASIC 7.0)
  * CP/M PLUS VERSION 3.0


[SEITE 2-1]

******************************************************************************
  2. ALLGEMEINE EIGENSCHAFTEN VON BASIC

     2.1 Betriebsarten von BASIC
     2.2 BASIC-Zeilenformat und -Zeichenvorrat
     2.3 Reservierte Wörter
     2.4 BASIC-Konstanten
     2.5 BASIC-Variablen
     2.6 Genauigkeit numerischer Werte
     2.7 Numerische Ausdrücke und Operatoren
     2.8 Ausdrücke und Operatoren mit Zeichenketten
******************************************************************************

2. ALLGEMEINE EIGENSCHAFTEN VON BASIC
=====================================

Dieses Kapitel enthält  wichtige Informationen über  viele grundlegende Eigen-
schaften des   BASIC-Interpreters und sollte   vor der  Erstellung  von BASIC-
Programmen  von denjenigen Andwendern beachtet  werden,  die mit dem Programm-
ieren in Commodore-BASIC noch keine Erfahrung  haben.  Aber auch für den Fach-
mann enthält dieses Kapitel viel Wissenswertes.

2.1 BETRIEBSARTEN VON BASIC
---------------------------

Der BASIC-Interpreter  kennt  grundsätzlich zwei Betriebsebenen:  die Befehls-
ebene (Direktmodus) und die Programmebene.

Die  BEFEHLSEBENE oder der  DIREKTMODUS  ist  aktiv,  wenn der  Rechner einge-
schaltet oder wenn ein BASIC-Programm  ordnungsgemäß oder durch Ausgabe  einer
Fehlermeldung beendet wurde. Sie ist durch die Bildschirmmeldung

,---------------------------------------------.
|  READY.                                     |
`---------------------------------------------'

und darunter wartendem Cursor (Positionsanzeiger) gekennzeichnet.

In der  Befehlsebene können fast alle  Befehle, Anweisungen und Funktionen des
Interpreters ausgeführt werden, indem  diese ohne vorangestellte  Zeilennummer
eingegeben werden. Drücken der RETURN-Taste schließt in jedem Fall die Eingabe
ab  und  übergibt sie  dem  Interpreter zur  Ausführung.   Nach der Ausführung
befindet sich BASIC wieder in der Befehlsebene.

                                ,--------------------------------------------.
Beispiel 1:                     |  READY.                                    |
                                |  PRINT 5*2                                 |
                                |  10                                        |
                                |  READY.                                    |
                                `--------------------------------------------'

Wird dem eingegebenen  Befehl, der Anweisung   oder Funktion jedoch eine  Zahl
vorangestellt, so  übernimmt der Interpreter diese  Zeile als Programmzeile in
den Hauptspeicher  und  führt die darin  enthaltenenen  Anweisungen  erst nach
Eingabe des RUN-Befehls  oder einer auf  diese Zeile  bezogenen GOTO-Anweisung
aus. Auf diese Weise können Programme eingegeben werden.

[SEITE 2-2]^
                                ,--------------------------------------------.
Beispiel 2:                     |  READY.                                    |
                                |  10 PRINT"ERGEBNIS IST";                   |
                                |  20 PRINT 5*2                              |
                                |  RUN                                       |
                                |  ERGEBNIS IST 10                           |
                                |  READY.                                    |
                                `--------------------------------------------'

In  der PROGRAMMEBENE befindet sich  der Interpreter, sobald  der Anwender das
eingegebene Programm gestartet hat.  Der Cursor (Positionsanzeiger) verschwin-
det dann (Ausnahme ist  hier  die INPUT-Anweisung  für die  Daten-eingabe über
Tastatur) und erscheint  erst wieder, wenn  der Interpreter nach der Programm-
ausführung wieder auf die Befehlsebene zurückkehrt (s. oben Beispiel 2).

2.2 BASIC-ZEILENFORMAT UND -ZEICHENVORRAT
-----------------------------------------

Ein BASIC-Programm besteht grundsätzlich aus Programmzeilen, die das folgende
Format haben müssen:

  nnnnn Befehl [:Befehl...][:REM Kommentar]

'nnnnn'  - Eine Zeilennummer  als ganze  Zahl  zwischen  0 und 63999,  die die
Reihenfolge der Programmzeilen im Hauptspeicher festlegt  und auch als Bezugs-
nummer für Programmverzweigungen dient.

'Befehl' - Ein beliebiger  BASIC-Befehl  oder eine beliebige  BASIC-Anweisung,
-Funktion oder -Variable (s. Kapitel 4.6  und 5.2). Mehrere solcher Befehle in
einer Zeile müssen durch Doppelpunkte (:) voneinander getrennt werden.

'Kommentar' - Freier Text zur Kommentierung des Programms, der nach einer REM-
Anweisung folgt.

  * Anmerkung: Die Gesamtlänge einer BASIC-Programmzeile darf 160 Zeichen
               nicht überschreiten. (Im C64-Modus max. 80 Zeichen)

[SEITE 2-3]

Neben den  Groß- oder  Kleinbuchstaben des   lateinischen Alphabets sowie  den
Ziffern 0 bis 9 kennt  BASIC eine Reihe  von Sonderzeichen, die eine besondere
Bedeutung haben:

+----------------------------------------------------------------------------+
|   Zeichen     Bedeutung                                                    |
|                                                                            |
|   +           Plussymbol oder Verkettungssymbol für Zeichenketten          |
|   -           Minussymbol oder Bindestrich                                 |
|   *           Multiplikationssymbol oder Stern                             |
|   /           Divisionssymbol oder Schrägstrich                            |
|   ^           Potenzierungssymbol                                          |
|   =           Gleichheitszeichen oder Zuweisungssymbol                     |
|   <           Kleiner-als-Symbol oder linke spitze Klammer                 |
|   >           Größer-als-Symbol oder rechte spitze Klammer                 |
|   (           linke Klammer                                                |
|   )           rechte Klammer                                               |
|   [           linke eckige Klammer                                         |
|   ]           rechte eckige Klammer                                        |
|   %           Typsymbol für ganze Zahlen oder Prozentzeichen               |
|   $           Typsymbol für Zeichenketten oder Dollarzeichen               |
|   .           Dezimalpunkt oder Punkt                                      |
|   ,           Tabulierungszeichen oder Komma                               |
|   :           Trennzeichen für Befehle oder Doppelpunkt                    |
|   ;           Zeilenvorschubunterdrückung oder Semikolon                   |
|   "           Zeichenketten-Anfang bzw. -Ende oder Anführungszeichen       |
|   ?           Abkürzung für PRINT-Anweisung oder Fragezeichen              |
+----------------------------------------------------------------------------+

Alle diese Zeichen können  auch als normale  druckbare Zeichen Bestandteil von
Zeichenketten sein. Weitere druckbare Zeichen sind in der vollständigen ASCII-
Zeichencodetabelle im Anhang A zusammengestellt.

2.3 RESERVIERTE WÖRTER
----------------------

Die für den BASIC-Interpreter  reservierten Wörter sind die  Bezeichnungen für
die verschiedenen  Befehle,  Anweisungen, Funktionen, Variablen  und logischen
Operatoren. Sie dürfen nicht als Variablennamen verwendet werden. Im folgenden
sind alle reservierten Wörter alphabetisch zusammengestellt.

[SEITE 2-4]^

ABS             DLOAD           INPUT#          QUIT            STEP
AND             DO              INT                             STOP
APPEND          DOPEN                           RCLR            SWAP
ASC             DRAW            JOY             RDOT            SYS
ATN             DS                              READ
AUTO            DSAVE           KEY             RECORD          TAB
                DS$                             REM             TAN
BACKUP          DVERIFY         LEFT$           RENAME          TEMPO
BANK                            LEN             RENUMBER        THEN
BEGIN           EL              LET             RESTORE         TI
BEND            ELSE            LIST            RESUME          TI$
BLOAD           END             LOAD            RETURN          TO
BOOT            ENVELOPE        LOCATE          RGR             TRAP
BOX             ER              LOG             RIGHT$          TRON
                ERR$            LOOP            RND             TROFF
BSAVE           EXIT                            RREG
BUMP            EXP             MID$            RSPCOLOR        UNTIL
                                MONITOR         RSPPOS          USING
CATALOG         FAST            MOVSPR          RSPRITE         USR
CHAR            FETCH                           RUN
CHR$            FILTER          NEW             RWINDOW         VAL
CIRCLE          FNxx            NEXT                            VERIFY
CLOSE           FOR             NOT             SAVE            VOL
CLR             FRE                             SCALE
CMD                             OFF             SCNCLR          WAIT
COLLECT         GET             ON              SCRATCH         WHILE
COLLISION       GETKEY          OPENM           SGN             WIDTH
COLOR           GO              OR              SIN             WINDOW
CONCAT          GOSUB                           SLEEP
CONT            GOTO            PAINT           SLOW            XOR
COPY            GRAPHIC         PEEK            SOUND
                GSHAPE          PEN             SPC
DATA                            PLAY            SPRCOLOR
DCLEAR          HEADER          POINTER         SPRDEF
DCLOSE          HELP            POKE            SPRITE
DEC             HEX$            POS             SPRSAV
DEF                             POT             SQR
DELETE          IF              PRINT           SSHAPE
DIM             INSTR           PRINT#          ST
DIRECTORY       INPUT           PUDEF           STASH

[SEITE 2-5]^

2.4 BASIC-KONSTANTEN
--------------------

Konstanten  sind aktuelle  Werte,  die der BASIC-Interpreter  während der Pro-
grammausführung   verwendet.  Er  unterscheidet dabei zwischen  Zeichenketten-
Konstanten und numerischen Konstanten.

Eine ZEICHENKETTENKONSTANTE ist eine  Folge von bis  zu 255 beliebigen (alpha-
numerischen) Zeichen, die in Anführungszeichen (") eingeschlossen ist. Z.B.:

  "HAUS"
  "Hund und Katze"
  "DM 12.80"

NUMERISCHE KONSTANTEN sind positive  oder negative Zahlen,  die außer dem Vor-
zeichen nur einen Dezimalpunkt (KEIN Komma)  enthalten dürfen. Der Interpreter
unterscheidet drei verschiedene Arten von numerischen Konstanten:

GANZZAHLIGE KONSTANTEN sind ganze Zahlen im Bereich zwischen -32768 und +32767
ohne Dezimalpunkt. Z.B.:

  125

FESTKOMMAKONSTANTEN sind alle positiven oder negativen reelen Zahlen mit einem
Dezimalpunkt. Z.B.:

  15.12

GLEITKOMMAKONSTANTEN sind alle positiven oder negativen Zahlen in Exponential-
darstellung  (wissenschaftliche Darstellung). Sie   bestehen aus einer  ganzen
oder einer  Festkommazahl  (Mantisse) mit oder   ohne  Vorzeichen, gefolgt vom
Buchstaben E und einer  ganzen Zahl im Bereich  zwischen -39 und +38 mit  oder
ohne Vorzeichen, die den Exponenten zur Basis 10 darstellt. Z.B.:

[SEITE 2-6]^

  15E-3             gleichbedeutend mit 0.015

  146.285E-6        gleichbedeutend mit 0.000146285

Der  Interpreter akzeptiert Gleitkommakonstanten  im  Bereich von 1.7E+38  bis
2.9E-39 und -2.9E-39 bis -1.7E+38.


2.5 BASIC-VARIABLEN
-------------------

Variablen sind Namen, die Werte repräsentieren, welche in einem BASIC-Programm
verwendet werden. Der Interpreter unterscheidet dabei zwischen

  * Zeichenketten-Variablen
  * numerischen Variablen

ZEICHENKETTENVARIABLEN dürfen aus bis zu 255 Zeichen bestehen. Die Anzahl
dieser Zeichen bestimmt die Länge des Variablenwertes.

NUMERISCHE VARIABLEN haben immer einen Wert, der aus einer Zahl besteht.

Der  Wert einer  Variablen kann dieser  explizit  vom Programmierer oder,  als
Ergebnis von   Programmoperationen,  vom  Programm zugewiesen   werden. Werden
Variablen benutzt, ehe  ihnen ein Wert zugewiesen  wurde, ist ihr Wert im Fall
von numerischen Variablen 0 und im Fall  von Zeichenkettenvariablen eine leere
Zeichenkette der Länge 0 (Leer-String).

2.5.1 VARIABLENNAMEN UND -TYPEN
-------------------------------

Der BASIC-Interpreter akzeptiert  beliebig lange Variablennamen, interpretiert
jedoch nur die ersten  2 Zeichen sowie ggf. das  letzte, das  den Variablentyp
definiert (s.u.) und  eines  der Sonderzeichen $ oder   % sein muß,  wenn  ein
anderer Typ als Gleitkomma definiert werden soll.

[SEITE 2-7]^

Ein Variablenname muß  als erstes Zeichen  einen Buchstaben haben und darf aus
Buchstaben und Ziffern in jeder beliebigen  Kombination bestehen. Er darf kein
reserviertes BASIC-Wort (s. Kapitel 2.4) sein.

Beispiele:

  SIN=101                verboten (SIN-Funktion)
  FN$="NAME"             verboten (Benutzerfunktion DEFFN)

Der  Name einer Variablen  dient nicht nur  ihrer  Benennung, sondern auch der
Definition ihres Typs.

ZEICHENKETTENVARIABLEN werden  durch ein $ als  letztem Zeichen im Namen defi-
niert. Z.B.:

  C$="COMMODORE"

NUMERISCHE GANZZAHLVARIABLEN (Typ integer) werden durch ein % als letztem Zei-
chen im Namen definiert:

  TAG%=30

NUMERISCHE GLEITKOMMAVARIABLE (Typ real) haben  kein  Sonderzeichen am Namens-
ende:

  ZINS=15.84

Je nach Art der numerischen Variablen ist der Platzbedarf bei

  Ganzzahlvariablen                2 Bytes
  Gleitkommavariablen              5 Bytes (10 Stellen)


2.5.2 FELDVARIABLEN
-------------------

Ein Feld   ist eine Gruppe oder  Tabelle   von numerischen oder Zeichenketten-
werten, die durch einen Variablennamen  repräsentiert wird. Jeder dieser Werte
wird als  Feldelement bezeichnet und mit  einem  Index zum  Varaiblennamen be-
schrieben.  Dieser Index  ist eine ganze  Zahl oder ein ganzzahliger Ausdruck.
Einem Feldvariablennamem sind  genausoviele  Indizes zugeordnet, wie  das Feld
Dimensionen  hat. Die Dimensionierung eines  Feldes, mit der gleichzeitig auch
die Benennung verbunden ist, erfolgt mit der Anweisung DIM (s. dort in Kapitel
5.2). Beispiele:

[SEITE 2-8]

  DIMX(25)       Ein eindimensionales Gleitkommafeld X mit 26 Elementen
                 (0 bis 25) wird dimensioniert.

  DIMX$(2,6)     Ein zweidimensionales Zeichenkettenfeld mit 21 Elementen
                 (3*7) wird dimensioniert.

Mit  der Dimensionierung werden  alle  Feldelemente des dimensionierten Feldes
auf Null gesetzt.

Der Index bestimmt die Position eines Elementes im Feld.

Die maximale Anzahl  von Elementen in jeder  Dimension  ist 32767 und es  sind
maximal  255  Dimensionen möglich.   Auf jeden  Fall   begrenzt der verfügbare
Speicher die Größe eines Feldes.

Bei zweidimensionalen Feldern gibt der erste Index grundsätzlich die Zeile und
der zweite Index die Spalte der durch ein solches Feld gebildeten Tabelle an.

Eindimensionale Felder mit bis zu 11 Elementen brauchen nicht dimensioniert zu
werden. Wird in einem Programm z.B. die Anweisung

  A(6)=12.3

verwendet, ohne daß vorher A dimensioniert wurde, so führt der Interpreter in-
tern die Anweisung

  DIMA(10)

aus und dimensioniert damit das Feld selbst.

Für die Namensvergabe  und  den Typ  gelten dieselben Regeln  wie für einfache
Variablen (s. Kapitel 2.5.1).


2.6 GENAUIGKEIT NUMERISCHER WERTE
---------------------------------

Numerische Werte können, wie bereits erwähnt, intern als ganze Zahlen oder als
reelle Zahlen gespeichert werden.
Ganzzahlige Werte werden  in  zwei Byte des   Hauptspeichers abgelegt.  Reelle
Werte werden als  Gleitkommazahlen  mit einer Genauigkeit  bis  zu 10  Stellen
gespeichert.

[SEITE 2-9]

Konstanten,  die keine  ganzen Zahlen sind,  können folgendermaßen geschrieben
werden:

  * bis zu 10 Zeichen                           z.B. 100.59
  * Exponentialdarstellung mit E                z.B. 3.57E-05


2.7 NUMERISCHE AUSDRÜCKE UND OPERATOREN
---------------------------------------

Ein  numerischer  Ausdruck kann eine numerische  Konstante  oder Variable oder
eine Kombination  aus  numerischen Konstanten,  Variablen und   Operatoren zur
Berechnung eines einzelnen Wertes sein.   Die Operatoren führen dabei mit  den
Werten mathematische oder logische  Operationen durch.  Der  BASIC-Interpreter
kennt vier verschiedene Kategorien von Operatoren:

  * arithmetische Operatoren
  * Vergleichsoperatoren
  * logische Operatoren
  * Funktionsoperatoren


2.7.1 Arithmetische Operatoren
------------------------------

Es gibt sechs arithmetische Operatoren. Es sind  dies in der Reihenfolge ihrer
Berücksichtigung (mathematische Hierarchie) in einem numerischen Ausdruck:

Operator             Operation                       Beispiel

^                    Potenzierung                    A^5
-                    Negation                        -A
*, /                 Multiplikation, Division        A*5, A/5
+, -                 Addition, Subtraktion           A+5, A-5


2.7.2 VERGLEICHSOPERATOREN
--------------------------

Vergleichsoperatoren dienen  dem  Vergleich  zweier numerischer oder  Zeichen-
kettenwerte.  Das  Ergebnis ist entweder logisch  "wahr" mit dem  Wert -1 oder
logisch "falsch" mit dem Wert 0 (Null) und wird meistens in Verbindung mit der
IF-Anweisung (s.  dort in  Kapitel   5.2) zur Steuerung des   Programmablaufes
verwendet.

[SEITE 2-10]

Im folgenden sind die sechs verschiedenen Vergleichsoperatoren, die der BASIC-
Interpreter kennt, tabellarisch zusammengestellt.

Operator        Vergleich auf                        Beispiel

=                Gleichheit                          A=B
<>, ><           Ungleichheit                        A<>B, A><B
<                kleiner als                         A<B
>                größer als                          A>B
<=, =<           kleiner als oder gleich             A<=B, A=<B
>=, =>           größer als oder gleich              A>=B, A=>B

Wenn in einem Ausdruck sowohl arithmetische als auch Vergleichsoperatoren vor-
kommen, so werden zuerst die arithmetischen Operatoren abgearbeitet.

Beispiele:      A+B < (X-Y) / Z

                Dieser Ausdruck ist "wahr" (liefert den Wert -1), wenn der
                Wert von A+B kleiner ist als der Wert X-Y dividiert durch Z.

                100 IF SIN(X)<0 THEN 1000

                Wenn der SIN(X) negativ wird, liefert der Vergleich ein
                "wahres" Ergebnis (-1) und das Programm verzweigt nach
                Zeile 1000.

Bei Zeichenkettenvergleichen wird   von beiden  Ketten zeichenweise  der  CBM-
ASCII-Code verglichen.   Es  werden  alle  Zeichen,   also auch führende   und
nachfolgende  Leerstellen verglichen. Die  Wirkung  ist am besten an folgenden
Beispielen zu  erkennen,  die  alle logisch  "wahr"   sind, also den  Wert  -1
liefern:

  "AA"<"AB"
  "Aa"<"AA"
  "HAUS"="HAUS"
  "HAUS">"HANS"
  "A!"<"A$"
  "U">"U"
  X$="12":X$<"13"

[SEITE 2-11]

2.7.3 LOGISCHE OPERATOREN
-------------------------

Logische Operatoren   dienen  zum  Testen  von Mehrfachvergleichen,   zur Bit-
Manipulation oder zum  Durchführen   Boolescher  Operationen  mit  numerischen
Werten.

Ein logischer  Operator verknüpft zwei  Operanden  als Kombination aus "wahr"-
und "falsch"-Werten bitweise und liefert als Ergebnis einen Wert, der entweder
als "wahr" (von Null verschieden) oder als "falsch" (Null) interpretiert wird.

Der Interpreter führt Operationen mit logischen Operatoren in einem gemischten
Ausdruck NACH den arithmetischen und den Vergleichsoperationen durch.

Der Interpreter kennt drei verschiedene logische  Operatoren, die im folgenden
in  der Reihenfolge, wie sie   bearbeitet werden, mit ihren  Wahrheitstabellen
dargestellt werden:

Operator                Operand 1        Operand 2        Ergebnis

NOT (log. Komplement)   wahr             -                falsch
                        falsch           -                wahr

AND (Konjunktion)       wahr             wahr             wahr
                        wahr             falsch           falsch
                        falsch           wahr             falsch
                        falsch           falsch           falsch

OR (Disjunktion)        wahr             wahr             wahr
                        wahr             falsch           wahr
                        falsch           wahr             wahr
                        falsch           falsch           falsch

Genau  wie die Vergleichsoperatoren über ihr  Ergebnis  zur Steuerung des Pro-
grammablaufes beitragen können, kann dies auch  durch die Verknüpfung von zwei
oder mehreren Vergleichen durch logische   Operatoren geschehen, die  wiederum
"wahr- und "falsch"-Werte liefern (s.a. IF-Anweisung in Kapitel 5.2).

[SEITE 2-12]

Die folgenden Beispiel-Programmzeilen sollen dies verdeutlichen:

,--------------------------------------------.
|  100 IF D<200 AND F<4 THEN 80              |
|  110 IF I>10 OR K<0 THEN 50                |
|  120 IF NOT P THEN 100                     |
`--------------------------------------------'

Die logischen Operatoren arbeiten intern folgendermaßen:

Zunächst werden die  beiden Operanden in ganze, vorzeichenbehaftete Zweierkom-
plement-16-Bit-Zahlen im Bereich zwischen -32768  und +32767 umgewandelt. Sind
die Operanden größer oder kleiner, so wird die Fehlermeldung

,--------------------------------------------.
|  ILLEGAL QUANTITY ERROR                    | (unerlaubter Betrag)
`--------------------------------------------'

angezeigt.

Sind die  beiden Operanden 0 und/oder -1,  so liefert  eine logische Operation
ebenfalls 0 oder -1. Die Operation wird  auf jeden Fall bitweise durchgeführt,
d.h. jedes  Ergebnis-Bit wird  durch  die beiden  entsprechenden Bits  in  den
Operanden bestimmt.  Dabei bedeutet  ein  1-Bit "wahr"und ein 0-Bit  "falsch".
Dadurch ist es  möglich, mit Hilfe  der logischen Operatoren das Bitmuster von
Speicherzellen zu  testen.  Z.B. kann ein   Byte an einer Ein-/Ausgabeschnitt-
stelle  maskiert werden, um den Zustand  eines bestimmten Bits zu testen (s.a.
WAIT-Anweisung  in Kapitel   5.2).   Auch kann mit   dem  OR-Operator in einem
bestimmten Byte ein ganz  bestimmtes Bitmuster  erzeugt werden. Die  folgenden
Beispiele sollen die Arbeitsweise der logischen Operatoren erläutern:

  63 AND 16 = 16                0000000000111111        63
                        AND     0000000000010000        16
                                0000000000010000 =      16

  15 AND 14 = 14                0000000000001111        15
                        AND     0000000000001110        14
                                0000000000001110 =      14

  -1 AND 8 = 8                  1111111111111111        -1
                        AND     0000000000001000         8
                                0000000000001000 =       8

[SEITE 2-13]

  4 OR 2 = 6                    0000000000000100         4
                        OR      0000000000000010         2
                                0000000000000110 =       6

  10 OR 10 = 10                 0000000000001010        10
                        OR      0000000000001010        10
                                0000000000001010 =      10

  -1 OR -2 = -1                 1111111111111111        -1
                        OR      1111111111111110        -2
                                1111111111111111 =      -1

  NOT 1 = -2                    0000000000000001         1
                        NOT     1111111111111110 =      -2

Der Operator NOT bildet das Einerkomplement des Operanden.


2.7.4 FUNKTIONSOPERATOREN
-------------------------

Funktionsoperatoren (BASIC-Funktionen)  werden dazu verwandt, an einem Operan-
den eine festgelegte Operation  auszuführen.  Solche im BASIC-Interpreter ent-
haltenen  Funktionen sind z.B.  SQR  (Quadratwurzel ziehen) oder SIN (trigono-
metrischer Sinus). Es  ist auch möglich,  mit Hilfe der DEFFN-Anweisung eigene
Funktionen zu definieren. Einzelheiten zu den  Funktionen sind in den Kapiteln
4.6 und 5.2 ausführlich beschrieben.


2.7.5 MATHEMATISCHE HIERARCHIE
------------------------------

Bei  der  Bearbeitung numerischer  Ausdrücke und   Operatoren  hält der BASIC-
Interpreter folgende  mathematische Hierarchie  ein (1  höchste,  8 niedrigste
Priorität):

  1. Funktionsaufrufe
  2. Potenzierung (^)
  3. Negation (Wandlung von Plus nach Minus u. umgekehrt)
  4. Multiplikation und Division (*, /)

[SEITE 2-14]

  5. Addition und Subtraktion (+, -)
  6. logisches Komplement (NOT)
  7. Konjunktion (AND)
  8. Disjunktion (OR)

Aufeinanderfolgende Operatoren derselben Hierarchiestufe werden von links nach
rechts abgearbeitet. Die Hierarchie kann  durch Verwendung von Klammern aufge-
hoben werden. Geklammerte Ausdrücke werden grundsätzlich zuerst bearbeitet.

Bei  geschalteten Klammerausdrücken  wird  grundsätzlich der innerste Klammer-
ausdruck zuerst bearbeitet.

Folgende Beispiele verdeutlichen dies:

  4+1*2                  ergibt   6
  (4+1)*2                ergibt  10
  100*4/2-1              ergibt 199
  100*(4/2-1)            ergibt 100
  100*(4/(2-1))          ergibt 400

2.8 ZEICHENKETTENAUSDRÜCKE UND OPERATIONEN MIT ZEICHENKETTEN
------------------------------------------------------------

Ein Zeichenkettenausdruck kann eine Zeichenkettenkonstante oder -Variable oder
eine Kombination aus  Zeichenkettenkonstanten, -variablen und -operatoren  zur
Erzeugung  einer neuen Zeichenkette  sein.  Die  Operatoren kombinieren  dabei
Zeichenketten zu neuen Zeichenketten.  Der  BASIC-Interpreter kennt zwei Typen
von Zeichenkettenoperatoren:

  * Verkettungsoperator
  * Funktionsoperator oder Zeichenkettenfunktion

Da der Zeichenkettenvergleich  prinzipiell ein numerischer Vergleich  ist, ist
er im Kapitel 2.7.2 bei den Vergleichsoperatoren beschrieben.

[SEITE 2-15]

2.8.1 VERKETTUNGSOPERATOR
-------------------------

Zeichenketten können mit dem Plus-Zeichen (+) aneinandergefügt werden, um neue
Zeichenketten zu bilden. Z.B.:

,--------------------------------------------.
|  10 A$="REGEN":B$="SCHIRM"                 |
|  20 PRINT A$+B$+"E"                        |
|  RUN                                       |
|  REGENSCHIRME                              |
|  READY.                                    |
`--------------------------------------------'

2.8.2 ZEICHENKETTENFUNKTIONEN
-----------------------------

Wie bei den numerischen Funktionen (s. Kapitel 2.7.4) führt die Zeichenketten-
funktion an einem oder mehreren Operanden  eine festgelegte Operation aus, die
als Ergebnis eine Zeichenkette liefert.   Solche im BASIC-Interpreter  enthal-
tenen Funktionen sind  z.B.  CHR$ (Bildung  einer Ein-Zeichen-Kette aus  einem
ASCII-Code)  oder  STR$   (Bildung  eines   Zeichenkettenäquivalents  zu einem
numerischen Ausdruck).  Es  ist jedoch  nicht möglich,  eigene  Zeichenketten-
funktionen mit Hilfe  der DEF FN-Anweisung  zu definieren. Einzelheiten zu den
Zeichenkettenfunktionen  sind  in den   Kapiteln 4.6  und  5.2 ausführlich be-
schrieben.


+--------------------------------------------------------------------+
|                                                                    |
|  3. Eingeben und Verwalten von BASIC-Programmen                    |
|  ==============================================                    |
|    3.1 Tastatur                                                    |
|    3.2 Eingeben von Programmzeilen                                 |
|    3.3 Ersetzen oder Ändern von Programmzeilen                     |
|    3.4 Speichern von BASIC-Programmen                              |
|    3.5 Laden von BASIC-Programmen                                  |
|                                                                    |
+--------------------------------------------------------------------+

[SEITE 3-1]

3.1 TASTATUR
------------

Abbildung 3.1  auf der nächsten Seite  zeigt die Tastatur  des C128.  Im C128-
Modus können alle Tasten verwendet  werden, im C64-Modus nur die schraffierten
Tasten. In diesem Abschnitt werden alle die  Tasten beschrieben, die in beiden
Modi verwendet werden können, also die schraffierten Tasten.

TASTATURMODI: Die Tastatur des C128 erlaubt zwei Betriebsmodi, nämlich

  * Großbuchstaben/Grafik-Symbole
  * Kleinbuchstaben/Großbuchstaben.

Nach  dem Einschalten des Rechners  ist der Großbuchstaben/Grafik-Modus aktiv.
Um zwischen den beiden  Modi hin- und  herzuschalten, werden die Umschalttaste
(SHIFT) und die C=-Taste (Commodore-Taste) zusammen gedrückt.

SCHREIBMASCHINENTASTATUR:  Den  Hauptteil   der Tastatur nimmt   das  Schreib-
maschinen-Tastenfeld ein, das auch so funktioniert.

Neben den Buchstaben-  und  Zeichentasten gibt  es eine Reihe  von Bedienungs-
tasten, deren Funktion teilweise anders ist als bei der Schreibmaschine.

UMSCHALTTASTEN: Die  Umschalttasten (SHIFT-Tasten)   dienen  je  nach  aktivem
Tastaturmodus  zur Eingabe von Großbuchstaben  oder den Sonderzeichen, die auf
den doppelt belegten Tasten oben abgebildet sind (z.B.  <  >) bzw. von Grafik-
symbolen,  die vorne auf den  Buchstabentasten abgebildet  sind.  Entweder die
linke oder  die  rechte  Umschalttaste muß  zusammen  mit  der  entsprechenden
Zeichentaste gedrückt werden. Die Umschaltung auf Großbuchstaben kann auch mit
der Feststeller-Taste (SHIFT LOCK) verriegelt werden.

[SEITE 3-2]

Abb. 3.1: Tastatur des C128
Abb. 3.1: Tastatur des C128D

[SEITE 3-3]

RETURN-Taste: Die  Return-Taste entspricht  der  Wagenrücklauftaste bei  elek-
trischen Schreibmaschine. Sie schließt die Eingabe einer Zeile ab.

RESTORE-Taste:  Die RESTORE-Taste dient zusammen  mit der RUN/STOP-Taste dazu,
den Rechner auf  seine  Standardparameter (dunkelgrauer Bildschirm   mit hell-
grünem Rand (C128-Modus) bzw.   blauer Bildschirm (C64-Modus)  sowie Großbuch-
staben/Grafikzeichen-Tastaturmodes) zurückzusetzen.

CONTROL-Taste:  Die CONTROL-Taste  oberhalb der RUN/STOP-Taste  dient zum Ein-
geben  spezieller Zeichen  sowie zum    Auslösen  von besonderen   akustischen
Signalen, Bildschirm- oder Systemfunktionen.  Auch hier wird die CONTROL-Taste
niedergehalten und eine weitere Taste gedrückt.   Eine häufig verwendete Funk-
tion der CONTROL-Taste ist die Einstellung einer Farbe. Zu diesem Zweck werden
die Control-Taste und eine der Zifferntasten  in der oberen Reihe des Schreib-
maschinen-Tastenfeldes gedrückt.   Auf der Frontseite  dieser  Tasten sind die
jeweiligen Farben (Zeichenfarbe im Textmodus) vermerkt.

RUN/STOP-Taste:  Drücken dieser Taste ohne  SHIFT-Taste unterbricht die augen-
blicklich vom Rechner ausgeführte BASIC-Anweisung und setzt ihn in den Direkt-
modus.  Zusammen mit der SHIFT-Taste  wird das  erste auf Kassette (C64-Modus)
oder Diskette (C128-Modus) befindliche Protramm geladen und gestartet.

C= (Commodore)-Taste: Diese Sondertaste hat zwei Funktionen:
1. Zusammen mit der SHIFT-Taste kann mit dieser Taste zwischen den beiden
   bereits erwähnten Tastatur-Modi hin- und hergeschaltet werden.
2. Zusammen mit den Zifferntasten in der oberen Reihe der Schreibmaschinen-
   tastatur kann eine Farbe aus einem zweiten Satz von acht Farben
   ausgewählt werden.
3. Im C128-Modus können bei eingeschalteter DIN-Tastatur Grafikzeiche
   eingegeben werden (s. Anhang D).

CLR/HOME-Taste: Drücken  der  HOME-Taste setzt den  Cursor  in die linke obere
Ecke des Bildschirms.  Wird  gleichzeitig die  SHIFT-Taste  niedergehalten, so
wird zusätzlich der Bildschirm gelöscht.

INST/DEL-Taste: Ohne  gleichzeitiges Drücken der  SHIFT-Taste wird das Zeichen
links neben dem Cursor gelöscht.   Alle Zeichen rechts vom gelöschten  Zeichen
werden,  falls vorhanden, um   eine Stelle nach  links  versetzt.  Bei gleich-
zeitigem Drücken der SHIFT-Taste  wird an der Cursor-Position  eine Leerstelle
eingefügt (Einfügemodus). Alle Zeichen  rechts davon, falls vorhanden, um eine
Stelle nach rechts versetzt. Bei diesem Einfügemodus wird außerdem die direkte
Wirkung  der Cursor-Steuertasten aufgehoben und  stattdessen ihr Steuercode in
Form eines inversen Zeichens auf dem Bildschirm angezeigt.

[SEITE 3-4]^

CRSR-Taste: Mit SHIFT-Taste wird  der Cursor in  dieselbe Spalte der  darüber-
liegenden Zeile gesetzt. In der obersten Zeile des Bildschirms hat diese Taste
keine Funktion.   Ohne  SHIFT-Taste  wird der  Cursor  in  dieselbe Spalte der
darunterliegenden Zeile   gesetzt.  In  der untersten Zeile   des  Bildschirms
bewirkt diese Taste ein Aufrollen des Bildschirms um eine Zeile.

CRSR-Taste:  Ohne SHIFT-Taste wird der  Cursor  um eine  Stelle nach rechts in
derselben  Bildschirmzeile gesetzt. Steht er vorher  am Zeilenende, so wird er
auf den Anfang der folgenden Zeile  gesetzt.  In der  rechten unteren Ecke des
Bildschirms führt diese  Taste zum Aufrollen  des  ganzen Bildschirms  um eine
Zeile. Mit der SHIFT-Taste wird der Cursor  um eine Stelle  nach links in der-
selben Bildschirmzeile versetzt.  Steht er vorher am  Zeilenanfang, so wird er
ans  Ende der  vorhergehenden Zeile  gesetzt.  In  der  linken oberen Ecke des
Bildschirms hat diese Taste keine Funktion.

Funktionstasten: Den acht Funktionstasten f1 bis f8, die  in einem Block ober-
halb der separaten Zehnertastatur angeordnet sind, sind im C128-Modus bestimm-
te Zeichenfolgen (häufig benötigte BASIC-Befehle und -Anweisungen) zugeordnet,
die  beim Drücken der  jeweiligen Taste auf   dem Bildschirm angezeigt werden.
Die  Belegung  dieser Tasten kann   vom Anwender jedoch   jederzeit für eigene
Zwecke geändert  werden  (s. Kapitel 4.1,  KEY-Anweisung  in Kapitel 4.6 sowie
Anhang G).


3.2 EINGEBEN VON PROGRAMMZEILEN
-------------------------------

Der BASIC-Interpreter  faßt  jede Textzeile, die mit   einer Zahl beginnt, als
Programmzeile auf, wobei die Zahl die Zeilennummer darstellt.

Eine BASIC-Programmzeile beginnt also  immer  mit einer  Zahl, wird  durch die
Return-Taste  beendet  und  darf  maximal 160 Zeichen  einschließlich  des der
RETURN-Taste zugeordneten   Zeichencodes enthalten.  Werden  mehr Zeichen ein-
gegeben, so werden diese  beim Drücken der RETURN-Taste  abgeschnitten, obwohl
sie durch die Eingabe noch auf dem Bildschirm stehen.

[SEITE 3-5]

Alle BASIC-Schlüsselwörter und  -Variablennamen müssen  bei aktiviertem Klein-
buchstaben/Großbuchstaben-Tastaturmodus    grundsätzlich   in  Kleinbuchstaben
eingegeben werden.

Wird  bei der Eingabe einer  Programmzeile  das Fragezeichen (?) als Abkürzung
für die PRINT-Anweisung  (s.  dort  in Kapitel 3)   verwendet, so wandelt  der
Interpreter  dies beim LIST-Befehl in das  Schlüsselwort PRINT um, wodurch die
Zeile ggf. länger  als 80 Zeichen  wird. In einem solchen  Fall darf die Zeile
länger als 80 Zeichen sein.

Wird eine Programmzeile mit einer Zeilennummer eingegeben, die kleiner ist als
die bis dahin  eingegebene größte Zeilennummer,  so fügt der Interpreter diese
Zeile an der richtigen Stelle ins  bereits eingegebene Programm ein. Programm-
zeilen  brauchen also  nicht  in der  Reihenfolge  aufsteigender Zeilennummern
eingegeben zu werden.

Wird eine Programmzeile mit einer  Zeilennummer eingegeben, unter der  bereits
eine andere Programmzeile existiert, so wird die  alte von der neuen Programm-
zeile überschrieben.

Hinzufügen  einer   Programmzeile zu  einem Programm,   das  den Hauptspeicher
bereits restlos füllt, führt zu der Fehlermeldung

,--------------------------------------------.
|  OUT OF MEMORY ERROR                       | (Hauptspeicher
`--------------------------------------------'  nicht ausreichend)

wobei die Zeile nicht mehr hinzugefügt wird.

Bei der Eingabe von Programmzeilen erfolgt keine Syntax-Prüfung. Erst wenn die
Zeile vom Interpreter ausgeführt wird, wird die Syntax überprüft und ggf. eine
Fehlermeldung (s. Kapitel 8.1) angezeigt.

Bei  Eingabe  einer ungeraden  Anzahl   von  Anführungszeichen  (") wird   der
Anführungs-Modus eingeschaltet,  bei dem  wie beim Einfügungsmodus  (s.  INST-
Taste in Kapitel 3.1) der Code  einer ggfs. dann gedrückten Cursor-Steuertaste
als inverses  Zeichen auf  dem Bildschirm dargestellt  wird.   Auf diese Weise
können  die  Cursor-Steuerfunktionen mit  Hilfe   von Steuerzeichenketten   in
Verbindung mit der PRINT-Anweisung programmiert werden.

[SEITE 3-6]

3.3 ERSETZEN ODER ÄNDERN VON EXISTIERENDEN PROGRAMMZEILEN
---------------------------------------------------------

Wie bereits  in   Kapitel  3.2  erwähnt, werden   existierende  Programmzeilen
ersetzt, indem eine neue Programmzeile mit der Zeilennummer der zu ersetzenden
Zeile eingegeben wird.   Dabei kann die   neue Programmzeile auch kürzer  oder
länger als die zu ersetzende Zeile sein.

Eine Programmzeile  wird gelöscht, indem  nur die Zeilennummer  eingegeben und
dann die  RETURN-Taste gedrückt wird. Existiert die  zu löschende Zeile nicht,
so wird die Eingabe ohne Anzeigen einer Fehlermeldung ignoriert.

Das ganze im Arbeitsspeicher  befindliche  BASIC-Programm kann mit dem  Befehl
NEW (s. dort in Kapitel 5.2) gelöscht werden.


3.3.1 ÄNDERN VON ZEILEN MIT DEM BILDSCHIRMEDITOR
------------------------------------------------

Jede auf dem Bildschirm sichtbare Zeile kann  mit Hilfe des Bildschirmeditors,
der  immer dann aktiv ist, wenn  BASIC sich  in der Befehlsebene (Direktmodus)
befindet oder ein Programm auf eine Tastatureingabe wartet, geändert werden.

Dazu wird der Cursor (Positionsanzeiger) mit Hilfe der Cursor-Steuertasten (s.
Kapitel 3.1) auf die  gewünschte Position in der  zu ändernden  Zeile gesetzt,
und dann wird die Änderung - ggf. auch  unter Verwendung der INST/DEL- Taste -
ausgefürht. Durch Drücken der RETURN-Taste  wird die Änderung beendet, und die
gesamte geänderte Programmzeile wird ins Programm eingefügt.

Sollen auf dem Bildschirm  nicht sichtbare Programmzeilen geändert  werden, so
werden diese zunächst  mit dem LIST-Befehl (s.   dort in Kapitel  5.2) auf dem
Bildschirm angezeigt und dann wie oben beschrieben geändert.

Die RETURN-Taste, die die Änderung einer Zeile beendet,  kann bei jeder belie-
bigen Cursor-Postition  innerhalb  der geänderten Zeile  gedrückt  werden. Der
Interpreter übernimmt in jedem Fall die gesamte Programmzeile ins Programm.


3.3.2 ÄNDERN VON ZEILEN MIT SYNTAX-FEHLERN
------------------------------------------

Erkennt der Interpreter während der Programmausführung einen Syntax-Fehler, so
meldet  er dies unter Angabe der  Zeilennummer, falls das  Programm keine pro-
grammierte Fehlerverarbeitung enthält. Die fehlerhafte Zeile muß mit LIST oder
durch Drücken  der HELP-Taste angezeigt   und dann mit den oben  beschriebenen
Techniken  geändert werden.  Drücken  der RETURN-Taste speichert die geänderte
Zeile ins Programm, das dann erneut gestartet werden kann.

[SEITE 3-7]^

Bei einer solchen Programmänderung  müssen folgende Maßnahmen des Interpreters
berücksichtigt werden:

  * Alle Variablen und Felder werden gelöscht (Wert oder Länge Null).
  * Das Programm kann NICHT mit dem CONT-Befehl (s. dort in Kapitel 5.2)
    fortgesetzt werden.

Sollen vor der Änderung die Inhalte bestimmter Variablen oder Felder überprüft
werden,  muß der Interpreter durch DrÜcken  der Taste RUN/STOP in die Befehls-
ebene (Direktmodus) gesetzt werden. Dann  kann die Überprüfung durch  Anzeigen
der  betreffenden Variablen  oder Felder  mit  PRINT erfolgen, die Zeile,  die
Zeile geändert und das Programm neu gestartet werden.


3.4 SPEICHERN VON BASIC-PROGRAMMEN
----------------------------------

Ein neu eingegebenes oder ein geändertes Programm muß  für den Erhalt auf Kas-
sette oder Diskette gespeichert werden. Diese Maßnahme wird mit dem SAVE- oder
dem DSAVE-Befehl durchgeführt. Beide Befehle sind  in den Kapiteln 5.2 und 4.6
so ausführlich beschrieben, daß hier eine weitere Erläuterung entfallen kann.


3.5 LADEN UND STARTEN VON BASIC-PROGRAMMEN
------------------------------------------

Um ein auf Kassette   oder Diskette gespeichertes  BASIC-Programm auszuführen,
muß dieses zunächst  in den Hauptspeicher  des Rechners geladen werden.  Diese
geschieht  im Direktmodus des Rechners mit  den Befehlen LOAD, DLOAD oder RUN.
Nach dem  Laden mit  LOAD oder DLOAD  wird  das Programm  mit  dem Befehl  RUN
gestartet. Die Befehle LOAD, DLOAD und RUN  sind in den  Kapiteln 5.2 bzw. 4.6
so  ausführlich   beschrieben, daß  hier   auf  eine weitergehende Erläuterung
verzichtet werden kann.

[SEITE 4-1]

KAPITEL 4 *** C128-Modus

Der C128 meldet sich in diesem Modus, wenn  der Rechner eingeschaltet oder der
Reset-Knopf gedrückt wird.

In diesem Modus stehen dem Anwender 128KBytes Hauptspeicher, wahlweise eine 40
oder 80 Zeichen  breite  Bildschirmdarstellung   mit 25  Zeilen,  ein   BASIC-
Interpreter mit gegenüber dem  C64-Modus (s.  Kapitel 5) erheblich erweitertem
Befehlsumfang   (BASIC   7.0), wahlweise  eine      deutsche DIN-  oder   eine
amerikanische ASCII-Tastatur mit  speziellen  Bedienungs- und programmierbaren
Funktionstasten   sowie ein    erheblich   schnellerer  Diskettenzugriff   zur
Verfügung.

4.1 Erweiterte Tastatur-Funktionen im C128-Modus

Die in Kapitel 3 beschriebene und abgebildete Tastatur  enthält eine Reihe von
Tasten, denen nur im C128-Modus eine Funktion zugeordnet ist.

Zehnertastatur:  Rechts neben  der  Schreibmaschinentastatur befindet sich ein
Block  mit  den  zehn Zifferntasten,    dem Dezimalpunkt,  der Plus- und   der
Minus-Taste sowie einer Eingabetaste.  Die Tasten  haben dieselbe Funktion wie
die entsprechenden   Tasten   der Schreibmaschinentastatur.    Die ENTER-Taste
entspricht dabei der RETURN-Taste.  Dieser Tastenblock erleichtert die Eingabe
großer  Zahlenmengen  und erlaubt  mit   Hilfe eines geeigneten  Programms die
Simulation eines Taschenrechners.

Funktionstasten:  Oberhalb der Zehnertastatur  befinden sich 4 Funktionstasten
für  insgesamt 8 verschiedene  programmierbare Funktionen.  Die Funktionen f1,
f3, f5 und f7 werden durch Drücken der entsprechenden Taste und die Funktionen
f2, f4, f6 und f8  durch zusätzliches Niederhalten der SHIFT-Taste ausgeführt.
Die  Funktionen  bestehen   in simulierten  Tastatureingaben   und  ggfs.  dem
Ausführen ganzer Befehle oder Befehlsketten.

Nach dem Einschalten des Rechners sind  den 8 Funktionstasten folgende Befehle
zugeordnet:

f1 GRAPHIC                 f2 DLOAD"
f3 DIRECTORY <RETURN>      f4 SCNCLR <RETURN>
f5 DSAVE"                  f6 RUN <RETURN>
f7 LIST <RETURN>           f8 MONITOR <RETURN>

[SEITE 4-2]

Wird f1 gedrückt,  so wird das Befehlswort  GRAPHIC bei  der aktuellen Cursor-
Position  angezeigt, und es brauchen  nur  noch die gewünschten Parameter  (s.
dort in Kapitel 4.6) eingegeben zu werden.

Wird f2 (f1  zusammen mit SHIFT) gedrückt,  so wird das Befehlswort DLOAD" bei
der aktuellen Cursorposition angezeigt, und es braucht nur noch der gewünschte
Dateiname mit abschließendem Anführungszeichen eingegeben zu werden.

Wird f3 gedrückt, so wird der Befehl DIRECTORY  ausgeführt, der das Disketten-
verzeichnis der Diskette in einem angeschlossenen Floppy-Disk-Laufwerk mit der
Geräteadresse 8 angezeigt.

Wird f4 (f3 zusammen mit SHIFT) gedrückt, so wird  der aktuelle Bildschirm mit
dem Befehl SCNCLR gelöscht.

Wird f5  gedrückt, so wird das   Befehlswort DSAVE" bei der  aktuellen Cursor-
position  angezeigt,  und es  braucht nur noch    der gewünschte Dateiname mit
abschließendem Anführungszeichen eingegeben zu werden.

Wird f6 (f5 zusammen mit SHIFT) gedrückt,  so  wird der Befehl RUN ausgeführt,
also das gerade im Hauptspeicher befindliche BASIC-Programm gestartet.

Wird f7 gedrückt,  so  wird der Befehl  LIST  ausgeführt, also das gerade   im
Hauptspeicher befindliche BASIC-Programm auf dem Bildschirm gelistet.

Wird f8 (f7   zusammen mit  SHIFT)  gedrückt,  so  wird der  Maschinensprache-
monitor mit dem Befehl MONITOR aufgerufen.

Die  voreingestelle  Belegung der    Funktionstasten kann  jederzeit   mit dem
KEY-Befehl  (s. dort  in Kapitel 4.6)  für jede  beliebige Taste geändert oder
einfach nur angezeigt werden.

Cursor-Steuertasten:  Die vier Tasten mit   den Pfeil-Symbolen links neben den
Funktionstasten dienen der  einfachen Steuerung der Cursor-Bewegungen  auf dem
Bildschirm.  Anders als  beim C64-Modus gibt  es hier für jede Cursor-Richtung
eine separate Taste.  Die  Richtung wird durch  den  Pfeil auf  der jeweiligen
Taste angegeben.

HOME-Taste: Wird  die HOME-Taste zweimal  aufeinanderfolgend gedrückt, so wird
ein ggfs. definiertes  Bildschirmfenster (s.a. WINDOW-Anweisung in Kapitel 4.6
sowie die Tastensequenzen ESC T und ESC B in  diesem Abschnitt) aufgehoben und
auf den gesamten Bildschirm zurückgesetzt.

[SEITE 4-3]^

NO SCROLL-Taste: Wenn während der Anzeige von  Daten auf dem Bildschirm dieser
nach oben gerollt wird, so kann dies durch Drücken der NO SCROLL-Taste, die in
dem  Tastenblock links neben   den Cursor-Steuertasten ganz  rechts angeordnet
ist,  verhindert werden.    Die   Funktion dieser   Taste  ähnelt  der   SHIFT
LOCK-Taste.    Einmaliges  Drücken  verriegelt die  Funktion (Bildschirmrollen
unterdrückt).  Nochmaliges Drücken  entriegelt die  Funktion (Bildschirmrollen
erlaubt).

40/80   DISPLAY-Taste:    Mit Hilfe  dieser  Taste  kann   zwischen den beiden
Anzeigebreiten des C128-Modus  hin-  und hergeschaltet werden  (gedrückt:  80-
Zeichen-Anzeige).   Voraussetzung  ist   jedoch,  daß  ein  80-Zeichen-Monitor
(z.B. Commodore 1902) angeschlossen ist. Auch diese Taste verriegelt sich beim
Drücken automatisch und wird   bei erneutem Drücken  wieder freigegeben.   Die
Umschaltung muß jedoch vor  dem Einschalten oder Rücksetzen (Reset-Taste)  des
Computers erfolgen.

LINE FEED-Taste: Drücken dieser Taste setzt den Cursor auf dieselbe Spalte der
folgenden Zeile.

HELP-Taste: Findet der Interpreter während der Abarbeitung einer Programmzeile
einen Fehler,  so  meldet er dies  mit einer  Fehleranzeige  (s. Kapitel 8.1).
Wird nun die HELP-Taste gedrückt, so  wird die fehlerhafte Zeile angezeigt und
die Zeile wird  ab  der fehlerhaften Stelle  je nach  Bildschirmmodus entweder
invers   (40-Zeichen-Bildschirm)  oder unterstrichen   (80-Zeichen-Bildschirm)
dargestellt. Auf diese Weise wird die Programmkorrektur sehr erleichtert.

ASCII/DIN-Taste: Dies ist eine  selbstverriegelnde Taste, mit der zwischen der
deutschen DIN- und der amerikanischen ASCII-Tastatur umgeschaltet werden kann.
Bei gedrückter (und  damit  verriegelter) Taste ist die  deutsche DIN-Tastatur
aktiviert.

ALT-Taste:   Mit   dieser   Taste   kann  eine  alternative,  selbstdefinierte
Tastaturtabelle gewählt werden, in der fast allen Tasten der Schreibmaschinen-
tastatur ein anderer Code  zugeordnet werden kann.   Dies ist z.B.  dann hilf-
reich, wenn Texte  in einer fremden  Sprache  geschrieben werden  müssen.  Die
Definition  solcher Tabellen erfolgt durch Speichern  von bestimmten Werten in
besonderen Speicherplätzen (s. Anhang J).

[SEITE 4-4]

TAB-Taste: Drücken  der TAB-Taste  zusammen  mit der SHIFT-Taste setzt  an der
aktuellen Cursor-Position  einen Tabulator-Stop, der   durch Drücken der  TAB-
Taste   angesprungen werden kann.   Voreingestellt  sind Tabulatorstops alle 8
Spalten.

ESC-Taste:  Die ESC-Taste erlaubt zusammen  mit  den Buchstabentasten  A bis Z
eine Reihe  von Sonderfunktionen für die  Tastatur und den Bildschirm,  die im
folgenden  beschrieben werden.   Zur Ausführung der  gewünschten Funktion wird
zuerst die ESC-Taste  gedrückt und wieder  losgelassen.  Anschließend wird die
gewünschte Buchstabentaste gedrückt:

Taste  Funktion

A      Der automatische Einfügemodus wird eingeschaltet. Es werden solange
       Zeichen eingefügt, bis ESC-C gedrückt wird.

B      Die aktuelle Cursor-Position definiert die untere rechte Ecke eines
       Bildschirmfensters.

C      Der automatische Einfügemodus wird ausgeschaltet.

D      Die aktuelle Bildschirmzeile wird gelöscht und der Bildschirm
       unterhalb dieser Zeile wird um eine Zeile nach oben gerollt.

E      Setzt den Cursor-Modus von Blinken auf Konstantanzeige.

F      Setzt den Cursor-Modus von Konstantanzeige auf Blinken.

G      Erlaubt akustisches Klingeln durch CTRL-G.

H      Verbietet akustisches Klingeln durch CTRL-G.

I      Fügt oberhalb der aktuellen Zeile eine neue Zeile auf dem Bild-
       schirm ein.

J      Setzt den Cursor an den Anfang der aktuellen Zeile.

K      Setzt den Cursor hinter das letzte Zeichen in der aktuellen Zeile.

L      Erlaubt Bildschirm-Aufrollen.

M      Verbietet Bildschirm-Aufrollen

[SEITE 4-5]

N      Schaltet den Bildschirm von Invers-Darstellung auf Normal-
       Darstellung (nur 80-Zeichen-Schirm).

O      Bewirkt ein Abschalten aller Modi (Blinken, Unterstreichen, Revers).

P      Die aktuelle Zeile wird vom Anfang bis zur Cursor-Position
       gelöscht.

Q      Die aktuelle Zeile wird von der Cursor-Position bis zum Zeilenende
       gelöscht.

R      Schaltet den Bildschirm von Normal-Darstellung auf Invers-Darstellung
       (nur 80-Zeichen-Schirm).

S      Schaltet Blockdarstellung für den Cursor ein.

T      Die aktuelle Cursor-Position definiert die obere linke Ecke eines
       Bildschirmfensters.

U      Schaltet Strichdarstellung für den Cursor ein (nur 80-Zeichen-
       Bildschirm)

V      Rollt den Bildschirm um eine Zeile nach oben.

W      Rollt den Bildschirm um eine Zeile nach unten.

X      Schaltet von einem 40-Zeichen-Monitor auf einen 80-Zeichen-Monitor
       um und umgekehrt.

Y      Schaltet voreingestelle Tabulatorstops (alle 8 Spalten) ein.

Z      Löscht alle eingestellen Tabulatorstops.

@      Löscht den Bildschirm ab der aktuellen Cursor-Position.

CTRL-Taste: Zusätzlich zu den Funktionen, die mit speziellen CTRL-Sequenzen im
C64-Modus ausgelöst werden können (z.B. Farbwahl), erlaubt der C128-Modus eine
Reihe von weiteren Funktionen, die  durch  Drücken einer der folgenden  Tasten
bei niedergehaltener CTRL-Taste ausgelöst werden können:

[SEITE 4-6]^

Taste  CHR$-Code  Funktion

B      2          Schaltet den Unterstreichungsmodus für alle angezeigten
                  Zeichen ein (nur 80-Zeichen-Bildschirm)

G      7          Löst ein akustisches Klingelzeichen aus.

I      9          Löst einen Tabulatorsprung auf den nächsten Tabulator-
                  stop aus.

J      10         Führt einen Zeilenvorschub aus.

K      11         Verbietet Umschaltung zwischen Klein/Groß- und Groß/Grafik-
                  Zeichensatz.

L      12         Erlaubt Umschaltung zwischen Klein/Groß- und Groß/Grafik-
                  Zeichensatz.

O      15         Schaltet Blinkdarstellung für alle angezeigten Zeichen ein
                  (nur 80-Zeichen Bildschirm).

X      24         Setzt oder löscht einen Tabulator-Stop.

[      27         ESC-Code.

[SEITE 4-7]

+----------------------------------------------------------------------------+
| ACHTUNG                                                                    |
| Die ESC- und  CTRL- Funktionen können  auch  mit Hilfe der PRINT-Anweisung |
| in einem Programm ausgeführt werden. Z.B.:                                 |
+----------------------------------------------------------------------------+

PRINT CHR$(27)+"M"  verbietet Bildschirmrollen.

PRINT CHR$(7)       löst ein akustisches Klingelzeichen aus.

Bei aktivierter DIN-Tastatur gilt für  die Verwendung der Tasten zusammen  mit
der CTRL-Taste die ASCII-Tastaturbelegung.


Besonderheiten der DIN/ASCII-Tastatur

Anwender, die eine rein   amerikanische Tastatur einsetzen wollen,  können mit
dem Befehl

POKE 2757,129  [nur im 80-Zeichen-Modus]

die Unterstützung  der Tastaturumschaltung  durch das Betriebssystem ausschal-
ten. Diese Maßnahme sollte  jedoch  nur bei vorher  aktivierter ASCII-Tastatur
(freigegebene ASCII/DIN-Taste) ergriffen werden und kann nur durch Drücken des
Reset-Knopfes wieder aufgehoben werden.

Eine  weitere Besonderheit der DIN-Tastatur  stellt  die Taste  mit den beiden
Accents in  der obersten  Reihe  der Schriebmaschinentastatur dar. Wird  diese
Taste  gedrückt,  so wird der  Accent  angezeigt,  der Cursor bleibt  aber bei
dieser Position stehen. Wird dann  eine Buchstabentaste gedrückt, so prüft das
Tastaturprogramm des Betriebssystems, ob diese Zeichenkombination erlaubt ist.
Wenn  nicht, wird nur  der  Buchstabe, andernfalls der  akzentuierte Buchstabe
angezeigt und der Cursor wird um eine Position nach rechts gesetzt.

Damit Sie sich  bei jeder  aktivierten Tastatur  auch zurechtfinden,  sind auf
einigen Tasten, die bei den beiden wählbaren Tastaturen unterschiedlich belegt
sind, sämtliche Belegungen vermerkt.

[SEITE 4-8]

4.2 Erweiterte Bildschirm-Funktionen im C128-Modus

Im C128-Modus kann der Anwender zwischen  einer 40- und 80-Zeichen-Bildschirm-
anzeige wählen. Beide Anzeigemodi können in einem Programm verwendet werden.

Die 40-Zeichen-Anzeige  ist auch  die,   die  für den  C64-Modus gültig   ist.
Außerdem dient   sie  zur   Darstellung   all  der   vielfältigen   grafischen
Möglichkeiten, die der C128-Modus bietet (s.a. Kapitel 4.7 ff.).

Die 80-Zeichen-Anzeige  erlaubt die  Ausführung professioneller  Programme wie
Textverarbeitung, Datenbankverwaltung usw.    Hochauflösende  Grafik ist   bei
dieser Darstellung nur in  Verbindung mit PEEK-  und POKE-Vefehlen oder  einem
Maschinenspracheprogramm  möglich. Die Verwendung der grafischen Sonderzeichen
aus  dem Commodore-Zeichensatz sowie   der Hintergrund-  und Vordergrundfarben
sind ebenfalls möglich.

40/80  DISPLAY-Taste:  Mit  dieser Taste   kann   zwischen  der  40- und   der
80-Zeichen-Anzeige umgeschaltet werden. Die Taste  kann zu jeder Zeit gedrückt
werden. Die Umschaltung erfolgt jedoch erst dann, wenn

* der Rechner aus- und wieder eingeschaltet wird;

* die Reset-Taste neben dem Netzschalter gedrückt wird;

* die RUN/STOP-Taste mit der RESTORE-Taste gedrückt wird.

Diese Taste verriegelt sich wie die  SHIFT LOCK-Taste beim Drücken selbsttätig
und wird durch erneutes Drücken  wieder entriegelt.  Im gedrückten Zustand ist
die 80-Zeichen-, andernfalls die 40-Zeichen-Anzeige eingeschaltet.

VIDEO-ANSCHLÜSSE UND MONITORE: Wie bereits  in der Einführung erwähnt, hat der
C128-Computer auf  der Rückseite zwei unterschiedliche Video-Anschlüsse (VIDEO
und RGBI). An  den Anschluß VIDEO  wird ein 40-Zeichen-Monitor (z.B. Commodore
1701) angeschlossen.

An  den  Anschluß   RGBI  wird ein  80-Zeichen-Monitor   angeschlossen  (RGBI-
Monitor).

Beide Anschlüsse werden benötigt,   wenn ein Doppel-Monitor wie  der Commodore
1901 angeschlossen  wird.   Dieser Monitor  kann sowohl  im  40-  als  auch im
80-Zeichen-Modus betrieben  werden und  erlaubt die  programmierte Umschaltung
zwischen beiden Modi.

[SEITE 4-9]^

Werden zwei verschiedene  Monitore angeschlossen,  so können sowohl  grafische
als auch Textausgaben gleichzeitig dargestellt werden.

BILDSCHIRMUMSCHALTUNG: Einer    der  großen Vorteile  des  C128-Modus  ist die
Möglichkeit, mit bis zu  3  voneinander unabhängigen Bildschirmen zu  arbeiten
(80-Zeichen-Bildschirm  sowie  geteilter   Bildschirm   für    grafische   und
Textwiedergabe). Es kann auf einem  Bildschirm ausgegeben werden, ohne die auf
den beiden anderen  Schirmen  angezeigten  Daten  zu verändern,  und  es  kann
zwischen   allen drei Bildschirmen    ohne Datenverlust hin- und hergeschaltet
werden. Außerdem kann zwischen der 40- und der 80-Zeichen-Anzeige umgeschaltet
werden, ohne daß der Bildschirm  vorher gelöscht werden muß. Diese Umschaltung
wird durch aufeinanderfolgendes Drücken der Tasten ESC und  X oder durch PRINT
CHR$(27)+"X" bewirkt.

Zur programmierten Bildschirmumschaltung dient  die GRAPHIC-Anweisung (s. dort
in Kapitel 4.6).  Mit  ihr lassen sich in  Programmen für den 80-Zeichen-Modus
grafische Darstellung auf dem 40-Zeichen-Bildschirm anzeigen.

Weitere Informationen siehe Kapitel 4.6 und 4.7 ff.

4.3 BASIC 7.0 im C128-Modus

Aufbauend auf dem Commodore-Standard-BASIC 2.0, das ausführlich im Kapitel 5.2
beschrieben  wird,  bietet  das   erweiterte   BASIC 7.0 dem  Anwender   viele
komfortable  Befehle,   Anweisungen,  Funktionen  und  Systemvariablen, um die
vielfältigen Möglichkeiten, die der C128 bietet, nutzen zu können.

Dieser Abschnitt  ist kein  Leitfaden  zum  Erlernen allgemeiner  Programmier-
techniken  oder der Programmiersprache  BASIC, sondern ein Nachschlagewerk für
mit   allgemeinen  Programmierkonzepten  vertraute   Anwender,  die  auf   den
nachfolgenden Seiten  alle wissenswerten Fakten  für die Erstellung effektiver
BASIC-Programme  finden. Anfängern wird die   Lektüre  der in der   Commodore-
Sachbuchreihe veröffentlichten BASIC-Kurse empfohlen.

Im C128-Modus kann der volle Befehlsumfang sowohl des BASIC 2.0 (s. Kapitel 5)
als auch des BASIC 7.0 verwendet werden, so daß hier auch  auf das Kapitel 5.2
verwiesen wird.

[SEITE 4-10]

Ehe   jedoch die einzelnen  Anweisungen  beschrieben  werden, hier noch einige
allgemeine Anmerkungen  zur   Struktur der  Programmiersprache  BASIC und  zur
Syntax der nachfolgenden Beschreibungen.

4.4 Struktur von BASIC

Der Sprachumfang des Commodore-BASIC gliedert sich in:

- Befehle
- Anweisungen
- Funktionen
- Variablen

BEFEHLE werden dazu benutzt, an Programmen etwas zu bearbeiten, sie zu listen,
zu ändern, zu löschen, zu speichern oder zu laden. Deshalb werden Befehle auch
meistens in der Befehlsebene (Direktmodus)  eingegeben.  Sie können aber  auch
Bestandteil eines Programms sein.

ANWEISUNGEN steuern  den Programmablauf. Sie  sind der eigentliche  Inhalt des
Programms, können aber auch im Direktmodus  eingegeben werden. Die Anweisungen
gliedern sich in 3 Gruppen:

* Ein-/Ausgabeanweisungen für den Datenverkehr zwischen dem Rech-
  ner einerseits sowie Tastatur, Bildschirm, Diskettenstation, Festplatte,
  Drucker oder Datenfernübertragungsschnittstelle andererseits.

* Deklarationsanweisungen für die Definition von Daten, benutzereigenen
  Funktionen, Speichersegmenten oder der Programmumgebung.

* Steueranweisungen zur Festlegung des Programmablaufes wie Schleifen,
  Sprünge, Unterprogramm- und Unterbrechungsaufrufe.

FUNKTIONEN liefern als Ergebnis bestimmte  Werte zur Weiterverarbeitung an das
Programm und gliedern sich in:

* Numerische Funktionen, die als Ergebnis ganzzahlige Werte oder Gleit-
  kommawerte übergeben;

* Zeichenkettenfunktionen, die als Ergebnis eine Zeichenkette übergeben.

[SEITE 4-11]

VARIABLEN   der BASIC-Sprache dürfen   nicht  mit  den vom  Programmierer frei
definierbaren Variablen eines Programms verwechselt werden. Die hier gemeinten
System-Variablen  haben  feste,  von BASIC  vorgegebene  Namen und Funktionen.
Ihnen wird  beim Aufruf  vom Interpreter ein   Wert zugewiesen, der  bestimmte
Funktionszustaende des  Interpreters oder Rechnersystems  zu einem  bestimmten
Zeitpunkt beschreibt.  Es gibt numerische und Zeichenketten-Systemvariablen.

4.5 Struktur und Syntax der Beschreibungen

Im Kapitel 4.6 werden alle Befehle, Anweisungen, Funktionen und Variablen, die
der  BASIC-Interpreter  kennt,    detailliert und   an   Hand  von  Beispielen
beschrieben.  Die einzelnen  Beschreibungen  sind alphabetisch nach  den Namen
geordnet und nach dem folgenden Schema gegliedert:

Format:         Hier ist die exakte Schreibweise für einen Befehl, eine
                Anweisung, Funktion oder Variable angegeben. Dabei gelten
                die folgenden Syntax-Regeln:

                1. Alle Wörter in Großbuchstaben sind BASIC-Schlüsselwörter,
                   deren Schreibweise wie angegeben verbindlich ist.
                2. Alle Angaben in kursiver Groß- und Kleinschrift stellen
                   Parameter dar, die vom Anwender eingesetzt werden
                   müssen. {Anm. d. E-Texters: Dies gilt natürlich nicht
                   für diese ASCII-Version, da keine Kursivschrift vorhanden
                   ist}
                3. Angaben in eckigen Klammern ([]) sind wahlfrei.
                4. Eine Folge von Punkten (...) hinter einer Angabe
                   bedeutet, daß diese Angabe, falls erforderlich,
                   mehrmals spezifiziert werden kann.
                5. Alle angegebenen Sonderzeichen außer den eckigen
                   Klammern, also , ; - = ( ) ' " , müssen da, wo sie
                   stehen, auch angegeben werden.

[SEITE 4-12]

                6. Bei den Parameterangaben haben die dort verwendeten
                   Abkürzungen folgende Bedeutung:

                   x,y,z      beliebige numerische Ausdrücke
                   i,j,k,m,n  beliebige ganzzahlige Ausdrücke
                   x$,y$      beliebige Zeichenkettenausdrücke
                   v,v$       numerische oder Zeichenkettenvariablen

Zweck:          Hier wird die Wirkung des jeweiligen Befehls oder der
                Anweisung, Funktion oder Variablen detailliert
                beschrieben, und die Parameter und ihre Definitionsbereiche
                werden erläutert.

Bemerkungen:    Besondere Eigenschaften der einzelnen Befehle, Anweisungen,
                Funktionen und Variablen werden hier erläutert.

Beispiel:       Die bei jeder Beschreibung angegebenen Beispiele zeigen,
                wie die einzelnen Befehle, Anweisungen, Funktionen und
                Variablen angewendet werden und weisen auf Besonderheiten
                hin.

4.6 Beschreibung der einzelnen Befehle, Anweisungen,
    Funktionen und Variablen

Zur Erleichterung des Auffindens eines bestimmten BASIC-Befehls oder
einer -Anweisung, -Funktion oder -Variablen sind die nachfolgenden
Beschreibungen nicht entsprechend der in Kapitel 4.4 beschriebenen
Sprachstruktur von BASIC gegliedert, sondern es sind alle Sprachelemente
zusammengefaßt und alphabetisch geordnet.

[SEITE 4-13]

APPEND-Anweisung

Format:       APPEND # log Filenr,Dateiname[,DLaufw]
                       [,UGeräteadr]

Zweck:        Öffnet eine existierende, sequentielle Datei vom Typ SEQ
              oder  USR   als  Ausgabedatei   und   positioniert   den
              Schreibzeiger   auf  das Dateiende, damit  weitere Daten
              angefügt werden können (s.a. Kapitel 6.6).

  log Filenr  Ein  ganzzahliger  Wert  zwischen  1 und  255,  der  der
              eröffneten  Datei als  Kennummer  zugeordnet wird.   Bei
              Werten   kleiner   als  128   wird   an   die  mit   der
              PRINT#-Anweisung  ausgegebenen Daten  ein Wagenrücklauf-
              code ausgegeben. Bei Werten über 127 wird zusätzlich ein
              Zeilenvorschubcode ausgegeben.

   Dateiname  Eine  Zeichenkettenkonstante  in Anführungsstrichen  (")
              oder  -variable von  maximal  16 Zeichen  Länge für  den
              Namen der zu eröffnenden Datei.

       Laufw  Ein ganzzahliger Wert von  0 oder 1.  Voreingestellt ist
              hier 0.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen   4  und  15  für  die
              Geräteadresse  der  angeschlossenen  Floppy-Disk.   Vor-
              eingestellt ist hier 8.

Bemerkungen:  Werden  für Dateiname, Laufwerk  und Geräteadr Variablen
              verwendet, so müssen diese in Klammer gesetzt werden.

Beispiel 1:   APPEND#2,"TEXT"

              Auf  der  Floppy-Disk mit der  Geräteadresse  8 wird die
              Datei  TEXT unter der  logischen File-Nummer 2 eröffnet,
              und der Schreibzeiger   wird   auf das Ende  der   Datei
              gestellt, so daß weitere Daten angefügt werden können.

Beispiel 2:   APPEND#3,(DA$),D(VAL(AL$))ONU9

              Der  Dateiname und  das   Laufwerk werden  als  Variable
              übergeben.

[SEITE 4-14]

AUTO-Befehl

Format:       AUTO [Schrittw]

Zweck:        Während der  Eingabe  von BASIC-Programmzeilen   wird am
              Zeilenanfang eine neue  Zeilennummer angezeigt,  wenn am
              Ende  der vorhergehenden Zeile die RETURN-Taste gedrückt
              wurde.

              Nach Eingabe  des Befehls  AUTO muß die  erste Programm-
              zeile  mit  Zeilennummer   eingegeben  werden.   Ab  der
              nächsten  Zeile  erfolgt  die Zeilennumerierung  automa-
              tisch.

Bemerkungen:  Schrittw gibt  die  Schrittweite  zwischen  den  Zeilen-
              nummern an.

              Wird  der AUTO-Befehl ohne  Schrittw  verwendet, so wird
              die automatische Zeilennumerierung wieder abgeschaltet.

Beispiele:    AUTO 10

              Es  werden  automatisch Zeilennummern mit einer Schritt-
              weite von 10 erzeugt.

              AUTO

              Die  automatische   Zeilennummernerzeugung   während der
              Programmeingabe wird abgeschaltet.

[SEITE 4-15]

BACKUP-Befehl

Format:       BACKUP D Quelle TO DZiel[,UGerät]

Zweck:        Dupliziert   eine    Diskette auf   einem   Floppy-Disk-
              Doppellaufwerk.

      Quelle  Ein Wert  von 0 oder 1  für das Laufwerk, in  dem die zu
              duplizierende Diskette eingelegt ist.

        Ziel  Ein  Wert von  1 oder  0 für  das Laufwerk,  in  dem die
              Diskette, auf die kopiert wird, eingelegt ist.

       Gerät  Ein ganzzahliger Wert zwischen  4 und 15 für die Geräte-
              adresse  des   angeschlossenen  Doppellaufwerkes.   Vor-
              eingestellt ist hier 8.

Bemerkungen:  Der BACKUP-Befehl ist nur bei einer Floppy-Disk mit zwei
              Laufwerken möglich.

              Das Duplikat ist ein exaktes Abbild der Quelldiskette.

              Der   BACKUP-Befehl    beinhaltet   den Befehl    HEADER
              (s. dort), mit dem die Diskette vor dem Dupliziervorgang
              formatiert wird.

              Vor  dem Beginn  des  Dupliziervorganges wird  durch die
              Anfrage

              ARE YOU SURE?

              vom  Anwender  eine  Bestätigung  (Antwort Y  für   YES)
              verlangt,  da  durch   BACKUP  ggfs.    vorher  auf  der
              Zieldiskette vorhandene Daten zerstört werden.

[SEITE 4-16]

Beispiel 1:   BACKUP D0 TO D1

              Duplizierung der Diskette in Laufwerk 0 auf die Diskette
              in Laufwerk 1.

Beispiel 2:   BACKUP D1 TO D0 ON U9

              Duplizierung von Laufwerk 1 auf Laufwerk  0 im Gerät mit
              der Adresse 9.

[SEITE 4-17]

BANK-Befehl

Format:       BANK n

Zweck:        Definiert eine 64-kByte-Speicherbank  für   nachfolgende
              PEEK-, POKE-, SYS- oder WAIT-Anweisungen. n muß zwischen
              0 und 15 liegen.

Bemerkungen:  Der  Speicher  des C128  ist in  15 Speicherbänke  zu je
              64 kByte aufgeteilt.  Dabei   sind jedoch  nur die Bänke
              Nr. 0,  1 und 15  vorhanden (s. a. Speicherverwaltung in
              Anhang B).

Beispiel:     10 REM WERT 20 BEI ADRESSE 1024 IN BANK
              15 REM 1 SPEICHERN
              20 BANK1:POKE1024,20

[SEITE 4-18]

BEGIN- und BEND-Anweisungen

Format:       IF... THEN BEGIN
              .
              . Anweisungen
              .
              BEND

Zweck:        BEGIN und BEND schließen einen beliebig langen Block von
              BASIC-Anweisungen  ein,   der auch  über  mehrere Zeilen
              gehen darf.

Bemerkungen:  BEGIN  wird immer  in  Verbindung  mit  der IF-Anweisung
              (s. dort) verwendet.

              Der  Vorteil  gegenüber der  IF  THEN ELSE-Anweisung ist
              der, daß  die  Anweisungen nach   THEN  nicht auf   eine
              Programmzeile beschränkt zu sein brauchen.

              Alle  anderen Regeln  für die IF...THEN...ELSE-Anweisung
              bleiben jedoch gültig (s. Beispiel).

Beispiel 1:   100 IF X=1 THEN BEGIN:A=5
              110 B=6 : C=7
              120 PRINT A+B+C : BEND : PRINT"AHA!"
              130 ...

              AHA!   wird nur  gedruckt,  wenn X=1  logisch wahr  ist:
              andernfalls  würde  das  Programm  mit Zeile  130  fort-
              gesetzt.

Beispiel 2:   10 INPUT"ZAHL=";Z
              20 IF Z>0 THEN BEGIN
              30 PRINT"DIE ZAHL IST > 0"
              40 BEND : ELSE GOTO 60
              50 END
              60 PRINT"DIE ZAHL IST <= 0"
              70 GOTO 10

              Das Programm   wird  in Zeile  50  beendet,   wenn  eine
              positive Zahl eingegeben wurde, andernfalls mit Zeile 10
              wiederholt.

[SEITE 4-19]

BLOAD-Befehl

Format:       BLOAD Dateiname[,DLaufwerk][,UGerät]
                    [,ON BBank][,PAdr]

Zweck:        Es  wird eine  Datei  mit binär  codiertem Inhalt  (z.B.
              Maschinensprache,   Binärdaten)  in   den  Hauptspeicher
              geladen (s.a. Kapitel 6.4).

   Dateiname  Eine  Zeichenkettenkonstante  in  Anführungszeichen  (")
              oder -variable  einer Länge von  bis zu 16  Zeichen, die
              den Namen der zu ladenden Binärdatei angibt.

    Laufwerk  Ein Wert von 0 oder  1 für das Laufwerk, von dem geladen
              werden soll. Voreingestellt ist hier 0.

       Gerät  Ein ganzzahliger Wert zwischen  4 und 15 für die Geräte-
              adresse der angeschlossenen Floppy-Disk.

        Bank  Ein  ganzzahliger  Wert  zwischen   0  und  15  für  die
              Speicherbank, in die geladen werden soll. Voreingestellt
              ist hier 0.

         Adr  Ein  ganzzahliger Wert  zwischen  0 und  65535, der  die
              Adresse  in der  gewählten Bank  angibt, ab  der geladen
              werden  soll. Voreingestellt ist  hier die  Adresse, die
              sich aus den ersten beiden Bytes der Binärdatei ergibt.

Bemerkungen:  Werden für Dateiname, Laufwerk, Gerät, Bank und/oder Adr
              Variablen  verwendet,  so  müssen    diese   in Klammern
              angegeben werden.

[SEITE 4-20]

Beispiel 1:   BLOAD"BIN",ON B1,P1024

              Die  Datei  BIN  wird   von  der  Floppy-Disk   mit  der
              Geräteadresse 8 in Bank  1 des Hauptspeichers ab Adresse
              1024 geladen.

Beispiel 2:   BLOAD(D$),D(LW),U(GA),ON B(B),P(AD)

              In diesem Beispiel  werden für alle  Parameter Variablen
              verwendet.


[SEITE 4-21]

BOOT-Befehl

Format:       BOOT [Dateiname[,DLaufw][,UGerät]]

Zweck:        Lädt einen ausführbaren   Binärfile von Diskette in  den
              Hauptspeicher und startet es bei seiner Startadresse.

   Dateiname  Eine  Zeichenkettenkonstante  in  Anführungszeichen  (")
              oder -variable  einer Länge von  bis zu 16  Zeichen, die
              den Namen der zu ladenden Binärdatei angibt.

    Laufwerk  Ein Wert von 0 oder  1 für das Laufwerk, von dem geladen
              werden soll. Voreingestellt ist hier 0.

       Gerät  Ein  ganzzahliger  Wert  zwischen   4  und  15  für  die
              Geräteadresse der angeschlossenen Floppy-Disk.

Bemerkungen:  Werden  als  Parameter   Variablen verwendet,  so müssen
              diese in Klammern angegeben werden.

              Wird  BOOT ohne  Parameter verwendet,   so entnimmt  das
              Betriebssystem  dem Sektor 0  in der Spur 1 der Diskette
              in der  Floppy-Disk Nr. 8  die Information,  was geladen
              werden und gestartet werden soll. Diese Information kann
              mit Hilfe  der  Direktzugriffsbefehle  auf  die Diskette
              gebracht werden. Näheres siehe Floppy-Disk-Handbuch.

Beispiel:     BOOT"HILFE"

              Von der  Floppy-Disk mit  der  Geräteadresse 8  wird der
              ausführbare Binärfile   HILFE   geladen  und bei  seiner
              Startadresse gestartet.

[SEITE 4-22]

BOX-Anweisung

Format:       BOX [Farbquelle],x1,y1[,[x2,y2]][,[Winkel][,Ausmal]]

Zweck:        Es wird   ein  Rechteck an einer  wählbaren  Bildschirm-
              position gezeichnet und wahlweise ausgemalt.

  Farbquelle  Ein ganzzahliger  Wert zwischen 0 und 3,  der die Quelle
              für  die Farbe  definiert, in  der gezeichnet  wird.  Es
              bedeuten:

              0   Hintergrund
              1   Vordergrund
              2   Zusatzfarbe 1
              3   Zusatzfarbe 2

       x1,y1, Koordinaten der linken  oberen bzw. rechten unteren Ecke
       x2,y2  des Rechtecks.  Die x-Koordinaten  gehen von 0  bis 320,
              und  die y-Koordinaten  von 0  bis  199.  Voreingestellt
              sind  der  Punkt  links  oben im  Bildschirm  sowie  die
              aktuelle Position des Pixel-Cursors (grafischer Cursor).

      Winkel  Winkel in  Grad, um den  das Rechteck um  seinen Mittel-
              punkt  im  Uhrzeigersinn   gedreht  werden  soll.   Vor-
              eingestellt ist der Wert 0.

      Ausmal  Ein ganzzahliger Wert, der  festlegt, ob das Rechteck in
              der gewählten Farbe ausgemalt werden soll (1) oder nicht
              (0).

Bemerkungen:  Nach dem Zeichnen des Rechteckes ist der Punkt x2,y2 die
              aktuelle Position des grafischen Cursors.

[SEITE 4-23]

Beispiele:    BOX 1,10,10,60,60

              Zeichnet  die Kontur eines  Rechteckes in  der aktuellen
              Vordergrundfarbe.

              BOX , 10,10,60,60,45,1

              Zeichnet   eine   in   der  aktuellen   Vordergrundfarbe
              ausgefüllte Raute.

              BOX ,30,90,,45,1

              Zeichnet ein um 45 Grad gedrehtes, ausgefülltes Polygon.

[SEITE 4-24]

BSAVE-Befehl

Format:       BSAVE Dateiname[,DLaufwerk][,UGerät]
                    [,ON BBank][PAdr1][TO PAdr2]

Zweck:        Es wird ein Hauptspeicherbereich (z.B. Maschinensprache,
              Binärdaten) als Binärdatei auf Diskette gespeichert.

   Dateiname  Eine  Zeichenkettenkonstante  in  Anführungszeichen  (")
              oder -variable  einer Länge von  bis zu 16  Zeichen, die
              den Namen der zu speichernden Binärdatei angibt.

    Laufwerk  Ein Wert von 0 oder  1 für das Laufwerk, von dem geladen
              werden soll. Voreingestellt ist hier 0.

       Gerät  Ein  ganzzahliger  Wert  zwischen   4  und  15  für  die
              Geräteadresse der angeschlossenen Floppy-Disk.

        Bank  Ein  ganzzahliger  Wert  zwischen   0  und  15  für  die
              Speicherbank,   aus   der   gespeichert   werden   soll.
              Voreingestellt ist hier 0.

  Adr1, Adr2  Zwei  ganzzahlige Werte  zwischen 0  und 65535,  die die
              Anfangs-  und Endadressen  des Speicherbereiches  in der
              gewählten Bank angeben, der gespeichert werden soll.

Bemerkungen:  Werden für Dateiname,   Laufwerk,  Gerät, Bank  und/oder
              Adr1 und Adr2  Variablen  verwendet, so müssen diese  in
              Klammern angegeben werden.

[SEITE 4-25]

Beispiel 1:   BSAVE"BIN",ON B2,P1024 TO P2047

              Der  Hauptspeicherbereich von   Adresse  1024  bis  2047
              einschließlich (1  kByte) in Bank  2  wird als Datei BIN
              auf Diskette in der  Floppy-Disk mit der Geräteadresse 8
              gespeichert.

Beispiel 2:   BSAVE(D$),D(LW),U(GA),ON B(B),P(A1) TO P(A2)

              Bei diesem Beispiel  werden für alle Parameter Variablen
              verwendet.

[SEITE 4-26]

BUMP-Funktion

Format:       v=BUMP(n)

Zweck:        Liefert die  Nummer des Sprites (1  bis 8), das seit der
              letzten BUMP-Abfrage entweder  mit einem  anderen Sprite
              (n=1) oder mit angezeigten Daten (n=2) kollidiert ist.

Bemerkungen:  Wenn  BUMP  verwendet wird,  braucht  die Programmunter-
              brechung    für Sprite-Kollisionen   nicht     mit   der
              COLLISION-Anweisung (s.  dort) aktiviert zu sein.

              Bei   Mehrfachabfragen  sollten vorher   mit  Hilfe  der
              RSPRITE-Funktion  die Sprite-Attribute abgefragt werden,
              um   feststellen   zu   können,   welches Sprite   womit
              kollidiert ist.

              BUMP(n) wird nach einer Abfrage auf Null gesetzt.

Beispiel:     100 ON BUMP(2)GOTO120,130,140,150

              Wenn Sprite Nr. 1 mit  angezeigten Daten kollidiert ist,
              verzweigt das  Programm nach Zeile 120,  bei  Nr. 2 nach
              Zeile 130 usw.

[SEITE 4-27]

CATALOG-Befehl

Der CATALOG-Befehl ist mit dem DIRECTORY-Befehl (s. dort) identisch.

[SEITE 4-28]

CHAR-Anweisung

Format:       CHAR [Farbquelle].x.y[.Zeichenkette][,Invers]

Zweck:        Zeigt eine  Zeichenkette  mit auswählbarer  Position auf
              dem Bildschirm an.

  Farbquelle  Ein ganzzahliger  Wert zwischen 0  und 3, der  die Farbe
              definiert, in  der der  Text angezeigt werden  soll.  Es
              bedeuten:

              0   Hintergrundfarbe
              1   Vordergrund- (Zeichen-)Farbe
              2   Zusatzfarbe 1
              3   Zusatzfarbe 2

         x,y  Die Spalten- (x) und die Zeilen (y)-Position, ab der der
              Text angezeigt werden soll.   Spalten: 0 bis 39 bzw. 79;
              Zeilen: 0 bis 24.

     Zeichen-
       kette  Der anzuzeigende Text in Anführungszeichen (").

      Invers  Ein  Parameter für die  inverse Darstellung  des Textes.
              Hat er den Wert 0, wird der Text normal, hat er den Wert
              1, invers dargestellt.

Bemerkungen:  Im   Text-Modus  arbeitet die  CHAR-Anweisung analog zur
              PRINT-Anweisung (s.  dort  in  Kapitel  3),  d.h.   auch
              eventuelle Cursor-Steuercodes in der Zeichenkette werden
              ausgeführt.

              Im  Grafik-Modus werden  solche  Steuercodes nicht  aus-
              geführt.

              Um im Mehrfarbenmodus  (s.  Kapitel 4.7) Zeichen  in der
              Zusatzfarbe 2  anzuzeigen,  muß  Farbquelle auf   0  und
              Invers auf 1 gesetzt werden.

[SEITE 4-29]

              Um  im Mehrfarbenmodus  Zeichen   in  der Zusatzfarbe  1
              anzuzeigen, muß   Farbquelle auf  1  und Invers   auf  0
              gesetzt werden.

Beispiel:     100 CHAR1,38,12,"GUTEN MORGEN"

              Der Text  "GUTEN   MORGEN"   wird  in   der    aktuellen
              Vordergrundfarbe in der Bildschirmmitte angezeigt.

[SEITE 4-30]

CIRCLE-Anweisung

Format:       CIRCLE [Farbquelle],[x,y],xr[,[yr]
                     [,[Start][,[Ende][,[Winkel]
                     [,Segmentwinkel]

Zweck:        Es wird eine  Ellipse,   ein Kreis oder ein   beliebiges
              Polygon  mit dem  Mittelpunkt   x,y  auf dem  Bildschirm
              gezeichnet.

  Farbquelle  Ein ganzzahliger  Wert zwischen 0  und 3, der  die Farbe
              definiert. Es bedeuten:

              0   Hintergrundfarbe
              1   Vordergrund- (Zeichen-)Farbe
              2   Zusatzfarbe 1
              3   Zusatzfarbe 2

         x,y  Die skalierten  (s.  SCALE-Anweisung) Mittelpunktkoordi-
              naten der Ellipse.  Voreingestellt ist hier die aktuelle
              Position des grafischen Cursors (Pixel-Cursor).

          xr  Radius der Hauptachse (skaliert).

          yr  Radius  der  Nebenachse  (skaliert). Voreingestellt  ist
              hier xr.

  Start,Ende  Numerische  Ausdrücke,  deren  Werte Winkelangaben  dar-
              stellen  und  die angeben,  wo  das  Zeichnen der  Figur
              beginnen und enden soll.  Die Winkel werden entgegen der
              mathematischen  Konvention  von  0 in  Uhrzeigerrichtung
              gezählt. Voreingestellt ist hier der Wert 0.

    Segment-  Numerischer Ausdruck, dessen  Wert den Winkel angibt, um
     winkel   den jedes Segment der Figur gegenüber dem vorhergehenden
              versetzt werden  soll. Voreingestellt ist  hier der Wert
              2.

[SEITE 4-31]

Bemerkungen:  Nach dem  Zeichnen der Figur  ist  die aktuelle Position
              des grafischen Cursors der Endpunkt des Winkels Ende.

              Jede  Drehung der  Figur   erfolgt grundsätzlich um  den
              Mittelpunkt x,y.

              Werden   xr und  yr   gleichgesetzt, so  wird ein  Kreis
              gezeichnet.

              Der  Parameter   Segmentwinkel bestimmt  die  Anzahl der
              Seiten (Eckigkeit) der   Figur.  Kleinere Werte  ergeben
              rundere Konturen.

Beispiele:    CIRLCE,160,100,65,10

              Zeichnet eine Ellipse in der aktuellen Vordergrundfarbe.

              CIRCLE,160,100,65,50

              Zeichnet einen Kreis.

              CIRCLE,60,40,20,18,,,,45

              Zeichnet ein Achteck.

              CIRCLE,260,40,20,,,,,90

              Zeichnet eine Raute.

              CIRCLE,60,140,20,18,,,,120

              Zeichnet ein Dreieck.

[SEITE 4-32]

COLLECT-Befehl

Format:       COLLECT [DLaufwerk][ON U Geräteadr]

Zweck:        Löscht alle nicht  geschlossenen  Dateien und  gibt  den
              solchen Dateien    zugewiesenen Speicherplatz  auf   der
              Diskette   im   spezifizierten   Laufwerk  wieder   frei
              (s.a. Kapitel 6.9.1).

    Laufwerk  Ganzzahliger Wert von 0  oder 1. Voreingestellt ist hier
              0.

   Geräteadr  Ganzzahliger Wert zwischen 8 und 15.  Voreingestellt ist
              hier 8.

Beispiele:    COLLECT

              COLLECT D1 ON U10

[SEITE 4-33]

COLLISION-Anweisung

Format:       COLLISION Typ[,Zeilennummer]

Zweck:        Inaktiviert oder aktiviert die Programmunterbrechung für
              Sprite-Kollisionen und definiert  im letzteren Fall eine
              Programmzeile für Programmverzweigung bei Kollisionen.

         Typ  Ganzzahliger  Wert zwischen  1 und  3, der  das Ereignis
              definiert, das zur Unterbrechung führen soll. Es gilt:

              1  Sprite-Sprite-Kollision
              2  Sprite-Anzeigedaten-Kollision
              3  Lichtstift-Aktivierung

     Zeilen-  Eine  gültige Programmzeilennummer,  zu  der bei  Unter-
     nummer   brechung verzweigt werden soll.

Bemerkungen:  Wenn  das   angegebene  Ereignis  eintritt,   führt  der
              Interpreter die  augenblicklich interpretierte Anweisung
              noch  zuende  und  verzweigt   dann  mit  GOSUB  zu  der
              angegebenen  Zeilennummer.   Das  dort zu  durchlaufende
              Unterprogramm  muß   mit  einer  RETURN-Anweisung  abge-
              schlossen sein.  Anschließend wird das  Programm mit der
              auf  die  unterbrochene  Anweisung  folgenden  Anweisung
              fortgesetzt.

              Wird Zeilennummer   weggelassen,   wird  die   Programm-
              unterbrechung  für  das  spezifizierte  Ereignis inakti-
              viert.

              Es können mehrere  verschiedene Unterbrechungsereignisse
              gleichzeitig  aktiviert  sein; es  kann jedoch  zu einer
              Zeit  immer nur eine   Unterbrechung  bearbeitet werden.
              Unterbrechungsschachtelung ist also nicht möglich.

              Es muß berücksichtigt  werden, daß die Ursache  für eine
              Programmunterbrechung eine Zeit  lang wirksam sein kann,
              obwohl  bereits eine andere  Situation vorliegt oder die
              Unterbrechung inzwischen inaktiviert wurde.

[SEITE 4-34]

              Verschwindet  ein  Sprite  vom  sichtbaren Bereich   des
              Bildschirms,  kann   es  auch  keine  Unterbrechung mehr
              auslösen.

              Um das Sprite zu bestimmen, das seit der letzten Abfrage
              eine  Kollision verursacht  hat, kann  die BUMP-Funktion
              (s. dort) verwendet werden.

Beispiel:     100 COLLISION2,500

              Das Programm  verzweigt zu einem Unterprogramm bei Zeile
              500,  sobald  eine  Kollision zwischen einem  Sprite und
              angezeigten Daten erfolgt.

[SEITE 4-35]

COLOR-Anweisung

Format:       COLOR Farbquelle,Farbcode

Zweck:        Definiert für   jede mögliche Farbquelle   eine der   16
              möglichen Farben.

  Farbquelle  Folgende Farbquellcodes sind verfügbar:

              0  Hintergrund (40-Zeichen-Anzeige)
              1  grafischer Vordergrund
              2  grafischer Mehrfarbenmodus 1
              3  grafischer Mehrfarbenmodus 2
              4  Rand
              5  Textfarbe
              6  Hintergrund (80-Zeichen-Anzeige)

    Farbcode  Folgende Farbcodes sind verfügbar:

              1  schwarz              9  hellbraun
              2  weiß                10  braun
              3  rot                 11  rosa
              4  grün                12  dunkelgrau
              5  violett             13  grau
              6  dunkelgrün          14  hellgrün
              7  blau                15  hellblau
              8  gelb                16  hellgrau

Bemerkungen:  Die   Farbwiedergabe   kann      bei       verschiedenen
              Farbbildschirmen    unterschiedlich   ausfallen.     Auf
              Schwarz/Weiß-Bildschirmen  erscheinen  die  Farben   als
              unterschiedliche Grautöne.

Beispiel:     COLOR0,2:COLOR1,3:COLOR4,1

              Der  Hintergrund erscheint  weiß, der Vordergrund (Text)
              rot und der Rahmen schwarz.

[SEITE 4-36]

CONCAT-Befehl

Format:       CONCAT [DQuelllaufw,]Quelldatei TO [DZiellaufw,]Zieldatei
                     [ON U Geräteadr]

Zweck:        Fügt eine  angegebene sequentielle   Datei an das   Ende
              einer  anderen angegebenen  sequentiellen Datei auf  der
              Diskette   im angegebenen   Laufwerk  an  (s.a.  Kapitel
              6.9.3).

 Quelllaufw,  Ganzzahlige Werte von 0 oder 1.  Voreingestellt ist hier
  Ziellaufw   0.

 Quelldatei,  Zeichenkettenkonstanten  in  Anführungszeichen (")  oder
  Zieldatei   -variablen einer  Länge von bis  zu 16 Zeichen,  die die
              anzufügende und  die zu verlängernde  sequentielle Datei
              bezeichnen.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4  und  15,  der  die
              Geräteadresse der Floppy-Disk angibt. Voreingestellt ist
              hier der Wert 8.

Beispiele:    CONCAT"DATEN1"TO"DATEN2"

              Die sequentielle Datei DATEN1  wird an die  sequentielle
              Datei DATEN2   auf Laufwerk 0   der  Floppy-Disk mit der
              Geräteadresse 8 angefügt.

              CONCATD(QL),(D1$)TOD(ZL),(D2$)

              Bei  diesem  Beispiel werden  für  Laufwerk- und  Datei-
              angaben Variablen verwendet.

[SEITE 4-37]

COPY-Befehl

Format:       COPY [DQuelllaufw,]Quelldatei TO [DZiellaufw,]Zieldatei
                   [ON U Geräteadr]

Zweck:        Kopiert eine  angegebene Quelldatei unter demselben oder
              einem   neuen Namen   auf  die Diskette   im angegebenen
              Laufwerk derselben Floppy-Disk-Einheit.

 Quelllaufw,  Ganzzahlige Werte von 0 oder 1.  Voreingestellt ist hier
  Ziellaufw   0.

 Quelldatei,  Zeichenkettenkonstanten  in  Anführungszeichen (")  oder
  Zieldatei   -variablen einer Länge von bis zu 16 Zeichen, die die zu
              kopierende und die kopierte Datei bezeichnen.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4  und  15,  der  die
              Geräteadresse der Floppy-Disk angibt. Voreingestellt ist
              hier der Wert 8.

Bemerkungen:  Bei der Angabe der  Quelldatei können die Jokerzeichen *
              und   ?  verwendet werden, um   mehrere Dateien in einem
              Durchgang zu kopieren.

Beispiele:    COPY"DATEN"TO"ZIEL"

              Die  Datei   DATEN  auf  Diskette    in Laufwerk  0  der
              Floppy-Disk mit der Geräteadresse 8 wird unter dem Namen
              "ZIEL" dupliziert.

              COPY"QUELLE"TOD1,"*"

              Die Datei "QUELLE" wird  von  Laufwerk 0 auf Laufwerk  1
              unter demselben Namen kopiert.

              COPYD1,"ADR*"TO"*"ONU9

              Auf der Floppy-Disk mit  der Geräteadresse 9 werden alle
              Dateien auf Laufwerk 1,  deren Namen mit "ADR" beginnen,
              unter Beibehaltung ihrer Namen auf Laufwerk 0 kopiert.

[SEITE 4-38]

DCLEAR-Anweisung

Format:       DCLEAR DLaufwerk [ON UGeräteadr]

Zweck:        Alle  für  das   angegebene   Laufwerk  offenen  Floppy-
              Disk-Kanäle (nicht Dateien) werden geschlossen.

    Laufwerk  Ganzzahliger Wert von 0 oder 1.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4  und  15,  der  die
              Geräteadresse der Floppy-Disk angibt. Voreingestellt ist
              hier der Wert 8.

Bemerkungen:  Wird ein Kanal z.B.  mit der  CMD-Anweisung (s. dort  in
              Kapitel 5.2) eröffnet, so bleibt dieser Kanal aktiv, bis
              eine  Ausgabe   mit    PRINT#     erfolgt  oder     eine
              DCLEAR-Anweisung gegeben wird.

+-------------------------------------------------------------------+
| Achtung                                                           |
| DCLEAR schließt keine geöffnete Datei. Das muß vor der Verwendung |
| der DCLEAR-Anweisung erfolgen, falls Daten mit der CMD-Anweisung  |
| ausgegeben wurden.                                                |
+-------------------------------------------------------------------+

Beispiel:     DCLEAR

              Alle offenen Kanäle für Laufwerk  0  auf Gerät 8  werden
              geschlossen.

[SEITE 4-39]

DCLOSE-Anweisung

Format:       DCLOSE [#log Dateinr] [ON U Geräteadr]

Zweck:        Schließt die spezifizierte oder alle offenen Dateien auf
              der angeschlossenen Floppy-Disk (s.a. Kapitel 6.6).

 log Dateinr  Ein ganzzahliger Wert zwischen  1 und 255, unter dem die
              Datei mit der OPEN- (s. dort in Kapitel 5.2) oder DOPEN-
              (s.  dort  in diesem Kapitel)  Anweisung auf Floppy-Disk
              eröffnet wurde.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4  und  15,  der  die
              Geräteadresse der Floppy-Disk angibt. Voreingestellt ist
              hier der Wert 8.

Beispiele:    DCLOSE

              Alle  für die  Floppy-Disk    mit  der Geräteadresse   8
              eröffneten Dateien werden geschlossen.

              DCLOSE #5 ON U9

              Die  Datei mit    der logischen Dateinummer   5  auf der
              Floppy-Disk mit der Geräteadresse 9 wird geschlossen.

[SEITE 4-40]

DEC-Funktion

Format:       v$=DEC(hex Zeichenkette)

Zweck:        Liefert  den  Dezimalwert  eines  Zahlenwertes in  hexa-
              dezimaler Schreibweise.

        hex   Eine  Zeichenkette in  Anführungszeichen ("),  die einen
    Zeichen-  hexadezimalen  Wert  im  Bereich  zwischen  0  und  FFFF
      kette   darstellt.

Beispiel:     PRINT DEC("FFFF")
              65535
              READY.

[SEITE 4-41]

DELETE-Befehl

Format:       DELETE [Zeilennr1] [-Zeilennr2]

Zweck:        Der   angegebene   Zeilennummernbereich  wird in dem  im
              Hauptspeicher befindlichen Programm gelöscht.

   Zeilennr1  Nummer der ersten zu löschenden Zeile.

   Zeilennr2  Nummer der letzten zu löschenden Zeile.

Bemerkungen:  Der  DELETE-Befehl  kann  nur im  Direktmodus  verwendet
              werden.

Beispiele:    DELETE 10

              Zeile 10 wird gelöscht.

              DELETE 10-200

              Zeilen 10 bis 200 werden gelöscht.

              DELETE -200

              Alle Zeilen   vom    Programmanfang  bis   Zeile     200
              einschließlich werden gelöscht.

              DELETE 200-

              Alle  Zeilen von    einschließlich  Zeile 200  bis   zum
              Programmende werden gelöscht.

[SEITE 4-42]

DIRECTORY-Befehl

Format:       DIRECTORY [D Laufwerk] [,U Geräteadr] [,Dateiname]

Zweck:        Zeigt   das    Verzeichnis    der   Diskette    auf  dem
              spezifizierten    Laufwerk  oder  Teile  davon  auf  dem
              Bildschirm an (s.a. Kapitel 6.5).

    Laufwerk  Ganzzahliger Wert von 0  oder 1. Voreingestellt ist hier
              der Wert 0.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4  und  15,  der  die
              Geräteadresse der Floppy-Disk angibt. Voreingestellt ist
              hier der Wert 8.

   Dateiname  Wahlweise  ein Dateiname  als  Zeichenkettenkonstante in
              Anführungsstrichen  ("), für den  der Verzeichniseintrag
              angezeigt   werden  soll.   Um   Dateien  mit   gleichen
              Namensteilen anzuzeigen, dürfen die Jokerzeichen * und ?
              (s.a.  Kapitel 6.3) verwendet werden.

Bemerkungen:  Die Anzeige langer Verzeichnisse führt zum Aufrollen des
              Bildschirms. Mit Hilfe  der NO  SCROLL-Taste (s. Kapitel
              5.2)  kann die   Anzeige angehalten werden,  mit der  C=
              (Commodore)-Taste kann sie verlangsamt werden.

Beispiele:    DIRECTORY

              Alle Verzeichniseinträge  von der Diskette in Laufwerk 0
              der   Floppy-Disk    mit  der   Geräteadresse   8 werden
              angezeigt.

              DIRECTORY D1,U9,"DATEN"

              Der  Verzeichniseintrag    der Datei "DATEN"   auf   der
              Diskette   in Laufwerk   1   der  Floppy-Disk    mit der
              Geräteadresse 9 wird, falls vorhanden, angezeigt.

[SEITE 4-43]

              DIRECTORY"AB*"

              Die  Verzeichniseinträge für  alle Dateien, deren  Namen
              mit  AB beginnen, auf  der  Diskette in  Laufwerk 0  der
              Floppy-Disk mit der Geräteadresse 8 werden angezeigt.

              DIRECTORY"DATEI???.ARB"

              Die Verzeichniseinträge  für alle  Dateien, deren  Namen
              zwischen  den   Zeichen DATEI und  .ARB  drei  beliebige
              Zeichen enthalten,  auf der Diskette   in Laufwerk 0 der
              Floppy-Disk mit der Geräteadresse 8 werden angezeigt.

+---------------------------------------------------------------------+
| Achtung:                                                            |
| Um ein Diskettenverzeichnis z.B. von Laufwerk 0 auf der Floppy-Disk |
| mit der Geräteadresse 8 auf dem Drucker mit der Geräteadresse 4     |
| auszugeben, muß folgende Anweisungssequenz im Direktmodus ein-      |
| gegeben werden:                                                     |
|                                                                     |
|              LOAD"$0",8                                             |
|              OPEN4,4:CMD4:LIST                                      |
|              PRINT#4:CLOSE4                                         |
+---------------------------------------------------------------------+

[SEITE 4-44]

DLOAD-Befehl

Format:       DLOAD Dateiname [,D Laufwerk] [,U Geräteadr]

Zweck:        Lädt ein  BASIC-Programm von einer  angegebenen Diskette
              in den Hauptspeicher des Rechners s.a. Kapitel 6.6).

   Dateiname  Eine  Zeichenkettenkonstante  in Anführungsstrichen  (")
              oder eine  -Variable in Klammern () einer  Länge von bis
              zu 16 Zeichen, die den Programmdateinamen bezeichnet.

    Laufwerk  Ein ganzzahliger Wert von  0 oder 1.  Voreingestellt ist
              hier 0.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4 oder  15,  der  die
              Geräteadresse     der     angeschlossenen    Floppy-Disk
              bezeichnet. Voreingestellt ist hier der Wert 8.

Bemerkungen:  Innerhalb eines  BASIC-Programmes dient der DLOAD-Befehl
              zum Aufruf und Start eines anderen BASIC-Programmes, das
              das aufrufende  Programm überlagert. Alle  Variablen des
              aufrufenden Programms bleiben erhalten.

              Wird das spezifizierte Programm nicht gefunden, wird die
              Fehlermeldung FILE NOT FOUND ERROR angezeigt.

[SEITE 4-45]

DO-Anweisung

Format:       DO [UNTIL logischer Ausdruck]
              .
              .Anweisungen
              .
              ...[EXIT]
              LOOP [UNTIL logischer Ausdruck]

              DO [WHILE logischer Ausdruck]
              .
              .Anweisungen
              .
              ...[EXIT]
              LOOP [WHILE logischer Ausdruck]

Zweck:        Definiert und steuert den Ablauf von Programmschleifen.

Bemerkungen:
              Wenn  kein  Zusatz UNTIL  oder  WHILE  in Verbindung mit
              logischen    Ausdrücken  angegeben    ist, werden   alle
              Anweisungen der Schleife unendlich oft ausgeführt.

              Wird  der  Zusatz   EXIT   in die   Schleifenanweisungen
              eingefügt,  so  wird   die  Schleife  an  dieser  Stelle
              verlassen, und  das  Programm  wird  mit der  auf   LOOP
              folgenden Anweisung fortgesetzt.

              DO ... LOOP-Programmschleifen   können  nach   denselben
              Regeln geschachtelt werden,   wie FOR ... NEXT-Schleifen
              (s. dort in Kapitel 5.2).

              Wird der Zusatz UNTIL   verwendet, so wird die  Schleife
              solange   ausgeführt, bis  der   nach  UNTIL  angegebene
              logische Ausdruck wahr (-1) wird.

              Wird der Zusatz  WHILE  verwendet, so wird die  Schleife
              solange   ausgeführt,   bis  der  nach  WHILE angegebene
              logische Ausdruck falsch (0) wird.

[SEITE 4-46]

Beispiel 1:   100 X=10
              110 DO UNTIL X=0 OR X=1
              120 PRINT"X IST NOCH NICHT 0 ODER 1"
              130 X=X-1
              140 LOOP
              150 ...

              Die  Schleife wird  neunmal  durchlaufen,  dann ist  X=1
              wahr, und das Programm wird mit Zeile 150 fortgesetzt.

Beispiel 2:   100 DO WHILE A$="":GETA$"LOOP

              Die Programmausführung wird solange angehalten, bis eine
              Taste gedrückt wird.

[SEITE 4-47]

DOPEN-Anweisung

Format:       DOPEN #log Filenr, Dateiname [,LLänge]
                    [,D Laufw] [,U Geräteadr] [,W]

Zweck:        Eröffnet   eine  sequentielle  oder  Relativ-Datei   auf
              Diskette für Daten-Ein- oder -Ausgabe (s.a. Kapitel 6.6).

  log Filenr  Ein  ganzzahliger  Wert  zwischen  1 und  255,  der  der
              eröffneten  Datei als  Kennummer  zugeordnet wird.   Bei
              Werten  kleiner  als  128  wird  nach  jeder  PRINT#-An-
              weisung  ein Wagenrücklaufcode  ausgegeben.   Bei Werten
              über  127 wird  zusätzlich  ein Zeilenvorschubcode  aus-
              gegeben.

   Dateiname  Eine  Zeichenkettenkonstante  in Anführungsstrichen  (")
              oder -variable  einer Länge von  bis zu 16  Zeichen, die
              den Namen der zu eröffnenden Datei bezeichnet.

       Länge  Ein ganzzahliger  Wert zwischen 1 und 254  für die Länge
              der logischen Sätze bei Relativ-Dateien.

       Laufw  Ein ganzzahliger Wert von  0 oder 1.  Voreingestellt ist
              hier 0.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen   4  und  15  für  die
              Geräteadresse     der    angeschlossenen    Floppy-Disk.
              Voreingestellt ist hier 8.

           W  Wird  dieser Parameter angegeben,  so wird  eine sequen-
              tielle  Datei zum  Schreiben  eröffnet, andernfalls  zum
              Lesen.

Bemerkungen:  Werden die Parameter als  Variablen übergeben, so müssen
              diese in Klammern gesetzt werden.

              LLänge und  W  dürfen nicht  zusammen  in  einer  DOPEN-
              Anweisung angegeben werden.

[SEITE 4-48]

              Werden  zwei Dateien  unter derselben  logischen  Datei-
              nummer  eröffnet,   wird  die  Fehlermeldung   FILE OPEN
              angezeigt.

Beispiele:    DOPEN#2,"DATEN"

              Die sequentielle  Datei    DATEN  auf   Laufwerk  0  der
              Floppy-Disk  mit  der  Geräteadresse 8  wird  zum  Lesen
              eröffnet.

              DOPEN#3,"ADRESSEN",D1,U9,W

              Die  sequentielle   Datei  ADRESSEN  auf  Laufwerk 1 der
              Floppy-Disk mit der Geräteadresse  9 wird zum  Schreiben
              eröffnet.

              DOPEN#5,"KLIENTEN",L112

              Die Relativ-Datei KLIENTEN mit einer logischen Satzlänge
              von  112 Bytes wird auf  Laufwerk 0  der Floppy-Disk mit
              der Geräteadresse 8 eröffnet.

[SEITE 4-49]

DRAW-Anweisung

Format:       DRAW [Farbquelle] [,x1,y1] TO x2,y2 ...

Zweck:        Verbindet beliebig viele spezifizierte Koordinaten durch
              eine Linie.

  Farbquelle  Ein ganzzahliger  Wert zwischen 0  und 3, der  die Farbe
              definiert,  in   der  die  Linie(n)   gezeichnet  werden
              soll(en).  Voreingestellt  ist hier die Vordergrundfarbe
              (1).  Es bedeuten:

              0  Hintergrundfarbe
              1  Vordergrund- (Zeichen-)Farbe
              2  Zusatzfarbe 1
              3  Zusatzfarbe 2

       x1,y1  Koordinaten des Starpunktes der Linie.

       x2,y2  Koordinaten des Endpunktes der Linie.

Bemerkungen:  Es  können   soviele  Koordinaten  mit  davor gestelltem
              Parameter TO spezifiziert werden, wie in einer Programm-
              zeile Platz haben.

              Der Endpunkt der  vorhergehenden Linie  ist dann gleich-
              zeitig der Startpunkt für die folgende Linie.

              Sind Start-  und Endkoordinaten  gleich, wird ein  Punkt
              gezeichnet.

              Wird die  Startkoordinate  nicht angegeben,  so gilt die
              aktuelle Position  des grafischen Cursors (Pixel-Cursor)
              als Startpunkt.

[SEITE 4-50]

Beispiele:    DRAW 1,100,50

              Zeichnet einen  Punkt, da  keine Endkoordinate angegeben
              ist.

              100 DRAW ,10,10 TO 100,60
              110 DRAW ,TO 25,30

              Zeichnet einen Winkel.

              DRAW ,10,10 TO 10,60 TO 100,60 TO 10,10

              Zeichnet eine Figur.

[SEITE 4-51]

DSAVE-Befehl

Format:       DSAVE Dateiname [,D Laufwerk] [,U Geräteadr]

Zweck:        Speichert ein  BASIC-Programm  aus dem Hauptspeicher auf
              Diskette im angegebenen Laufwerk (s.a. Kapitel 6.2).

   Dateiname  Eine Zeichenkettenkonstante in  Anführungs-
              strichen (")  oder eine  -variable   in Klammern ()  mit
              einer Länge  von bis zu  16  Zeichen, die den  Programm-
              dateinamen bezeichnet.

    Laufwerk  Ein ganzzahliger  Wert von 0 oder  1. Voreingestellt ist
              hier 0.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4 oder  15,  der  die
              Geräteadresse     der     angeschlossenen    Floppy-Disk
              bezeichnet. Voreingestellt ist hier der Wert 8.

Bemerkungen:  Werden die Parameter als  Variablen übergeben, so müssen
              diese in Klammern gesetzt werden.

              Nach  Ausführung  von DSAVE  kehrt der  Interpreter  auf
              jeden Fall in den Direktmodus zurück.

              Zur Speicherung  von Programmen   auf Kassette  muß  die
              SAVE-Anweisung   (s.  dort   in  Kapitel 5.2)  verwendet
              werden.

              Existiert die angegebene Datei  bereits auf Diskette, so
              wird  die Fehlermeldung  FILE  EXISTS  erzeugt, die  mit
              PRINT DS$ angezeigt werden kann.

Beispiele:    DSAVE"PROG1"

              Das im Hauptspeicher befindliche Programm wird unter dem
              Namen  PROG1 auf die Diskette  in Laufwerk 0 von Gerät 8
              gespeichert.

              DSAVE(A$),D(LW),U(GA)

              Hier werden die Parameter als Variablen übergeben.
[SEITE 4-52]

DS- und DS$-Systemvariablen

Format:       v=DS
              v$=DS$

Zweck:

              Liefert den Fehlerstatus als Code (DS) und als komplette
              Statusmeldung  (DS$) des zuletzt angesprochenen  Floppy-
              Disk-Gerätes.

Bemerkungen:  Ein Statuscode von 0 bedeutet kein Fehler.

              Die Statusmeldung ist  eine Zeichenkette und besteht aus
              4 Teilen:

              Statuscode
              Statustext
              Spur-Nr., bei der der Fehler auftrat
              Sektor-Nr., bei der der Fehler auftrat

              Durch eine Fehlerabfrage  wird der Fehlerstatus  zurück-
              gesetzt.

              Da DS und DS$ Systemvariablen sind, dürfen sie nicht als
              anwenderspezifische     Variablen   in  einem   Programm
              verwendet werden.   Andernfalls  würde der Fehler SYNTAX
              ERROR angezeigt.

Beispiel:     PRINT DS$:PRINT DS
              32,SYNTAX ERROR,00,00
              32
              READY.

              Das zuletzt angesprochene Floppy-Disk-Gerät zeigt  einen
              Syntax-Fehler, weil die übermittelte Befehlszeichenkette
              zu lang war.

[SEITE 4-53]

DVERIFY-Befehl

Format:       DVERIFY Dateiname [,D Laufwerk] [,U Geräteadr]

Zweck:        Vergleicht ein Programm  im  Hauptspeicher byteweise mit
              einer Programmdatei auf einer angegebenen Diskette.

   Dateiname  Eine  Zeichenkettenkonstante  in Anführungsstrichen  (")
              oder eine  -variable in Klammern () einer  Länge von bis
              zu 16 Zeichen, die den Programmdateinamen bezeichnet.

    Laufwerk  Ein ganzzahliger Wert von  0 oder 1.  Voreingestellt ist
              hier 0.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4 oder  15,  der  die
              Geräteadresse     der     angeschlossenen    Floppy-Disk
              bezeichnet. Voreingestellt ist hier der Wert 8.

Bemerkungen:  Wenn nach  Ausführung eines SAVE- oder DSAVE-Befehls ein
              grafischer Bereich  reserviert  oder  wieder freigegeben
              wird,   liefern  die  Befehle   VERIFY oder  DVERIFY die
              Fehlermeldung VERIFY ERROR,    obwohl  das Programm   in
              Ordnung  ist.  Dies   entsteht  dadurch,  daß durch  die
              Reservierung oder   Freigabe eines grafischen  Bereiches
              ein BASIC-Programm  aus seiner  ursprünglichen Speicher-
              position verschoben wird, wodurch die Adreßzeiger inner-
              halb der BASIC-Zeilen verändert werden  und  eine  byte-
              weise  Übereinstimmung  mit dem   gespeicherten Programm
              nicht mehr gegeben ist.

[SEITE 4-54]^

Beispiele:    DVERIFY"PROG1"

              Das Programm  PROG1 auf Laufwerk  0 in der Floppy-Disk 8
              wird mit dem hauptspeicherresidenten Programm  byteweise
              verglichen.

              DVERIFY"MULT",D1,1

              Das Programm MULT auf Laufwerk 1  der Floppy-Disk 8 wird
              mit  einem  hauptspeicherresidenten    Maschinensprache-
              programm verglichen,  das   nicht am  Anfang  des BASIC-
              Programmspeichers beginnt.

[SEITE 4-55]

Format:       v=EL

Zweck:        Liefert die Nummer der Programmzeile,  in der ein Fehler
              aufgetreten ist.

Bemerkungen:  Da  EL  eine Systemvariable  ist,  darf  sie  nicht  als
              anwenderspezifische Variable in einem Programm verwendet
              werden.   Andernfalls   würde  der  Fehler  SYNTAX ERROR
              angezeigt.

Beispiele:    800 IF EL=100 THEN 1000

              Wenn  EL  in einer IF-Abfrage verwendet  wird,  muß  die
              Vergleichsnummer  rechts  von  der  EL-Variablen stehen,
              damit  sie bei einer  ggfs. durchgeführten Renumerierung
              berücksichtigt werden kann.

[SEITE 4-56]

ENVELOPE-Anweisung

Format:       ENVELOPE n [,[An] [,[Ab] [,[Ha] [,[Au] [,Wd] [,Ib]]]]]]

Zweck:        Definiert eine  von 10 möglichen  Hüllkurven für  Musik-
              instrumente.

           n  Nummer der Hüllkurve (0 bis 9)
          An  Anschlagzeit (0 bis 15)
          Ab  Abschwellzeit (0 bis 15)
          Ha  Haltezeit (0 bis 15)
          Au  Ausklingzeit (0 bis 15)
          Wf  Wellenform:
              0  Dreieck
              1  Sägezahn
              2  Rechteck
              3  Rauschen
              4  Ringmodulation
          Ib  Impulsbreite (0 bis 4095)

Bemerkungen:  Ein nicht  spezifizierter Parameter behält seinen momen-
              tanen Wert.

              Die Impulsbreite ist  nur im Zusammenhang mit der Recht-
              eck-Wellenform (Wf=2)  definierbar  und wird  durch  die
              Formel  PULSBREITE=Ib/40.95 %  bestimmt,  so daß Ib=2048
              eine Rechteckwelle erzeugt.

[SEITE 4-57]

              Nach dem  Einschalten   des  Rechners  werden  für   die
              Parameter folgende Werte voreingestellt:

              n   An   Ab   Ha   Au   Wf     Ib       Instrument

              0    0    9    0    0    2   1536       Klavier
              1   12    0   12    0    1              Akkordeon
              2    0    0   15    0    0              Zirkusorgel
              3    0    5    5    0    3              Trommel
              4    9    4    4    0    0              Flöte
              5    0    9    2    1    1              Gitarre
              6    0    9    0    0    2    512       Cembalo
              7    0    9    9    0    2   2048       Orgel
              8    8    9    4    1    2    512       Trompete
              9    0    9    0    0    0              Xylophon

              Weitere Einzelheiten  zur   ENVELOPE-Anweisung entnehmen
              Sie bitte dem Abschnitt "Musikerzeugung mit dem C128" ab
              Seite 4-156 ff.

[SEITE 4-58]

ER-Systemvariable

Format:       v=ER

Zweck:        Liefert den  Code des  zuletzt vom Interpreter  diagnos-
              tizierten Fehlers.

              Im Kapitel 8.1 sind die Fehlermeldungen zusammen mit den
              ihnen zugeordneten Fehlercodes aufgeführt.

Bemerkungen:

              Da  ER eine Systemvariable   ist,  darf  sie nicht   als
              anwenderspezifische Variable in einem Programm verwendet
              werden.    Andernfalls  würde  der  Fehler  SYNTAX ERROR
              angezeigt.

Beispiele:    100 IF ER=30 THEN 1000

              Wenn   die  STOP-Taste  gedrückt  wird,   verzweigt  das
              Programm nach Zeile 1000.

[SEITE 4-59]

ERR$-Funktion

Format:       v$=ERR$(n)

Zweck:        Liefert den Text des durch n spezifizierten Fehlers.

           n  Ein  ganzzahliger  Wert  zwischen  1 und  127,  der  den
              Fehlercode angibt (s. Kapitel 8.1).

Beispiel:     10 TRAP 1000
              .
              .BASIC-Anweisungen
              .
              1000 REM ANALYSE DER FEHLERMELDUNGEN
              1001 REM BEI SYNTAX-ERROR PROGRAMMSTOP
              1010 IF ER=11 THEN PRINT EL,ERR$:STOP
              1011 REM WENN KEIN SYNTAX ERROR, WIRD
              1012 REM MELDUNG GEPRUEFT UND GEDRUCKT
              1020 IF ER=9 THEN PRINT EL,ERR$(ER):RESUME 100
              1030 IF ER=30 THEN RESUME 150
              1040 RESUME 975

              Die übrigen  zur  Fehlerverarbeitung benötigten   Anwei-
              sungen sind bei RESUME und TRAP beschrieben.

[SEITE 4-60]

FAST-Befehl

Format:       FAST

Zweck:        Schaltet  den  Prozessor vom Betrieb im 1-Megahertz-Takt
              auf Betrieb im 2-Megahertz-Takt   um.  Der Rechner  wird
              damit doppelt so schnell.

Bemerkungen:

              Der  40-Zeichen-Bildschirm   wird durch  den FAST-Befehl
              inaktiviert,  d.h.  Text-  oder  Grafikausgaben sind nur
              noch auf dem 80-Zeichen-Bildschirm sichtbar.

              Sollten Sie  ausschließlich einen  Fernsehempfänger oder
              einen  Monitor  mit  40-Zeichen-Darstellung    benutzen,
              schalten Sie  bitte vor  Ausgabe von Texten  oder Grafik
              mit dem Befehl  SLOW   (s.  dort) in  den  1-MHz-Betrieb
              zurück.

[SEITE 4-61]

FETCH-Befehl

Format:       FETCH Bytes,Intadr,Extadr,Bank

Zweck:        Überträgt  eine  wählbare   Anzahl  von  Bytes aus einer
              Speichererweiterungs-Bank in den BASIC-Arbeitsspeicher.

       Bytes  Ein  ganzzahliger Wert  zwischen  0 und  65535, der  die
              Anzahl der zu übertragenden Bytes angibt.

      Intadr  Ein  ganzzahliger Wert  zwischen  0 und  65535, der  die
              Adresse  im  BASIC-Arbeitsspeicher  angibt, ab  der  die
              Bytes abgelegt werden sollen.

      Extadr  Ein  ganzzahliger Wert  zwischen  0 und  65535, der  die
              Adresse  in der  Speicherbank angibt,  ab der  die Bytes
              geholt werden sollen.

        Bank  Ein  ganzzahliger  Wert  zwischen   0  und  7,  der  die
              Speicherbank  angibt, aus  der die  Bytes  geholt werden
              sollen.

Bemerkungen:  Dieser  Befehl  kann  nur ausgeführt  werden,  wenn eine
              RAM-Disk an den Rechner angeschlossen ist.  Die RAM-Disk
              decodiert den entsprechenden Befehl und führt ihn aus.

              Der Parameter Intadr bezieht sich auf  die Bank, die mit
              dem  BANK Befehl  eingestellt wurde.  Voreingestellt ist
              Bank 15.

              Sollen  z.B.  Daten aus  Bank  0 in  der RAM-Disk  abge-
              speichert werden,  so muß vor  dem STASH Befehl 'BANK 0'
              eingegeben werden.

Beispiel:     FETCH 1000,52000,2000,7

              Überträgt 1000 Bytes  aus Speicherbank 7 ab Adresse 2000
              in den BASIC-Arbeitsspeicher ab Adresse 52000.

+-------------------------------------------------------------------+
| Achtung:                                                          |
| Um diesen Befehl ausführen zu können, brauchen Sie das Steckmodul |
| RAM-Disk.                                                         |
+-------------------------------------------------------------------+

[SEITE 4-62]

FILTER-Anweisung

Format:       FILTER [Freq] [,[Tp] [,[Bp] [,[Hp] [,[Res]]]]]

Zweck:        Definiert die Parameter für Klangfilter.

        Freq  Ein  ganzzahliger  Wert zwischen  0  und  2047, der  die
              Filtergrenzfrequenz festlegt.

    Tp,Bp,Hp  Ein ganzzahliger  Wert von 0  oder 1, der  das Tiefpaß-,
              Bandpaß- oder  Hochpaß-Filter ein- (1)  oder ausschaltet
              (0).

         Res  Ein  ganzzahliger  Wert  zwischen  0  und  15,  der  die
              Resonanz festlegt.

Bemerkungen:  Bei nicht  angegebenen   Parametern bleibt der  aktuelle
              Wert gültig.

              Die   tatsächliche Filterfrequenz   errechnet sich   aus
                      GRENZFREQ=Freq*5.8 + 30
              Dieser Wert ist jedoch nur ein Anhaltswert und kann sich
              von Rechner zu Rechner geringfügig ändern.

              Die  Filterausgänge sind   additiv.   So  können   durch
              gemeinsame  Auswahl    von    Tief- und   Hochpaßfiltern
              Kerbfilter- oder Bandsperr- Effekte erzielt werden.

              Um hörbare Filtereffekte zu erzielen, muß mindestens ein
              Filter gewählt und mindestens eine Tonfrequenz durch das
              Filter geführt werden.

              Weitere  Einzelheiten zur FILTER-Anweisung entnehmen Sie
              bitte dem Abschnitt   "Musikerzeugung mit  dem  C128" ab
              Seite 4-162.

[SEITE 4-63]

FRE-Funktion

Format:       v=FRE(Bank)

Bedeutung:    Liefert   die    Anzahl  der    noch   nicht   benutzten
              Speicherplätze im BASIC-Programm- oder -Arbeitsspeicher.

        Bank  Ein ganzzahliger Wert von 0 oder 1, der die Speicherbank
              bezeichnet,  deren  ungenutzte Speicherplätze  abgefragt
              werden sollen.

Bemerkungen:  Wird FRE(1) aufgerufen,  so wird der Speicherbereich für
              Zeichenketten in  der Speicherbank  1    organisatorisch
              bereinigt,  ehe   die  Anzahl der  freien Speicherplätze
              übergeben wird.  Dieser Speicherbereich wird nämlich vom
              Interpreter  dynamisch   verwaltet, d.h.  Mehrfachzuwei-
              sungen von Zeichenketten  zu ein und derselben Variablen
              führen zu immer neuem Anlegen dieser Ketten im Speicher.

[SEITE 4-64]

GETKET-Anweisung

Format:       GETKEY Liste von Zeichenkettenvariablen

Zweck:        Die GETKEY-Anweisung ähnelt  der GET-Anweisung (s.  dort
              in Kapitel 5.2).  Sie  wartet jedoch so lange,  bis eine
              Taste auf der Tastatur gedrückt wird  und weist dann den
              ASCII-Code der gedrückten Taste als  1-Byte-Zeichenkette
              der   spezifizierten   Variablen   zu.  Werden   mehrere
              Zeichenkettenvariablen, getrennt durch Komma, angegeben,
              so müssen entsprechend viele Tasten betätigt werden.

              Liste von Zeichenkettenvariablen     Eine  oder mehrere,
              durch Komma getrennte, Zeichenkettenvariablen.

Bemerkungen:  Die   GETKEY-Anweisung   kann  nur    im  Programm-Modus
              verwendet werden.   Andernfalls wird  die  Fehlermeldung
              ILLEGAL DIRECT angezeigt.

Beispiele:    100 GETKEYA$,B$,C$

              Die   ASCII-Codes   von  drei  gedrückten  Tasten werden
              jeweils als 1-Byte-Zeichenkette den Variablen A$, B$ und
              C$ zugewiesen.

              100 GETKEY A$
              110 IF A$<"A" OR A$>"B" THEN 100
              120 ON ASC(A$)-64 GOTO 1000,2000

              Das Programm verzweigt   nur nach Zeile  1000 oder 2000,
              wenn entweder die Taste A oder B gedrückt wird.

[SEITE 4-65]

GO64-Befehl

Format:       GO64

Zweck:        Der Rechner   wird  vom  C128-Modus   in  den  C64-Modus
              umgeschaltet.

Bemerkungen:  Der Interpreter fordert durch die Anzeige

              ARE YOU SURE?

              vom Anwender  eine  Bestätigung für den Befehl.   Wird Y
              (Yes) eingegeben,   so  wird das momentan   im  Speicher
              befindliche  Programm  gelöscht und der Rechner  wird in
              den C64-Modus umgeschaltet.  Bei N (No) bleibt der C128-
              Modus aktiv, und es wird  am bestehenden Programm nichts
              verändert.

              Dieser  Befehl  kann  sowohl  im  Direkt-  als  auch  im
              Programm-Modus gegeben werden.

[SEITE 4-66]

GRAPHIC-Anweisung

Formate:      GRAPHIC Modus [,[Lösch], Textz]
              GRAPHIC CLR

Zweck:        Aktiviert Grafikmodus und reserviert Grafikspeicher (bit
              mapped) bzw. gibt Grafikspeicher wieder frei.

       Modus  Ein ganzzahliger Wert zwischen 0 und 5.   Folgende  Modi
              sind wählbar:

              0  Text mit 40 Zeichen/Zeile

              1  hochauflösende Grafik (320x200 Punkte)

              2  hochauflösende Grafik,
                 geteilter Bildschirm für Grafik und Text

              3  Mehrfarbengrafik (160x200 Punkte)

              4  Mehrfarbengrafik,
                 geteilter Bildschirm für Grafik und Text

              5  Text mit 80 Zeichen/Zeile

       Lösch  Ein ganzzahliger Wert von 0 oder 1, der bestimmt, ob der
              Bildschirm beim  Aufruf der Grafikmodi 1  bis 4 gelöscht
              werden soll (1) oder nicht (0).

       Textz  Ein  ganzzahliger Wert zwischen  0 und  24, der  bei den
              Modi  2 und  4 die  Zeile  festlegt, bei  der der  Text-
              Teilbildschirm beginnt. Voreingestellt ist hier 19.

              GRAPHIC CLR gibt  den durch  die GRAPHIC Modus-Anweisung
              reservierten Speicher wieder frei.

Bemerkungen:  Im Kapitel   4.7 werden  hochauflösende  und Mehrfarben-
              grafik ausführlich beschrieben.

              Bei den Modi 1 bis 4 wird ein 9-KByte-Speicherbereich am
              Anfang des  BASIC-Programmspeichers  als  Grafikspeicher
              reserviert.  Der Beginn des BASIC-Programmspeichers wird
              dadurch nach oben verschoben.

[SEITE 4-67]

              Dieser  Bereich bleibt auch  reserviert, wenn wieder der
              Text-Modus (1 oder  5) eingeschaltet wird  und wird erst
              durch die GRAPHIC CLR-Anweisung wieder freigegeben.

Beispiele:    GRAPHIC 1

              Schaltet auf hochauflösende Grafik um.

              GRAPHIC 4,1,15

              Schaltet auf  Mehrfarbengrafik  mit geteiltem Bildschirm
              und  setzt den   Anfang des   Textschirms  auf Zeile  16
              (Zeilen beginnen mit 0).

              GRAPHIC CLR

              Der reservierte Grafikspeicher wird wieder freigegeben.

[SEITE 4-68]

GSHAPE-Anweisung

Format:       GSHAPE Zeikett [,[x,y[,Modus]]]

Zweck:        Überträgt  den Wert einer  angegebenen Zeichenkette  als
              binäre  Bildinformation  auf den Grafik-Bildschirm (s.a.
              MOVSPR-Anweisung).

     Zeikett  Eine  Zeichenkettenvariable  oder  -konstante,  die  die
              abzubildende  Bildinformation binär enthält  (s. SSHAPE-
              Anweisung).

         x,y  Die  skalierten Bildschirmkoordinaten der  linken oberen
              Ecke des darzustellenden Bildes.

       Modus  Ein ganzzahliger Wert zwischen 0  und 4, der die Art der
              Darstellung bestimmt.  Folgende Modi sind verfügbar:

              0  Die Daten aus  der Zeichenkette werden genau  so, wie
                 sie mit SSHAPE gespeichert wurden, abgebildet.
              1  Das Bild wird invertiert.
              2  Dem auf dem  Schirm vorhandenen Bild  wird  die Bild-
                 information aus  der Zeichenkette  überlagert  (logi-
                 sches ODER).
              3  Es werden nur dann  Bildpunkte übertragen, wenn unter
                 den zu  übertragenden Bildpunkten bereits  Bildpunkte
                 auf dem Schirm existieren (logisches UND).
              4  Es werden im existierenden  Bild  dort die Bildpunkte
                 invertiert,  wo  im zu  übertragenden Bild Bildpunkte
                 existieren.  Dadurch  kann ein Objekt über  den Bild-
                 schirm  bewegt   werden,   ohne  den  Hintergrund  zu
                 löschen.

[SEITE 4-69]

HEADER-Befehl

Format:       HEADER Name,DLaufwerk[,IKennung][,UGerät]

Zweck:        Formatiert  eine  Diskette im  angegebenen  Laufwerk der
              gewählten  Floppy-Disk  neu  oder  löscht  das  Inhalts-
              verzeichnis (s.a. Kapitel 6.1).

        Name  Eine  Zeichenkettenkonstante  in  Anführungszeichen  (")
              oder eine -variable einer  Länge von maximal 16 Zeichen,
              die den Namen der Diskette bezeichnet.

    Laufwerk  Ein ganzzahliger  Wert von 0  oder 1 für  die Laufwerks-
              bezeichnung. 0 ist voreingestellt.

     Kennung  Zwei beliebige Zeichen  für die Diskettenkennung.  Diese
              Kennung  wird  bei  der  Formatierung  in  jeden  Sektor
              eingetragen.   Für jede  Diskette sollte  unbedingt eine
              eigene Kennung vergeben werden.

              ACHTUNG
              Wegen  der   besonderen  Art  und  Weise,   in  der  der
              Interpreter   die   Floppy-Disk-Befehle   interpretiert,
              dürfen   für   den   Parameter  Kennung   keine   BASIC-
              Schlüsselworte wie ON, FN, TO usw.  oder Abkürzungen von
              Schlüsselworten  wie  aB,  c)  usw.   verwendet  werden.
              Andernfalls  wird die  Fehlermeldung SYNTAX  ERROR ange-
              zeigt.

       Gerät  Ein  ganzzahliger  Wert  zwischen   4  und  15  für  die
              Geräteadresse  der angeschlossenen  Floppy-Disk.   8 ist
              voreingestellt.

Bemerkungen:  Da  bei  der Formatierung  alle  ggfs.   vorher auf  der
              Diskette gespeicherten  Daten zerstört werden,  wird der
              Anwender durch die Anfrage

              ARE YOU SURE?

              um Bestätigung  gebeten.  Die Antwort  Y (Yes) führt den
              HEADER-Befehl aus, jede andere nicht.

[SEITE 4-70]

              Soll  eine  bereits  formatierte  Diskette  nur gelöscht
              werden, wird beim  HEADER-Befehl der Parameter  IKennung
              weggelassen. Die  Diskette  erhält  dann nur  den  neuen
              Namen, behält aber die alte Kennung.

              Werden  als  Parameter  Variablen verwendet,  so  müssen
              diese in Klammern gesetzt werden.

Beispiele:    HEADER "DATEN",D0,IDA

              Die  Diskette in  Laufwerk  0  der  Floppy-Disk  mit der
              Geräteadresse 8  wird mit der  Kennung DA neu formatiert
              und erhält den Namen DATEN.

              HEADER "PROGRAMME",IP1,D1,U9

              Die Diskette  im  Laufwerk  1  der Floppy-Disk  mit  der
              Geräteadresse 9 wird  mit der Kennung  P1 neu formatiert
              und erhält den Namen PROGRAMME.

              HEADER (N$),I(K$),D(L),U(G)

              Hier werden für alle Parameter Variablen verwendet.

              HEADER "STAMMDATEN",D0

              Die  Diskette  in Laufwerk  0   der Floppy-Disk  mit der
              Geräteadresse 8  wird  nur  gelöscht, erhält  den  Namen
              STAMMDATEN und behält ihre alte Kennung bei.

[SEITE 4-71]

HELP-Befehl

Format:       HELP

Zweck:        Zeigt  nach  einer  Fehlermeldung des  Interpreters  die
              fehlerhafte  Programmzeile  auf  dem Bildschirm  an  und
              stellt den fehlerhaften Teil invers beim 40-Zeichen- und
              unterstrichen     beim     80-Zeichen-Bildschirm     dar
              (s.a. HELP-Taste in Kapitel 4.1).

Bemerkungen:  Der HELP-Befehl  (oder Drücken  der HELP-Taste) hat  bei
              Fehler,  die bei im Direktmodus eingegebenen Anweisungen
              diagnostiziert werden, keine Wirkung.

[SEITE 4-72]

HEX$-Funktion

Format:       v$=HEX$(n)

Zweck:

              Liefert   eine   Zeichenkette,  die   die   hexadezimale
              Darstellung  des   Wertes des  numerischen  Ausdruckes n
              enthält.

           n  Beliebiger  numerischer  Ausdruck,  dessen  ganzzahliger
              Wert gewandelt wird und zwischen 0 und 65535 liegen muß.

Beispiel:     100 X=23:Y=1456
              110 PRINTX;HEX$(X),Y;HEX$(Y)
              RUN
              23 17    1456 5B0
              READY.

[SEITE 4-73]

IF-Anweisung

Format:       IF Ausdr THEN Anw [:ELSE Anw]

Zweck:        Erlaubt  die Verzweigung in  verschiedene Programmteile,
              abhängig vom logischen Wahrheitsgehalt eines numerischen
              Ausdruckes.    Ein  numerischer  Ausdruck   ist  logisch
              "wahr",  wenn sein  Wert  von Null  verschieden ist  und
              logisch "falsch", wenn sein Wert 0 ist.

       Ausdr  Jeder beliebige numerische Ausdruck.

         Anw  Eine  einzelne  Anweisung,  eine Folge  von  Anweisungen
              durch  Doppelpunkte  voneinander  getrennt oder  einfach
              eine Zeilennummer.

Bemerkungen:  Ist  der  numerische Ausdruck  logisch  "wahr", so  wird
              (werden) die Anweisung(en)  hinter THEN ausgeführt.  Ist
              er  dagegen  logisch  "falsch",  so  wird  (werden)  die
              Anweisung(en)    hinter   THEN    ignoriert    und   die
              Anweisung(en)  hinter ELSE,  falls  vorhanden, oder  die
              nächste Programmzeile ausgeführt.

              Beim Test auf  Gleichheit muß die Ungenauigkeit aufgrund
              der    internen   Gleitkommadarstellung   berücksichtigt
              werden.  In kritischen Fällen sollte der Test über einen
              Bereich  erfolgen, innerhalb  dessen Grenzen  die Genau-
              igkeit  schwankt.  Z.B.   liefert  IF ABS(X-2.5)<1.06E-6
              THEN...   das  Ergebnis  "wahr",  wenn X=2.5  mit  einem
              relativen Fehler von weniger als 1.06E-6 ist.

              Die IF...THEN...:ELSE-Anweisung  muß in einer  Programm-
              zeile stehen. Weder THEN  noch ELSE dürfen  in separaten
              Zeilen stehen, es sei denn, es wird eine BEGIN-Anweisung
              in  die   IF eingefügt  (s.   Beispiel 2  bei der BEGIN-
              Anweisung).

              Ist die Anzahl  von  THEN- und  von ELSE-Angaben  unter-
              schiedlich, so  bezieht  sich ELSE immer  auf das letzte
              davorstehende THEN.

[SEITE 4-74]

Beispiel 1:   100 NMSG$="DER WERT MUSS POSITIV SEIN"
              110 PMSG$="DIE WURZEL IST"
              120 INPUT"BITTE ZAHL EINGEBEN";N
              130 IF N<0 THEN PRINT NMSG$:GOTO120:ELSE PRINT
                  PMSG$;SQR(N)
              140 INPUT"NOCH EINE ZAHL (J/N)";Z$
              150 IF Z$="J" THEN 120:ELSE END

              Es wird  die  Wurzel einer  eingegebenen Zahl  nur  dann
              ermittelt und gedruckt, wenn die Zahl positiv ist.

Beispiel 2:   100 IF X>Y THEN PRINT"GROESSER":ELSE IF Y<X THEN
                  PRINT"KLEINER":ELSE PRINT "GLEICH"

              Dies ist ein Beispiel für verschachtelte IF-Anweisungen.

Beispiel 3:   100 IF A=B THEN IF B=C THEN PRINT"A=C":ELSE PRINT"A<>C"

              Falls A ungleich B ist, wird  der zweite Vergleich nicht
              mehr ausgeführt.

[SEITE 4-75]

INSTR-Funktion

Format:       v=INSTR(x$,y$[,n])

Zweck:        Sucht und liefert die Position des ersten Auftretens der
              Teilzeichenkette y$ in x$.

          x$  Beliebiger  Zeichenkettenausdruck,  dessen  Wert die  zu
              durchsuchende Zeichenkette darstellt.

          y$  Beliebiger   Zeichenkettenausdruck,   dessen  Wert   die
              gesuchte Teilzeichenkette darstellt.

           n  Ein  numerischer   Ausdruck,  dessen  ganzzahliger  Wert
              zwischen 1 und 255  liegen muß und der die Startposition
              in der  zu durchsuchenden Zeichenkette  angibt.  Vorein-
              gestellt ist hier 1.

Bemerkungen:  In den folgenden Fällen liefert INSTR den Wert 0:

              n  ist größer als LEN(x$)
              x$ ist leer
              y$ ist nicht in x$ enthalten

Beispiel:     PRINT INSTR("COMMODORE","R")
              8
              READY.
[SEITE 4-76]

JOY-Funktion

Format:       v=JOY(n)

Zweck:        Liefert  einen Wert  für die Position  sowie den Zustand
              des Feuerknopfes eines wählbaren Joysticks (Spielpult).

           n  Ein ganzzahliger Wert von  1 oder 2, der den gewünschten
              Joystick bezeichnet.

              Der  von der JOY-Funktion  übergebene Wert  hat folgende
              Bedeutung:

              0  Mittelstellung
              1  nach vorn
              2  nach diagonal rechts vorn
              3  nach rechts
              4  nach diagonal rechts hinten
              5  nach hinten
              6  nach diagonal links hinten
              7  nach links
              8  nach diagonal links vorn

              Werte  von  128 bis  136  bedeuten,  daß zusätzlich  der
              Feuerknopf gedrückt wurde.

Beispiel:     PRINT JOY(2)
              135
              READY.

              Joystick  2  steht  bei  gedrücktem  Feuerknopf  in  der
              Stellung nach links.

[SEITE 4-77]

Format:       KEY [n,x$]

Zweck:        Belegt Funktionstasten neu oder zeigt deren Belegung an.

           n  Beliebiger  numerischer  Ausdruck,  dessen  ganzzahliger
              Wert  zwischen   1  und  8  liegen  muß   und  der  eine
              Funktionstaste bezeichnet.

          x$  Beliebiger   Zeichenkettenausdruck,   dessen  Wert   der
              gewählten  Funktionstaste zugeordnet  wird  und der  bei
              Betätigen  dieser  Taste  auf dem  Bildschirm  angezeigt
              wird.

Bemerkungen:  Wird der  KEY-Befehl  ohne Paramater gegeben, so  werden
              die   augenblicklichen  Belegungen  auf  dem  Bildschirm
              angezeigt.

              Die  Länge aller 8 Belegungen  zusammen darf 256 Zeichen
              nicht überschreiten.

Beispiel:     KEY 8,"GRAPHIC0"+CHR$(13)+"LIST"+CHR$(13)

              Wenn  Funktionstaste  f8 (die  vierte Taste zusammen mit
              SHIFT) im  Direktmodus gedrückt wird, wird der Textmodus
              eingeschaltet  und   das im  Hauptspeicher   befindliche
              Programme wird gelistet.

[SEITE 4-78]

LOCATE-Anweisung

Format:       LOCATE x,y

Zweck:        Positioniert  den  grafischen Cursor  (Pixel-Cursor) auf
              dem Bildschirm.

         x,y  Skalierte  Koordinaten  (s.a.  SCALE-Anweisung).  Für  x
              (horizontale   Koordinate)    und   für   y   (vertikale
              Koordinate) dürfen  je nach Skalierung  Werte zwischen 0
              und 1023 angegeben werden.

Bemerkungen:  Im Gegensatz  zum normalen Text-Cursor ist der grafische
              Cursor nicht sichtbar.

              Die aktuelle  Position des  grafischen Cursors  ist  für
              alle grafischen Zeichenanweisungen die Ausgangsposition.

              Nach der  Ausführung  einer  grafischen Zeichenanweisung
              ist der  letzte gezeichnete  Bildpunkt die neue aktuelle
              Position des grafischen Cursors.

              Die aktuelle Position  des  grafischen Cursors kann  mit
              Hilfe der RDOT-Funktion (s. dort) gefunden werden.

Beispiel:     LOCATE160,100

              Der grafische Cursor wird auf  die Mitte des Bildschirms
              (hohe Auflösung, keine Skalierung) positioniert.

[SEITE 4-79]

MONITOR-Befehl

Format:       MONITOR

Zweck:        Der Maschinensprache-Monitor wird aufgerufen.

Bemerkungen:  Funktionen und Bedienung  des Monitors sind  ausführlich
              im Anhang C beschrieben.

[SEITE 4-80]

MOVSPR-Anweisung

Format:       MOVSPR n,x,y
              MOVSPR n,+/-x1,+/-y1
              MOVSPR n,Winkel#Geschw

Zweck:        Bewegt  ein  Sprite  mit einer spezifizierten  Geschwin-
              digkeit oder  plaziert  ein Sprite  an einer  bestimmten
              Stelle auf dem Bildschirm.

           n  Ein ganzzahliger  Wert zwischen 0 und 7,  der die Nummer
              für das Sprite angibt.

         x,y  Die  absoluten, skalierten  Koordinaten,  bei denen  das
              Sprite positioniert werden soll.

      +/-x1,  Die   zur   letzten   Sprite-Positionierung   relativen,
      +/-y1   skalierten    Koordinaten,   bei   denen    das   Sprite
              positioniert werden soll.

      Winkel  Ein ganzzahliger Wert zwischen 0 und 360, der angibt, in
              welchem  Winkel  das  Sprite von  seiner  ursprünglichen
              Position wegbewegt werden soll.

      Geschw  Ein  ganzzahliger  Wert  zwischen  0  und  15,  der  die
              Geschwindigkeit angibt, mit der das Sprite bewegt werden
              soll.

Bemerkungen:  Die Anwendung der  MOVSPR-Anweisung ist ausführlich  und
              an vielen Beispielen in Kapitel 4.7 beschrieben.

[SEITE 4-81]

PAINT-Anweisung

Format:       PAINT [Farbquelle] [,[x,y][,Modus]]

Zweck:        Malt einen Bildschirmbereich  mit einer wählbaren  Farbe
              aus.

  Farbquelle  Ein ganzzahliger  Wert zwischen 0  und 3, der  die Farbe
              definiert,  mit der der  Bereich ausgemalt  werden soll.
              Voreingestellt   ist  die   Vordergrundfarbe   (1).   Es
              bedeuten:

              0  Hintergrundfarbe
              1  Vordergrund- (Zeichen-)Farbe
              2  Zusatzfarbe 1
              3  Zusatzfarbe 2

         x,y  Koordinaten   (skaliert)  des   Startpunktes   zum  Aus-
              malen. Voreingestellt ist hier die aktuelle Position des
              grafischen Cursors (Pixel-Cursor).

       Modus  Ein ganzzahliger Wert von 0 oder 1, der festlegt, ob der
              auszumalende  Bereich von der  gewählten Farbe  (0) oder
              einer anderen Farbe als der Hintergrundfarbe umgeben ist
              (1).

Bemerkungen:  Die PAINT-Anweisung  füllt  solange  den Bereich um  den
              angegebenen Punkt, bis ein Rand in der angegebenen Farbe
              (Modus 0) oder  einer anderen  als der  Hintergrundfarbe
              erreicht ist.

              Die  Endposition   des  grafischen    Cursors  ist   das
              angegebene Koordinatenpaar x,y.

              Wenn der  Startpunkt  bereits die  angegebene Farbe beim
              Modus  0  bzw.   irgendeine   von der   Hintergrundfarbe
              verschiedene Farbe  beim Modus  1  hat, hat  der  Befehl
              PAINT keine Wirkung.

Beispiel:     10 CIRCLE,160,100,65,50
              20 PAINT,160,100

              Der in  Zeile 100 gezeichnete  Kreis wird in der Vorder-
              grundfarbe (Voreinstellung) ausgemalt.

[SEITE 4-82]

PEN-Funktion

Format:       v=PEN(n)

Zweck:        Liefert  den  Zustand oder die Bildschirmkoordinaten des
              Lichtstiftes.

           n  Ein  ganzzahliger Wert  zwischen 0  und 4,  der folgende
              Wirkung hat:

              0  x-Koordinate der Lichstiftposition auf dem grafischen
                 Bildschirm (60 bis 320).
              1  y-Koordinate der Lichstiftposition auf dem grafischen
                 Bildschirm (50 bis 200)
              2  Zeichen-Spaltenposition  des   Lichstiftes   beim 80-
                 Zeichen-Bildschirm.
              3  Zeichen-Zeilenposition  des  Lichtstiftes  beim   80-
                 Zeichen-Bildschirm.
              4  Es wird 1  übergeben, falls  der Lichtstift  seit der
                 letzten Abfrage aktiviert wurde, andernfalls 0.

Bemerkungen:  Wie  bei  den  Sprite-Koordinaten  sind  die Lichtstift-
              koordinaten nicht  skaliert, sondern   echte Koordinaten
              innerhalb des umrahmten Bildschirmbereiches.

              Liegt  die  Lichtstiftposition  außerhalb des   gültigen
              Bildschirmbereiches, sind die  übergebenen  Koordinaten-
              werte 0.

              Für die  PEN-Funktion braucht  die   COLLISION-Anweisung
              nicht aktiviert zu werden.

              Im allgemeinen ist für die Stimulierung des Lichtstiftes
              ein weißer Bildschirmhintergrund erforderlich.

              Die von  der PEN-Funktion  übergebenen Werte  können von
              Bildschirm zu Bildschirm unterschiedlich sein.

Beispiel:     100 DO UNTIL PEN(4):LOOP
              110 PRINT PEN(2);PEN(3)

              Sobald der  Lichtstift aktiviert wird, wird die Spalten-
              und Zeilen-Position des Bildschirmzeichens gedruckt, bei
              dem er aufgesetzt wurde.

[SEITE 4-83]

{PI}-Funktion (Anm. d. E-Texters:    Das  {PI}-Symbol  entsteht  durch
               gleichzeitiges Drücken von SHIFT und ^)

Format:       v={PI}

Zweck:        Übergibt den Wert der Ludolfschen Zahl (3.14159265).

Beispiel:     PRINT COS({PI})
              -1
              READY.

[SEITE 4-84]

PLAY-Anweisung

Format:       PLAY Zeichenkette

Zweck:        Spielt die  mit   Hilfe einer   Zeichenkette  definierte
              Tonfolge.

    Zeichen-  Eine  Zeichenkette in  Anführungszeichen,  die sich  aus
      kette   Tonerzeugungs-  und  Abspielbefehlen zusammensetzt.   Es
              gibt folgende Befehle:

              On  Setzt eine von  Oktaven (n=0 bis n=6)

              Tn  Setzt eine der folgenden 10 Klanghüllkurven:

                  0 Klavier (voreingestellt)
                  1 Akkordeon
                  2 Zirkusorgel
                  3 Trommel
                  4 Flöte
                  5 Gitarre
                  6 Cembalo
                  7 Orgel
                  8 Trompete
                  9 Xylophon

              Un  Setzt die Lautstärke (n von 0 bis 9)

              Vn  Setzt eine von 3 möglichen Stimmen.

              Xn  Schaltet das mit  der FILTER-Anweisung (s. dort) ge-
                  wählte Filter ein (n=1) oder aus (n=0).

              N   Eine der Noten A B C D E F G

              #N  Es wird die Note N einen Halbton höher gespielt.

              $N  Es wird die Note N einen Halbton tiefer gespielt.

              W   Die folgende Note wird als ganze Note gespielt.

              H   Die folgende Note wird als halbe Note gespielt.

[SEITE 4-85]

              Q   Die folgende Note wird als viertel Note gespielt.

              I   Die folgende Note wird als achtel Note gespielt.

              S   Die folgende Note wird als sechzehntel Note gespielt.

              .N  Die folgende Note  wird   als punktierte Note   (die
                  Hälfte  ihres Wertes) gespielt.

              R   Setzt eine Pause.

              M   Wartet,  bis die gegenwärtig  gespielte Musik zuende
                  ist.

[SEITE 4-86]

POINTER-Funktion

Format:       v=POINTER(Variable)

Zweck:        Liefert die  Hauptspeicheradresse des ersten Bytes eines
              Variablenzeigers  in  der  Speicherbank  1, in  der  der
              BASIC-Interpreter  alle Variablen,   Felder und Zeichen-
              ketten ablegt.

    Variable  Eine  beliebige  Variable   oder  ein  beliebiges  Feld-
              variablenelement,  der/dem bereits  ein  Wert zugewiesen
              sein muß.

Bemerkungen:  Die übergebene   Adresse im Bereich   0 bis 65535 stellt
              einen Offset in der Speicherbank 1 des Interpreters dar.

              Wird POINTER   für   ein Feldvariablenelement verwendet,
              sollten  alle einfachen Variablen vorher definiert sein,
              damit sich die Feldelementadressen nicht bei jeder neuen
              Definition einer einfachen Variablen wieder verändern.

              POINTER  ist   nützlich,   um  die  Anfangsadressen  für
              Variablendeskriptoren an Maschinensprache-Unterprogramme
              zu übergeben.

Beispiel:     100 BX%=1024
              110 VP=POINTER(BX%)
              120 BANK1:AX=256*PEEK(VP)+PEEK(VP+1)

              Die Daten, die  in der Ganzzahlvariablen BX% gespeichert
              sind, werden in Zeile 120 gelesen.

[SEITE 4-87]

POT-Funktion

Format:       v=POT(n)

Zweck:
              Liefert  die  Position eines der  4 anschließbaren Dreh-
              regler (paddles).

           n  Ein ganzzahliger  Wert zwischen 1  und 4, der  den Dreh-
              regler definiert.

              1  Drehregler 1
              2  Drehregler 2
              3  Drehregler 3
              4  Drehregler 4

Bemerkungen:  Der von der POT-Funktion übergebene Wert kann zwischen 0
              und 255 liegen.  Ein um 256  erhöhter Wert bedeutet, daß
              außerdem der Feuerknopf gedrückt wurde.

[SEITE 4-88]

PRINT USING-Anweisung

Format:       PRINT [#Filenr] USING v$; Liste von Ausdrücken[;]

Zweck:
              Gibt die Werte  von Liste von  Ausdrücken auf dem  Bild-
              schirm oder einem Ausgabegerät formatiert aus.

      Filenr  Die Nummer,  unter der  eine Datei für  ein Ausgabegerät
              eröffnet wurde. Bei Nummern  zwischen 1 und 127 wird den
              ausgegebenen  Daten   ein  Wagenrücklaufcode  (CHR$(13))
              angefügt.  Bei  Nummern zwischen 128  und 255 zusätzlich
              noch ein Zeilenvorschubcode (CHR$(10)).

          v$  Eine  Zeichenkettenvariable  oder  -konstante,  die  das
              Druckformat definiert (s. Beispiele).

       Liste  Eine beliebige  Liste von numerischen  und/oder Zeichen-
         von  kettenausdrücken, deren  Werte ausgegeben werden sollen.
  Ausdrücken  Die  einzelnen  Ausdrücke   müssen  durch  Komma  (,)  ,
              Semikolon  (;)   oder  eine  oder   mehrere  Leerstellen
              voneinander getrennt sein.  Die Formatierung der Ausgabe
              erfolgt durch Steuerzeichen,  deren Wirkung im folgenden
              getrennt für Zeichenketten-  und numerische Daten anhand
              von Beispielen  beschrieben wird.  Hier  führt das Komma
              nach einem Ausdruck jedoch nicht zur Tabulierung auf den
              Anfang des nächsten 10 Zeichen langen Druckfeldes.

              Zeichenketten-Druckfelder

              #  Jedes  Nummernzeichen  im  Formatfeld steht  für  ein
              Zeichen im  Druckfeld.  Jedes Formatfeld  muß mindestens
              ein Nummernzeichen  enthalten.  Hat der  Wert eines Zei-
              chenkettenausdruckes mehr Zeichen als Druckstellen mit #
              definiert  sind,  wird  die Zeichenkette  abgeschnitten,
              andernfalls wird mit  Leerzeichen aufgefüllt.  Die Daten
              werden linksbündig im Feld ausgedruckt.

[SEITE 4-89]

              =  Die  normalerweise  linksbündig  im  Druckfeld  ange-
              zeigten Daten werden zentriert angezeigt.

              >  Die Daten werden rechtsbündig im Druckfeld angezeigt.

              Numerische Druckfelder

              #   Hat der  Wert eines numerisch Ausdruckes mehr Druck-
              stellen als Positionen  mit #  definiert sind, wird  das
              Druckfeld  mit Sternen (*)   gefüllt,  hat  er  weniger,
              werden links    Leerstellen   aufgefüllt, da   die Daten
              rechtsbündig gedruckt werden.

              + und -    Plus-  oder Minus-Zeichen können entweder  an
              erster  oder   letzter  Stelle  der   Formatzeichenkette
              stehen.  Das  Vorzeichen  des  auszugebenden Wertes wird
              dann an der Stelle gedruckt.

              .     Legt die Dezimalpunktposition  in  einer  Zahl mit
              Dezimalstellen  fest.  In jeder Formatzeichenkette  darf
              nur ein Dezimalpunkt vorkommen.

              ,    Legt  die Position  fest, an  der im Druckfeld  ein
              Komma ausgegeben  werden soll.  Dem Komma muß mindestens
              ein  #-Symbol in  der  Formatzeichenkette  vorangestellt
              sein.   Das  Komma ist  kein Dezimalkomma, sondern dient
              nur der besseren Lesbarkeit von großen Zahlen.

              $     Immer vor  der  ersten gültigen  Ziffer der auszu-
              gebenden Zahl wird ein Dollar-Zeichen gedruckt, wenn vor
              dem  Dollar-Zeichen in   der  Formatkette  ein  #-Symbol
              steht.

              ^^^^   Wenn  die Formatzeichenkette mit  vier ^-Symbolen
              endet, denen außerdem noch ein  + oder - folgt, wird die
              darzustellende Zahl im Exponentialformat gedruckt.

[SEITE 4-90]

              Die folgende Tabelle  enthält eine Reihe  von Beispielen
              für die Verwendung der PRINT USING-Anweisung:


Format     Ausdruck   Ergebnis      Bemerkungen

+##        1          + 1           Leerstelle zwischen Vorzeichen und Zahl
#.##+      -.01       0.01-         Führende Null hinzugefügt
-.##       -.1        -.10          Führende Null durch Minus überschrieben
##.#-      1          1.0           Folgende Null hinzugefügt
+##+       1          SYNTAX ERROR  Zwei Plus-Symbole
+##.#-     1          SYNTAX ERROR  Plus- und Minus-Symbole
####       -100.5     -101          Auf insgesamt 4 Stellen gerundet
####       -1000      ****          Überlauf, weil Feld nur für 4 Zeichen
#.##       -4E-03     -.00          Auf insgesamt 4 Stellen gerundet
##.        10         10.           Dezimalpunkt hinzugefügt
#.#.       1          SYNTAX ERROR  Zwei Dezimalpunkte
###,##     100        1,00          Kein Dezimalkomma, wie im Deutschen
##,##      10.4       10            Gerundet und Komma unterdrückt

#,###.##   10000.009  1,000.01      Gerundet
##,##      -1         -1            Komma unterdrückt
##,##      -10        -10           Komma wird von Minus überschrieben

##,##      -100.9     -1,01         Gerundet
##=>.>     1000       1000.0        = und < werden als # interpretiert, weil
                                    sie im Zahlenfeld stehen
+>==,#     1          +>==,1        Vor dem Komma muß mindestens ein # stehen,
                                    sonst werden >, = und Komma als druckbare
                                    Zeichen interpretiert
+>=#,#     1          + 1           > und = werden als # interpretiert, weil
                                    sie im Zahlenfeld stehen

#$##       1          $1            Führendes $-Zeichen
###$       -1         -$1           Vorzeichen steht vor dem $
##$##      -1         -$1           Vorzeichen steht vor dem $
###$-      -1         $1-           Vorzeichen steht am Ende

[SEITE 4-91]

Format     Ausdruck   Ergebnis      Bemerkungen

+$###      -1         +$-1          Vor dem $ muß mindestens ein # stehen,
                                    sonst wird + als druckbares Zeichen
                                    interpretiert
+#$##      -1         -$1
#.#$#      1          *****         Überlauf, weil kein Platz für $ vorhanden
+#.#^^^^   1          +1.0E+00      Ausdruck in Exponentialdarstellung
#^^^+      -340       3E+02-        Vorzeichen hinter der Zahl
#^^^^      1.5E+11    2E+11         Gerundet
#^^^^      -1.5E+11   *****         Überlauf, weil kein Platz für das
                                    Vorzeichen
##.##^^^^  100000     10.00E+04
##.##^^^^  -100000    -1.00E+05
##^^^      1          SYNTAX ERROR  Nur 3 Pfeile
##^^^^^    34         34E+00^       Der fünfte Pfeil wird als druckbares
                                    Zeichen interpretiert
##.##      CBM        CBM           Linksbündig gedruckter Text
###>#      CBM        CBM           Rechtsbündig in einem 5-Zeichen-Druckfeld
#####      CBM        CBM           Linksbündig in einem 5-Zeichen-Druckfeld
=####      CBM        CBM           Zentriert in einem 5-Zeichen-Druckfeld
#,$#=+     CBM        CBM           Wie oben, weil die anderen Zeichen als
                                    Druckzeichen interpretiert werden

[SEITE 4-92]

PUDEF-Anweisung

Format:       PUDEF v$

Zweck:        Erlaubt die Umdefinition von  bis zu vier  verschiedenen
              Steuerzeichen in der PRINT USING-Anweisung.

          v$  Eine  Zeichenkettenkonstante  in  Anführungszeichen  (")
              oder -variable,  deren Wert bis  zu 4 Zeichen  lang sein
              darf.  Die  Position dieser Zeichen  in der Zeichenkette
              steht  für   ein  bestimmtes  Steuerzeichen   der  PRINT
              USING-Anweisung. Es gilt:

              Pos. 1    Füllzeichen. Voreingestellt ist hier das Leer-
                        zeichen.

              Pos. 2    Komma. Voreingestellt ist ebenfalls das Komma.

              Pos. 3    Dezimalpunkt. Voreingestellt ist ebenfalls der
                        Dezimalpunkt.

              Pos. 4    Dollarzeichen.  Voreingestellt  ist  ebenfalls
                        das Dollarzeichen.

Bemerkungen:  PUDEF ändert  die  Zeichen nur,  wenn eine  PRINT USING-
              Anweisung  zur  Ausgabe  verwendet  wird.  Bei PRINT hat
              PUDEF keine Wirkung.

              PUDEF  beeinflußt nur  die  Ausgabe  selbst,  nicht  die
              Formatzeichenkette von PRINT USING.

[SEITE 4-93]

Beispiel 1:   PUDEF"?"

              Leerstellen  werden  beim Ausdruck   durch  Fragezeichen
              ersetzt.

Beispiel 2:   10 PUDEF".,"
              20 PRINT USING "###,###.##";-1234,567
              RUN
              -1.234,57
              READY.

              Das Komma in der  Tausenderposition und der Dezimalpunkt
              (amerikanische   Schreibweise)   werden  in die deutsche
              Schreibweise umgewandelt.

[SEITE 4-94]

RCLR-Funktion

Format:       v=RCLR(n)

Zweck:        Liefert  den der  angegebenen Farbquelle    zugeordneten
              aktuellen   Farbcode   im  Bereich  zwischen   1  und 16
              (s. a. COLOR-Anweisung).

           n  Ein ganzzahliger  Wert zwischen 0  und 6, der  die Farb-
              quelle angibt. Folgende Farbquellen sind verfügbar:

              0  Hintergrund (40-Zeichen-Anzeige)
              1  grafischer Vordergrund
              2  Mehrfarbenmodus 1
              3  Mehrfarbenmodus 2
              4  Rand (40-Zeichen-Anzeige)
              5  Text (80-Zeichen-Anzeige)
              6  Hintergrund (80-Zeichen-Anzeige)

Beispiel:     A=RCLR(4)

              Der aktuelle Farbcode  für  den Bildschirmrand wird  der
              Variablen A zugewiesen.

[SEITE 4-95]

RDOT-Funktion

Format:       v=RDOT(n)

Zweck:        Liefert die aktuelle Bildschirm-Position des  grafischen
              Cursors (Pixel-Cursor)  oder den  für die aktuelle Posi-
              tion gültigen Code der Farbquelle.

           n  Ein  ganzzahliger Wert  zwischen 0  und 2  mit folgender
              Bedeutung:

              0  x-Position
              1  y-Position
              2  Farbquell-Code bei aktueller Position

Beispiel:     10 GRAPHIC1,1
              20 CIRCLE1,160,100,80,80
              30 DRAW TO RDOT(0),180

              Zeichnet einen Kreis mit senkrechtem Durchmesser.


[SEITE 4-96]

RECORD-Anweisung

Format:       RECORD #Filenr,Satznr[,Bytenr]

Zweck:        Positioniert den  Schreib-/Lese-Zeiger auf eine wählbare
              Position    innerhalb   einer    Disketten-Relativ-Datei
              (s. a. Kapitel 6.7).

      Filenr  Die logische Nummer im Bereich zwischen 1 und 255, unter
              der die Disketten-Relativ-Datei eröffnet wurde.

      Satznr  Ein  ganzzahliger Wert  zwischen  1 und  65535, der  den
              logischen  Datensatz in  der  Diskettendatei bezeichnet,
              auf den zugegriffen werden soll.

      Bytenr  Ein ganzzahliger  Wert zwischen 1 und 254,  der das Byte
              im  gewünschten  logischen  Datensatz der  Relativ-Datei
              bezeichnet,  auf  den  der Schreib-/Lesezeiger  gestellt
              werden soll. Voreingestellt ist hier 1.

Bemerkungen:  Werden für die  Parameter Variablen verwendet, so müssen
              diese in Klammern eingekleidet werden.

              Positionieren auf   nichtexistente  Sätze  führt  zu der
              Fehlermeldung RECORD NOT PRESENT.

Beispiele:    RECORD #2,452,23

              Der Schreib-/Lese-Zeiger  für  die  unter  der logischen
              Dateinummer 2 eröffneten Relativ-Datei  wird auf das 23.
              Byte im 452. Satz gestellt.

[SEITE 4-97]

RENAME-Befehl

Format:       RENAME Altname TO Neuname [,DLaufw] [,UGeräteadr]

Zweck:        Weist einer Diskettendatei  auf einem wählbaren Laufwerk
              einen neuen Namen zu (s.a. Kapitel 6.9.4).

    Altname,  Zeichenkettenkonstanten  in  Anführungszeichen (")  oder
    Neuname   -variablen mit  einer Länge von  bis zu 16  Zeichen, die
              den  alten  bzw.   neuen  Namen für  die  Diskettendatei
              bezeichnen.

       Laufw  Ein  ganzzahliger Wert von  0 oder  1, der  das Laufwerk
              bezeichnet. Voreingestellt ist hier 0.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen   4  und  15  für  die
              Geräteadresse  der   angeschlossenen  Floppy-Disk.  Vor-
              eingestellt ist hier 8.

Bemerkungen:  Werden für  die Parameter Variablen verwendet, so müssen
              diese in Klammern angegeben werden.

Beispiele:    RENAME "ADRESSEN" TO "ADRNEU"

              Die  Datei ADRESSEN auf  der  Diskette in Laufwerk 0 der
              Floppy-Disk 8 erhält den Namen ADRNEU.

              RENAME (AD$) TO (ND$),D(LW),U(GA)

              Hier werden für die Parameter Variablen verwendet.

[SEITE 4-98]

RENUMBER-Befehl

Format:       RENUMBER [Nnum[,[Schrittw][,Anum]]]

Zweck:        Numeriert  das  im   Hauptspeicher  befindliche   BASIC-
              Programm vollständig oder teilweise neu.

        Nnum  Die  Zeilennummer,  mit  der  der  neu  zu  numerierende
              Programmteil beginnen soll. Voreingestellt ist hier 10.

    Schrittw  Ein  ganzzahliger Wert,  um den  bei  der Neunumerierung
              jede  Zeilennummer gegenüber der  vorhergehenden steigen
              soll. Voreingestellt ist hier 10.

        Anum  Die Zeilennummer  im aktuellen Programm, von  der an neu
              numeriert werden soll. Voreingestellt ist hier 0.

Bemerkungen:  Dieser Befehl kann nur im Direktmodus gegeben werden.

              Alle Zeilenreferenzen in den Anweisungen

              GOTO              ON GOSUB ...
              GOSUB             RESTORE
              THEN              RESUME
              ELSE              EL
              ON GOTO ...

              werden durch RENUMBER der neuen Numerierung angepaßt.

              RENUMBER kann die  Reihenfolge von  Programmzeilen nicht
              verändern.

[SEITE 4-99]

Beispiele:    RENUMBER

              Das  gesamte im Hauptspeicher  befindliche Programm wird
              in 10er-Schritten neu numeriert.  Die erste Zeile erhält
              die Nummer 10.

              RENUMBER 100,15

              Das  gesamte im  Hauptspeicher befindliche Programm wird
              in 15er-Schritten neu  numeriert. Die erste Zeile erhält
              die Nummer 100.

              RENUMBER 2500,50,1000

              Das im Hauptspeicher befindliche Programm wird von Zeile
              1000 an  in  50er-Schritten neu  numeriert.  Zeile  1000
              erhält die Nummer 2500.

[SEITE 4-100]

RESTORE-Anweisung

Format:       RESTORE [Zeilennr]

Zweck:
              Setzt  den  Lesezeiger  der READ-Anweisung   (s. dort in
              Kapitel 3) auf  das  erste DATA-Element der  ersten oder
              einer  wählbaren  DATA-Zeile im   Programm, um DATA-Ele-
              mente wiederholt zu lesen.

    Zeilennr  Eine  gültige Programmzeilennummer,  bei der  eine DATA-
              Anweisung stehen muß.

Beispiel:     100 DATA 1,2,3,4,5,6
              110 READ U,V,W:RESTORE 100
              120 READ X,Y,Z
              130 PRINT U;V;W;X;Y;Z
              RUN
              1 2 3 1 2 3
              READY.

[SEITE 4-101]

RESUME-Anweisung

Format:       RESUME
              RESUME NEXT
              RESUME Zeilennr

Zweck:        Setzt   das  Programm   nach  Ausführen  einer   Fehler-
              behandlungsroutine (s. TRAP-Anweisung)  an  einer  defi-
              nierten Stelle fort.

              RESUME           Das unterbrochene Programm wird mit der
              Anweisung, die den Fehler verursacht hat, fortgesetzt.

              RESUME NEXT      Das unterbrochene Programm wird mit der
              Anweisung, die der fehlerverursachenden Anweisung folgt,
              fortgesetzt.

              RESUME Zeilennr  Das unterbrochene Programm wird mit der
              durch Zeilennr definierten Zeile fortgesetzt.

Beispiel:     100 TRAP 500
              .
              .
              .
              500 IF ER=11 THEN RESUME 250

              Bei einem SYNTAX ERROR  soll das Programm mit  Zeile 250
              fortgesetzt werden.

[SEITE 4-102]

RGR-Funktion

Format:       v=RGR(n)

Zweck:        Liefert  den  aktuell eingestellten grafischen  Modus (0
              bis 5; s. a. GRAPHIC-Anweisung).

           n  Ein Scheinargument, dessen Wert beliebig sein kann, aber
              angegeben werden muß.

[SEITE 4-103]

RREG-Anweisung

Format:       RREG [AVar][,[XVar][,[YVar][,[SVar]]]

Zweck:        Weist   den  spezifizierten   Variablen,  die   bei  der
              Beendigung  eines  mit der  SYS-Anweisung  (s.  dort  in
              Kapitel   5.2)  aufgerufenen  Maschinensprache-Unterpro-
              gramms aktuellen  Inhalte der Prozessorregister  A, X, Y
              und SR (Statusregister) zu.

  AVar, XVar,
  YVar, SVar  Beliebige numerische Variablen oder Feldelemente.

Bemerkungen:  Mit dieser Anweisung können die Prozessorregisterinhalte
              nach Beendigung eines Maschinensprache-Unterprogramms in
              ein BASIC-Programm übernommen werden.

[SEITE 4-104]

RSPCOLOR-Funktion

Format:       v=RSPCOLOR(n)

Zweck:        Liefert den Code der aktuellen Zusatzfarbe für Sprites.

           n  Ein  ganzzahliger  Wert  von  1  oder  2  mit  folgender
              Bedeutung:

              1  liefert einen Farbcode   zwischen  1 und  16  für die
                 Sprite-Zusatzfarbe 1.

              2  liefert einen Farbcode   zwischen  1 und  16  für die
                 Sprite-Zusatzfarbe 2.

[SEITE 4-105]

RSPPOS-Funktion

Format:       v=RSPPOS(n,m)

Zweck:        Liefert für ein bestimmtes Sprite Position oder aktuelle
              Geschwindigkeit.

           n  Ein  ganzzahliger Wert  zwischen  1 und  8,  der das  zu
              untersuchende Sprite definiert.

           m  Ein  ganzzahliger Wert  zwischen  0  und 2 mit folgender
              Bedeutung.

              0  liefert aktuelle x-Koordinate
              1  liefert aktuelle y-Koordinate
              2  liefert  die   aktuelle  Geschwindigkeit  im  Bereich
                 zwischen 0 und 15

[SEITE 4-106]

RSPRITE-Funktion

Format:       v=RSPRITE(n,m)

Zweck:        Liefert für ein bestimmtes  Sprite die aktuellen  Attri-
              bute.

           n  Ein  ganzzahliger Wert  zwischen  1 und  8,  der das  zu
              untersuchende Sprite definiert.

           m  Ein  ganzzahliger Wert  zwischen  0  und 5 mit folgender
              Bedeutung:

              0  Liefert  1, wenn das Sprite aktiviert  und 0, wenn es
                 inaktiviert ist.
              1  Liefert die Spritefarbe im Bereich 1 bis 16.
              2  Liefert  eine 0, wenn  das  Sprite Priorität über den
                 Hintergrund hat, andernfalls 1.
              3  Liefert eine 1, wenn das Sprite in x-Richtung gedehnt
                 ist, andernfalls 0.
              4  Liefert eine 1, wenn das Sprite in y-Richtung gedehnt
                 ist, andernfalls 0.
              5  Liefert eine 1,  wenn für das Sprite der  Mehrfarben-
                 modus aktiv ist, andernfalls 0.

[SEITE 4-107]

RUN-Befehl

Format:       RUN [Zeilennr]
              RUN Dateiname[,DLaufw][,UGeräteadr]

Bedeutung:    Ein BASIC-Programm, das  entweder im Hauptspeicher resi-
              dent ist oder von Disk geladen wird, wird gestartet.

    Zeilennr  Eine gültige Programmzeilennummer,  bei der das Programm
              gestartet werden soll.

   Dateiname  Eine  Zeichenkettenkonstante  in Anführungsstrichen  (")
              oder eine  -variable in  Klammern (), die  den Programm-
              dateinamen bezeichnet.

       Laufw  Ein ganzzahliger  Wert von 0 oder  1. Voreingestellt ist
              hier 0.

   Geräteadr  Ein  ganzzahliger  Wert  zwischen  4  und  15,  der  die
              Geräteadresse  der angeschlossenen  Floppy-Disk bezeich-
              net. Voreingestellt ist hier der Wert 8.

Bemerkungen:  Wird keine  Zeilennummer angegeben, wird das Programm ab
              der niedrigsten Zeilennummer gestartet.

              Durch   RUN   werden    vor   dem  Programmstart    alle
              ggfs. definierten Variablen gelöscht.

              Wird im RUN-Befehl eine Datei  spezifiziert, so wird vor
              dem   Laden der   Programmspeicher  gelöscht.   Außerdem
              werden alle ggfs. geöffneten Dateien geschlossen.

[SEITE 4-108]

Beispiel 1:   100 FOR I=1 TO 2:PRINT I^2;:NEXT
              200 PRINT"HALLO!"
              RUN
              1 4HALLO!
              READY.
              RUN 200
              HALLO!
              READY.

Beispiel 2:   RUN"PROG1",D0,U9

              Das Programm  PROG1 wird von der  Diskette in Laufwerk 0
              der  Floppy-Disk mit  der   Geräteadresse 9 geladen  und
              gestartet.

[SEITE 4-109]

RWINDOW-Funktion

Format:       v=RWINDOW(n)

Zweck:        Liefert die Parameter für das aktuelle Bildfenster (s.a.
              WINDOW-Befehl).

           n  Ein  ganzzahliger Wert  zwischen 0  und 2  mit folgender
              Bedeutung:

              0  Liefert die  Nummer  der  letzten Zeile  im aktuellen
                 Bildfenster (0-24).
              1  Liefert die  Nummer  der letzten Spalte  im aktuellen
                 Bildfenster (0-79)
              2  Liefert 40 oder 80, je nach eingestellter Bildschirm-
                 breite

[SEITE 4-110]

SCALE-Anweisung

Format:       SCALE [n][,xmax,ymax]

Zweck:        Schaltet die Skalierung  im Grafikmodus ein oder aus und
              verändert den Maßstab für die Bildschirmkoordinaten.

           n  Ein  ganzzahliger  Wert  von  0  oder  1  mit  folgender
              Bedeutung:

              0  schaltet  die  Skalierung aus.  Die  grafischen Bild-
                 schirmkoordinaten x/y sind
                 0-159/0-199 im Mehrfarbenmodus und
                 0-319/0-199 im hochauflösenden Modus.

              1  schaltet  die Skalierung  ein.   Die grafischen Bild-
                 schirmkoordinaten sind  wie  unten beschrieben einge-
                 stellt.

   xmax,ymax  Größte mögliche x- bzw. y-Koordinate bei eingeschalteter
              Skalierung.  xmax  muß zwischen  160 bzw.  320  und 1023
              liegen.   ymax   muß   zwischen   200  und  1023 liegen.
              Voreingestellt  ist für  eingeschaltete  Skalierung 1023
              für beide Koordinaten.

Bemerkungen:  Mit der SCALE-Anweisung  lassen sich im grafischen Modus
              Objekte auf  dem  Bildschirm  in  anderen Maßstäben dar-
              stellen.

Beispiel:     SCALE 1

              Die  Bildschirmskalierung wird   eingeschaltet und ggfs.
              abgebildete  Objekte werden  verkleinert,  da jetzt  die
              Maximalkoordinaten in x- und y-Richtung 1023 sind.

[SEITE 4-111]

SCNCLR-Anweisung

Format:       SCNCLR [n]

Zweck:        Löscht den angegebenen Bildschirm.

           n  Ein ganzzahliger Wert mit folgender Bedeutung:

              0  Der 40-Zeichen-Textschirm wird gelöscht.

              1  Der hochauflösende Grafikbildschirm wird gelöscht.

              2  Der hochauflösende  geteilte Bildschirm   (Text-  und
                 Grafikdarstellung) wird gelöscht.

              3  Der Mehrfarben-Grafikbildschirm wird gelöscht.

              4  Der  geteilte Mehrfarben-Grafikbildschirm (Text-  und
                 Grafikdarstellung) wird gelöscht.

              5  Der 80-Zeichen-Textschirm wird gelöscht.

              Bei  aktiviertem Grafikbildschirm (s. GRAPHIC-Anweisung)
              kann SCNCLR ohne Parameter eingegeben werden.

[SEITE 4-112]

SCRATCH-Befehl

Format:       SCRATCH Dateiname[,DLaufw][,UGeräteadr]

Zweck:        Löscht den Dateieintrag für die angegebene Datei aus dem
              Diskettenverzeichnis und  damit  die Datei von  Diskette
              (s.a.  Kapitel 6.8)

   Dateiname  Eine  Zeichenkettenkonstante  in  Anführungszeichen  (")
              oder  eine  -variable mit  einer  Länge  von  bis zu  16
              Zeichen, die die zu löschende Datei bezeichnet.

       Laufw  Ein  ganzzahliger Wert von  0 oder  1, der  das Laufwerk
              bezeichnet. Voreingestellt ist hier 0.

   Geräteadr  Ein ganzzahliger Wert zwischen  4 und 15 für die Geräte-
              adresse der  angeschlossenen Floppy-Disk. Voreingestellt
              ist hier 8.

Bemerkungen:  Der  SCRATCH-Befehl  verlangt durch  die Anfrage ARE YOU
              SURE?  vom Anwender  die  Bestätigung  für die  Befehls-
              ausführung (Antwort Y für  YES).  Bei jeder anderen Ant-
              wort wird der Befehl ignoriert.

              Werden in   dem Dateinamen die   Joker-Zeichen *  und  ?
              (s. Kapitel 6.3) verwendet,  so können mit einem  Befehl
              mehrere Dateien gelöscht werden.

              Wird  der SCRATCH-Befehl  im   Direktmodus  gegeben,  so
              meldet er die erfolgreiche Löschung mit

              01,FILES SCRATCHED,nn,00

              wobei nn die Anzahl der gelöschten Dateien angibt.

[SEITE 4-113]

Beispiele:    SCRATCH"DATEN"

              Die  Datei "DATEN" wird auf  der Diskette  in Laufwerk 0
              von der Floppy-Disk mit der Geräteadresse 8 gelöscht.

              SCRATCH"*",U9

              Alle Dateien werden von  der Diskette in Laufwerk  0 von
              Floppy-Disk Nr. 9 gelöscht.

              SCRATCH"????.PRG",D1

              Alle  Dateien, deren  8 Zeichen   lange Namen mit   .PRG
              enden,  werden von  der   Diskette in   Laufwerk  1 (bei
              Doppellaufwerken) von Floppy-Disk Nr. 8 gelöscht.

              SCRATCH(A$),D(LW),U(GA)

              Hier werden für alle Parameter Variablen benutzt.

[SEITE 4-114]

SLEEP-Befehl

Format:       SLEEP n

Zweck:        Hält die Programmausführung für eine bestimmte Zeit an.

           n  Ein  ganzzahliger Wert  zwischen  1 und  65535, der  die
              Wartezeit in Sekunden definiert.

Bemerkungen:  Die durch den SLEEP-Befehl gesetzte  Zeit wird durch die
              FAST-Anweisung (s. dort) nicht beeinflußt.

[SEITE 4-115]

SLOW-Befehl

Format:       SLOW

Zweck:        Schaltet den  Prozessor vom  Betrieb im 2-Megahertz-Takt
              auf   Betrieb im 1-Megahertz-Takt   um. Der Rechner wird
              damit halb so schnell.

Bemerkungen:  Die 40-Zeichen-Bildschirmanzeige  wird  durch den  SLOW-
              Befehl wieder aktiviert (s.a. FAST-Befehl).

[SEITE 4-116]

SOUND-Anweisung

Format:       SOUND Stimme,Freq,Dauer[,[Richtung]
                    [,[Maxfreq][,[Stufe][,[Welle]
                    [,Impulsbreite]]]]]

Zweck:        Erzeugt  Ton- oder Klangeffekte  wählbarer Frequenz  und
              Dauer und gibt sie über   den Lautsprecher des  Monitors
              oder Fernsehempfängers aus.

      Stimme  Ein  ganzzahliger Wert  zwischen 1  und 3  mit folgender
              Bedeutung:

              1  Stimme 1 (Ton)
              2  Stimme 2 (Ton)
              3  Stimme 3 (Ton)

        Freq  Ein  ganzzahliger  Wert zwischen  0  und  65535 für  die
              Frequenz.

       Dauer  Ein  ganzzahliger Wert  zwischen  0 und  32767, der  die
              Dauer  des   Klangeffektes  in  Rechnerzeittakten  (1/60
              Sekunde)  angibt.   Ein Wert  von  0  bricht alle  ggfs.
              laufenden Ton- oder  Klangeffekte mit sofortiger Wirkung
              ab.

    Richtung  Ein  ganzzahliger Wert  zwischen 0  und 2  mit folgender
              Bedeutung:

              0  zunehmende Klangstufen
              1  abnehmende Klangstufen
              2  oszillierende Klangstufen

              Voreingestellt ist hier 0.

     Maxfreq  Ein  ganzzahliger  Wert zwischen  0  und  65535 für  die
              Maximalfrequenz  für  anschwellende  Klangeffekte.  Vor-
              eingestellt ist hier 0.

       Stufe  Ein  ganzzahliger Wert  zwischen  0 und  32767, der  die
              Zeitdauer für stufige Klangeffekte angibt.

[SEITE 4-117]

      Welle   Ein ganzzahliger  Wert zwischen 0 und 3  für die Wellen-
              form:

              0  Dreieck
              1  Sägezahn
              2  Rechteck
              3  Rauschen

              Voreingestellt ist hier 2.
      Impuls-
      breite  Ein  ganzzahliger  Wert  zwischen  0 und  4095.  Vorein-
              gestellt ist hier 2048 (50% Tastverhältnis).

Bemerkungen:  Wenn  eine  SOUND-Anweisung mit einer  bestimmten Stimme
              gegeben    wird,    solange   eine    vorher    gegebene
              SOUND-Anweisung mit  derselben Stimme noch aktiv ist, so
              wird erstere  zunächst  zuende  geführt, ehe die  zweite
              begonnen wird.

Beispiel:     SOUND2,800,3600

              Spielt eine Note der Stimme 2 bei einem Frequenzwert von
              800 für eine Minute.

[SEITE 4-118]

SPRCOLOR-Anweisung

Format:       SPRCOLOR [Zusatzfarb1][,Zusatzfarb2]

Zweck:        Setzt  die  Zusatzfarbe   im Mehrfarbenmodus  für   alle
              Sprites.

 Zusatzfarb1  Ein  ganzzahliger  Wert  zwischen  1  und  16,  der  die
              Zusatzfarbe  1  für   alle  Sprites  im  Mehrfarbenmodus
              festlegt.

 Zusatzfarb2  Ein  ganzzahliger  Wert  zwischen  1  und  16,  der  die
              Zusatzfarbe  2  für   alle  Sprites  im  Mehrfarbenmodus
              festlegt.

[SEITE 4-119]

SPRDEF-Befehl

Format:       SPRDEF

Zweck:        Schaltet den Sprite-Editor ein.

Bemerkungen:  Dieser Befehl  ist  sowohl im   Direktmodus als auch  im
              Programm-Modus erlaubt. Der Sprite-Editor kennt folgende
              Befehle:

     1 bis 8  Wählt eine Sprite-Nummer.

           A  Schaltet   die   automatische   Wiederholung   für   die
              Zeichen-Tasten 1,2,3 oder 4 ein oder aus.

        CRSR-
      Tasten  Steuern den Cursor über das Sprite-Raster.

      RETURN-
       Taste  Setzt  den  Cursor auf  die  nächste  Zeile des  Sprite-
              Rasters.

       SHIFT-
      RETURN  Speichert  das   entworfene  Sprite.   Wird  unmittelbar
              danach   die   RETURN-Taste   gedrückt,  so   wird   der
              Sprite-Editor beendet und der Interpreter wird wieder in
              den Direktmodus gesetzt.

        HOME-
       Taste  Setzt   den  Cursor   in  die   linke  obere   Ecke  des
              Sprite-Rasters.

         CLR-
       Taste  Löscht das gesamte Sprite-Raster.

     1 bis 4  Im   hochauflösenden  Grafik-Modus   zeichnet   1  einen
              Sprite-Bildpunkt in der aktuellen Hintergrundfarbe und 2
              einen   Sprite-Bildpunkt   in   der  aktuellen   Vorder-
              grundfarbe  bei der Cursorposition.   Im Mehrfarbenmodus
              haben  die  1-  und  2-Taste dieselbe  Funktion  wie  im
              hochauflösenden  Grafik-Modus.    Die  3-Taste  zeichnet
              einen  Sprite-Bildpunkt  in der  Zusatzfarbe  1 und  die
              4-Taste einen in  der Zusatzfarbe 2 des Mehrfarbenmodus.
              In   diesem  Fall   werden  immer   doppelte  Bildpunkte
              gezeichnet, da im Mehrfarbenmodus  nur  die  halbe Bild-
              schirmauflösung  in  x-Richtung   zur  Verfügung  steht.
              Jeder  im  Raster gezeichnete  Bildpunkt wird  rechts in
              der  Originaldarstellung  der  aktuellen  Bildschirmauf-
              lösung  wiederholt, um eine  Kontrolle über die tatsäch-
              liche Größe des  zu entwerfenden  Sprites zu haben.

[SEITE 4-120]^

      CTRL 1  Wählt eine der  acht Vordergrundfarben 1  bis 8 für  das
  bis CTRL 8  Sprite.

         C=1
     bis C=8  Wählt eine der acht Vordergrundfarben 9 bis 16.
 (Commodore-
      Taste)

  STOP-Taste  Löscht alle Sprite-Eingaben.   Wird unmittelbar nach der
              STOP-Taste  die  RETURN-Taste   gedrückt,  so  wird  der
              Sprite-Editor  beendet und  der Direktmodus  wird wieder
              aktiviert.

           X  Dehnt das Sprite in x-Richtung.

           Y  Dehnt das Sprite in y-Richtung.

           M  Wählt Vielfarbmodus 1 oder 2 für das Sprite.

Bemerkungen:  Wenn der Sprite-Editor aufgerufen  wird, wird im  linken
              oberen Teil des Bildschirms ein Raster  von 21 x 24 Zei-
              chenpositionen eingerichtet.

              Um einen Bildpunkt  zu zeichnen, wird der  Sprite-Cursor
              (Plus-Zeichen)   an die gewünschte   Position im Sprite-
              Raster gesteuert, und  dann werden je nach eingestelltem
              grafischen  Modus  die  Zifferntasten 1, 2, 3 oder 4 ge-
              drückt.

              Möchten Sie   Ihre  entworfenen  Sprites   auf  Diskette
              speichern, verfahren Sie im Direktmodus wie folgt:

              BSAVE"name",B0,P3584 TO P4095

              Zum Laden einer solchen Datei geben Sie nur ein:

              BLOAD"name".

[SEITE 4-121]

              Mit Hilfe des Monitors müssen Sie zum Speichern auf Kas-
              sette oder Diskette

              S"name",gerät,0E00,0FFF

              und zum Laden

              L"name",gerät

              eingeben.  Für name ist der  Dateiname und für gerät die
              Geräteadresse in hexadezimaler Schreibweise anzugeben.

[SEITE 4-122]

SPRITE-Anweisung

Format:       SPRITE n[,[akt][,[Farbe][,[Pri]
                      [,xdehn][,[ydehn]
                      [,[Modus]]]]]]

Zweck:        Setzt Attribute für eines von 8 Sprites.

           n  Ein ganzzahliger  Wert    zwischen   1  und 8   für  die
              Sprite-Nummer.

         akt  Ein ganzzahliger Wert von  0 oder 1,  der angibt, ob das
              Sprite aktiviert (1) oder inaktiviert (0) werden soll.

       Farbe  Ein ganzzahliger Wert zwischen 1  und 16 für die Sprite-
              Farbe.   Die Zuordnung von  Farbcodes und Farben ist bei
              der COLOR-Anweisung (s. dort) beschrieben.

         Pri  Ein ganzzahliger Wert von 0 oder 1, der festlegt, ob das
              Sprite   bei   Bewegung zwischen vorhandenen Bildschirm-
              objekten vor (0) oder hinter (1) diesen Objekten vorbei-
              läuft.

       xdehn  Ein ganzzahliger  Wert von 0  oder 1, der angibt, ob das
              Sprite in x-Richtung gedehnt ist (1) oder nicht (0).

       ydehn  Ein ganzzahliger Wert von 0  oder 1, der  angibt, ob das
              Sprite in y-Richtung gedehnt ist (1) oder nicht (0).

       Modus  Ein ganzzahliger Wert von  0 oder 1,  der angibt, ob das
              Sprite  im hochauflösenden (0)  oder im  Mehrfarbenmodus
              angezeigt werden soll.

Bemerkungen:  Nicht  angegebene Parameter bedeuten,  daß ggfs.  vorher
              gesetzte Sprite-Attribute erhalten bleiben.

              Der  hochauflösende  oder  Mehrfarben-Sprite-Modus  darf
              nicht   mit    den   hochauflösenden   bzw.  Mehrfarben-
              Grafik-Modi  verwechselt werden.  Hochauflösende Sprites
              können im  Mehrfarben-Grafikmodus   verwendet werden und
              umgekehrt.

[SEITE 4-123]^

              Zur Ermittlung der für ein bestimmtes Sprite eingestell-
              ten Attribute kann die  RSPRITE-Funktion (s.  dort) ver-
              wendet werden.

Beispiel:     SPRITE 4,1,6,1,,,1

              Das Sprite Nr. 4  wird  aktiviert.  Es wird im Vielfarb-
              modus in der Farbe grün angezeigt und hat Priorität über
              angezeigten Bildschirmdaten.

[SEITE 4-124]

SPRSAV-Anweisung

Format:       SPRSAV n,v$
              SPRSAV v$,n

Zweck:        Speichert ein bestimmtes Sprite als Punktraster in einer
              Zeichenkettenvariablen oder umgekehrt.

           n  Ein  ganzzahliger Wert zwischen 1  und 8 für die Sprite-
              Nummer.

          v$  Eine  beliebige  Zeichenkettenvariable, die  das  Punkt-
              raster als Binärinformation aufnimmt oder enthält.

Beispiele:    SPRSAV 1,A$

              Überträgt das Punktraster von  Sprite 1  als Binärinfor-
              mation in die Zeichenkettenvariable A$.

              SPRSAV B$,4

              Überträgt  den  Wert   der  Zeichenkettenvariablen B als
              binäres Punktraster in das Sprite 4.

[SEITE 4-125]

SSHAPE-Anweisung

Format:       SSHAPE Zeikett,x1,y1,[,x2,y2]

Zweck:        Überträgt den Inhalt eines angegebenen Bereiches auf dem
              Grafikbildschirm als binäre Bildinformation in eine Zei-
              chenkettenvariable.

     zeikett  Eine  Zeichenkettenvariable,  die  den gewählten   Bild-
              schirmbereich als binäre Bildinformation aufnimmt.

       x1,y1  Die skalierten  Bildschirmkoordinaten der linken  oberen
              Ecke des darzustellenden Bildes.

       x2,y2  Die skalierten Bildschirmkoordinaten der rechten unteren
              Ecke des darzustellenden Bildes. Voreingestellt ist hier
              die aktuelle  Position  des grafischen  Cursors  (Pixel-
              Cursor).

Bemerkungen:  Da  BASIC-Zeichenketten  auf  eine Maximallänge  von 255
              Zeichen beschränkt sind, ist auch die Größe des zu spei-
              chernden Bereiches beschrönkt.

              Je nach aktiviertem grafischen Modus (hochauflösend oder
              Mehrfarben) läßt  sich die benötigte Länge  der Zeichen-
              kette folgendermaßen berechnen:

              L(m)=INT((ABS(x1-x2)+1)/4+.99)*
                   (ABS(y1-y2)+1)+4

              L(h)=INT((ABS(x1-x2)+1)/8+.99)
                   (ABS(y1-y2)+1)+4

[SEITE 4-126]

STASH-Befehl

Format:       STASH Bytes,Intadr,Extadr,Bank

Zweck:        Überträgt eine wählbare  Anzahl von Bytes aus dem BASIC-
              Arbeitsspeicher in eine Speichererweiterungsbank.

       Bytes  Ein ganzzahliger Wert zwischen 0 und  65535, der die An-
              zahl der zu übertragenden Bytes angibt.

      Intadr  Ein ganzzahliger  Wert  zwischen 0  und  65535, der  die
              Adresse im  BASIC-Arbeitsspeicher  angibt,  ab  der  die
              Bytes umgespeichert werden sollen.

      Extadr  Ein  ganzzahliger Wert  zwischen  0  und 65535, der  die
              Adresse  in der  Speicherbank  angibt, ab der  die Bytes
              abgelegt werden sollen.

        Bank  Ein  ganzzahliger  Wert   zwischen  0  und  7,  der  die
              Speicherbank angibt, in  der  die Bytes  abgelegt werden
              sollen.

Bemerkungen:  Dieser Befehl   kann nur  ausgeführt  werden, wenn  eine
              RAM-Disk an den Rechner angeschlossen ist.  Die RAM-Disk
              decodiert den entsprechenden Befehl, und führt in aus.

              Der Parameter Intadr bezieht sich auf  die Bank, die mit
              dem BANK-Befehlt  eingestellt  wurde. Voreingestellt ist
              Bank 15.

              Sollen  z.B.  Daten  aus Bank 0   in der RAM-Disk  abge-
              speichert werden,  so muß  vor dem  STASH-Befehl 'Bank0'
              eingegeben werden.

Beispiel:     STASH 1000,52000,2000,7

              Überträgt  1000  Bytes  ab Adresse  52000 aus dem BASIC-
              Arbeitsspeicher in die Speicherbank 7 ab Adresse 2000.

+--------------------------------------------------------+
| ACHTUNG:                                               |
| Um diesen Befehl ausführen zu können, brauchen Sie das |
| Steckmodul RAM-Disk.                                   |
+--------------------------------------------------------+

[SEITE 4-127]

SWAP-Befehl

Format:       SWAP Bytes,Intadr,Extadr,Bank

Zweck:        Tauscht eine  wählbare  Anzahl Bytes zwischen dem BASIC-
              Arbeitsspeicher und einer Speichererweiterungsbank.

       Bytes  Ein ganzzahliger Wert zwischen 0 und  65535, der die An-
              zahl der auszutauschenden Bytes angibt.

      Intadr  Ein ganzzahliger  Wert  zwischen  0 und  65535,  der die
              Adresse im  BASIC-Arbeitsspeicher   angibt,  ab der  die
              Bytes ausgetauscht werden sollen.

      Extadr  Ein ganzzahliger  Wert   zwischen 0 und  65535,  der die
              Adresse in  der Speicherbank  angibt,  ab der die  Bytes
              ausgetauscht werden sollen.

        Bank  Ein  ganzzahliger  Wert  zwischen  0   und  7, der   die
              Speicherbank  angibt,   mit  der die  Bytes ausgetauscht
              werden sollen.

Bemerkungen:  Dieser Befehl  kann  nur  ausgeführt werden, wenn   eine
              RAM-Disk an den Rechner angeschlossen ist.  Die RAM-Disk
              decodiert den entsprechenden Befehl, und führt ihn aus.

              Der Parameter Intadr bezieht  sich auf die Bank, die mit
              dem BANK-Befehl  eingestellt wurde.  Voreingestellt  ist
              Bank 15.

              Sollen z.B.  Daten aus   Bank 0  in der RAM-Disk   abge-
              speichert werden, so  muß vor dem STASH-Befehl  'BANK 0'
              eingegeben werden.

Beispiel:     SWAP 1000,52000,2000,7

              Tauscht 1000  Bytes ab Adresse  52000 im  BASIC-Arbeits-
              speicher mit einem gleichgroßen Bereich in der Speicher-
              bank 7 ab Adresse 2000 aus.

+--------------------------------------------------------+
| ACHTUNG:                                               |
| Um diesen Befehl ausführen zu können, brauchen Sie das |
| Steckmodul RAM-Disk.                                   |
+--------------------------------------------------------+

[SEITE 4-128]

TEMPO-Anweisung

Format:       TEMPO n

Zweck:        Setzt das Spieltempo für Musiknoten.

           n  Ein ganzzahliger Wert zwischen  0 und 255, der die rela-
              tive Dauer angibt, mit der die gespielten Musiknoten ge-
              halten werden.   Die  tatsächliche Dauer  berechnet sich
              nach

              Dauer = 19.22/n in Sekunden.

              Voreingestellt ist  der  Wert 8.  Bei  einem  Wert von 0
              wird die Note dauernd gehalten.

[SEITE 4-129]

TRAP-Anweisung

Format:       TRAP [Zeilennr]

Zweck:        Die Fehlerunterbrechung wird aktiviert, und das Programm
              verzweigt zu  einer angegebenen Zeilennummer, sobald der
              Interpreter eine Fehlermeldung ausgeben will.

    Zeilennr  Eine gültige Programmzeilennummer, mit der die Fehlerbe-
              handlungsroutine beginnt.  Wird keine Zeilennummer ange-
              geben, so wird die Fehlerunterbrechung inaktiviert.

Bemerkungen:  Bei aktivierter   Fehlerunterbrechung verzweigt das Pro-
              gramm  bei  allen  Fehlerbedingungen einschließlich  der
              Betätigung der STOP-Taste.

              Beim  Auftreten  eines  Fehlers  wird  eine  Fehlermarke
              gesetzt, das   Programm  verzweigt  zu  der  angegebenen
              Zeilennummer und führt dort eine Fehlerbearbeitung aus.

              Die Nummer der fehlerhaften Zeile kann mit Hilfe der EL-
              Systemvariablen (s.  dort), der Fehlercode mit Hilfe der
              ER-Systemvariablen und der  Fehlermeldungstext  mit  der
              Funktion ERR$(ER) ermittelt werden.

              Mit   Hilfe  der RESUME-Anweisung  (s.  dort)  wird  das
              Hauptprogramm fortgesetzt.

+---------------------------------------------------------------------+
| ACHTUNG                                                             |
| Ein Fehler innerhalb einer Fehlerbearbeitungsroutine kann nicht mit |
| TRAP aufgefangen werden.                                            |
+---------------------------------------------------------------------+

[SEITE 4-130]

TRON- und TROFF-Befehle

Format:       TRON
              TROFF

Zweck:        Schaltet  die  Programmablaufverfolgung ein  (TRON) oder
              aus (TROFF).

Bemerkungen:  Bei eingeschalteter Programmablaufverfolgung werden  die
              Zeilennummern in der Reihenfolge ihrer Bearbeitung durch
              den  Interpreter in eckigen  Klammern ([]) auf dem Bild-
              schirm angezeigt.

              Die Befehle TRON und TROFF dienen zum schrittweisen Aus-
              testen von BASIC-Programmen.

[SEITE 4-131]

VOL-Anweisung

Format:       VOL n

Zweck:        Setzt  die Lautstärke  für die  mit der  SOUND-  und der
              PLAY-Anweisung  (s.  dort)  erzeugten  Ton- oder  Klang-
              effekte.

           n  Ein ganzzahliger Wert  zwischen 0 und  15, der die Laut-
              stärke bestimmt.   0 bedeutet Ausschalten  der Ton- oder
              Klang- Ausgabe.

Bemerkungen:  Die  VOL-Anweisung  ist  für   alle   wählbaren  Stimmen
              (s. SOUND- und PLAY-Anweisungen) gültig.

[SEITE 4-132]

WIDTH-Anweisung

Format:       WIDTH n

Zweck:        Setzt die  Strichstärke  für alle  grafischen   Zeichen-
              anweisungen (BOX, CIRCLE, DRAW etc.).

           n  Ein  ganzzahliger Wert  von  1 für  einfache  oder 2 für
              doppelte Strichstärke.

[SEITE 4-133]

WINDOW-Anweisung

Format:       WINDOW xlo,ylo,xru,yru[,lö]

Zweck:        Setzt  ein Bildschirmfenster für  Textausgabe und löscht
              dieses wahlweise.

     xlo,ylo  Spalten- und  Zeilennummer  der  linken oberen Ecke  des
              Textfensters.

     xru,yru  Spalten- und  Zeilennummer  der rechten unteren Ecke des
              Textfensters.

          lö  Ein  ganzzahliger Wert von 0  oder 1, der angibt, ob das
              Bildfenster nach der Definition gelöscht werden soll (1)
              oder nicht (0). Voreingestellt ist 0.

[SEITE 4-134]

XOR-Funktion

Format:       v=XOR(n1,n2)

Zweck:        Liefert  einen ganzzahligen  Wert  im Bereich zwischen 0
              und 65535,  der  sich aus  der Exclusiv-ODER-Verknüpfung
              von zwei ganzen, vorzeichenlosen 16-Bit-Werten ergibt.

       n1,n2  Zwei ganzzahlige Werte im Bereich  zwischen 0 und 65535,
              die intern in 16-Bit-Zahlen  umgewandelt werden, ehe sie
              logisch miteinander verknüpft werden.

Beispiele:    PRINT XOR(124,12); XOR(0,12)
              112 12
              READY.

[SEITE 4-135]

4.7 FARBEN, SPRITES UND GRAFISCHE EFFEKTE

Der  C128 besitzt  14 neue Befehle,  die  es  Ihnen leicht machen, Grafiken zu
erzeugen.

             BOX       CHAR
             CIRCLE    DRAW
             COLOR     LOCATE
             GRAPHIC   PAINT
             MOVSPR    GSHAPE
             SCALE     SSHAPE
             SPRSAV    SPRITE

Genauere Informationen entnehmen Sie bitte Kapitel 4.6.

GRAFISCHE BESONDERHEITEN

Ein hervorstechendes Merkmal  des C128 ist seine grafische Programmierbarkeit.
Er kann 16 verschiedene Farben (siehe untenstehende Tabelle) erzeugen.  Außer-
dem  besitzt  er noch 5 verschiedene  grafische  Modi und kann  8 verschiedene
bewegliche Objekte, genannt Sprites, verwalten.

Folgende Farbcodes sind verfügbar:

             1 schwarz        9 hellbraun
             2 weiß          10 braun
             3 rot           11 rosa
             4 grün          12 dunkelgrau
             5 violett       13 grau
             6 dunkelgrün    14 hellgrün
             7 blau          15 hellblau
             8 gelb          16 hellgrau

Folgende grafische Modi sind wählbar:

0   Text mit 40 Zeichen/Zeile.
1   hochauflösende Grafik (320x200 Punkte).
2   hochauflösende Grafik, geteilter Bildschirm für Grafik und Text
3   Mehrfarbengrafik (160x200 Punkte)
4   Mehrfarbengrafik, geteilter Bildschirm für Grafik und Text.
5   Text mit 80 Zeichen/Zeiles.

[SEITE 4-136]

HOCHAUFLÖSENDE UND MEHRFARBEN-GRAFIK

Wie bereits  erwähnt, zählen zu den  Besonderheiten des C128 zwei verschiedene
grafische Betriebsmodi, nämlich der Betrieb mit hochauflösender Grafik und der
Mehrfarben-Grafikbetrieb, die mit der GRAPHIC-Anweisung gewählt werden können.

Bei beiden Betriebsarten (wie auch beim Mischbetrieb mit geteiltem Bildschirm)
wird ein Speicherbereich von insgesamt 9 bzw. 10 KBytes reserviert. Von diesem
Bereich werden 8000 Bytes für den Grafik-Bildschirm belegt.

Da jedes Byte aus 8 Bit besteht,  stehen der Grafik  also insgesamt 64000 Bits
zur  Verfügung.  Jedem  dieser Bits  ist ein  Bildpunkt der  Grafik zugeordnet
(320x200 = 64000 Bildpunkte).  Man  spricht deshalb auch  von einem Bitmapped-
Speicher.

Jedes Bit kann zwei Zustände annehmen, nämlich 0 (Null) und  1. 0 bedeutet aus
und 1 bedeutet ein.

Der Baustein  (VIC=Vide Interface Controller),  der nun  alle Vorgänge auf dem
Bildschirm sowie die  Farbwiedergabe steuert, stellt  unter anderem sowohl für
den Hintergrund als auch für den Vordergrund je  eine Farbe zur Verfügung, die
aus einer Skala von 16 verschiedenen Farben wählbar ist.

Da  bei der hochauflösenden Grafik jeder  Bildpunkt durch  ein Bit dargestellt
wird,  kann er   auch  nur  zwei  verschiedene  Farben annehmen,  nämlich  die
Hintergrundfarbe, wenn das Bit 0 (aus) ist oder die Vordergrundfarbe, wenn das
Bit  1 (ein) ist.   Es sind also insgesamt   nur 2 Farben  bei hoher Auflösung
möglich.

Bei  der  Mehrfarbengrafik wird  die   Auflösung auf  160x200=32000 Bildpunkte
reduziert.  Damit  stehen im 64000-Bildpunkte-Speicher  für jeden  Bildpunkt 2
Bits zur   Verfügung, die   insgesamt  vier  verschiedene   Zustände erlauben,
nämlich:

00 01 10 11

Damit kann jetzt ein Bildpunkt neben der Hintergrund- und der Vordergrundfarbe
zwei weitere  Farben  (Zusatzfarben  1 und 2)    annehmen.   Es sind bei   der
Mehrfarbengrafik also insgesamt 4 FArben möglich.

[SEITE 4-137]

Welche Farben verwendet werden, wird mit der COLOR-Anweisung, deren Wirkung im
folgenden noch näher erläutert wird, festgelegt. Mit ihr werden jeder der vier
im  Grafikbetrieb existierenden Farbquellen (Hintergrund, Vordergrund, Zusatz-
farben 1 und 2)  eine der 16  möglichen Farben zugewiesen.  Diese  Farbquellen
und damit die ihnen zugeordneten Farben sind wiederum Parameter der grafischen
Zeichenanweisungen BOX, CHAR, CIRCLE, DRAW und PAINT.

ERSTELLEN VON GRAFIK-PROGRAMMEN IM C128-MODUS

Mit  den oben beschriebenen Grundlangen  sollte es  nicht mehr allzu schwierig
sein, eigene Grafik-Programme für den C128 zu erstellen.

Wenn  Sie diesem  Abschnitt schrittweise folgen,  können  Sie am Schluß selbst
Grafik-Programme schreiben.

1.    Zunächst müssen Sie die  Farben für den Vorder-  und Hintergrund
      sowie den Bildrahmen wählen. Dazu dient folgender Befehl:

COLOR Farbquelle,Farbcode

Die Farbquelle beschreibt den Teil  des Bildschirm, des Sie farblich verändern
wollen.  Farbcode ist  die  Zahl,  mit der  Sie die  Farbe  bei  der gewählten
Farbquelle bestimmen (s. TAbellen unten):

Code  Quelle

0     Hintergrund (40-Zeichen-Anzeige)
1     Vordergrund
2     Mehrfarbenmodus 1
3     Mehrfarbenmodus 2
4     Rand
5     Textfarbe
6     Hintergrund (80-Zeichen-Anzeige)

[SEITE 4-138]

Code  Farbe          Code  Farbe

1     schwarz         9    hellbraun
2     weiß           10    braun
3     rot            11    rosa
4     grün           12    dunkelgrau
5     violett        13    grau
6     dunkelgrün     14    hellgrün
7     blau           15    hellblau
8     gelb           16    hellgrau

Für ein  Beispiel  mit dem Hintergrund  schwarz,  dem Vordergrund rot und  dem
Bildrahmen schwarz probieren Sie folgendes Programm aus.

10 COLOR 0,1
20 COLOR 1,3
30 COLOR 4,1


2.    Der nächste Schritt bestimmt den Grafikmodus.

GRAPHIC Modus[,[Lösch],[Textzeile]]

Modus muß  eine Zahl zwischen 0 und  5 sein. Die untenstehende  Tabelle zeigt,
welche Zahlen dem jeweiligen grafischen Modus entsprechen.

Lösch ist ein ganzzahliger  Wert von 0  oder 1, der  bei Aufruf der Grafikmodi
1-4 bestimmt, ob der Bildschirm gelöscht werden soll (1) oder nicht (0).

Textzeile ist ein ganzzahliger Wert zwischen 0 und 24 (gilt nur für die Modi 2
und 4),   der die Zeile  festlegt,  bei der  der  Text-Teilbildschirm beginnen
soll. Voreingestellt ist 19.

Modus    Bedeutung

0        Text 40 Zeichen/Zeile
1        hochauflösende Grafik (320x200 Punkte)
2        hochauflösende Grafik (geteilter Bildschirm für Grafik und Text)
3        Mehrfarbengrafik (160x200 Punkte)
4        Mehrfarbengrafik (geteilter Bildschirm für Grafik und Text)
5        Text 80 Zeichen/Zeile

[SEITE 4-139]

Das  folgende Beispiel  arbeitet  mit der hochauflösenden  Grafik.  Geben  Sie
folgende Programmzeile ein:

40 GRAPHIC 1,1

Die zweite Zahl 1 im GRAPHIC-Befehl löscht den Bildschirm. Soll der Bildschirm
nicht gelöscht werden, geben Sie an der zweiten Stelle eine 0 ein.


+-------------------------------------------------------------------------+
| BEACHTE:                                                                |
| Arbeiten Sie nur mit einem Bildschirm und sollten Sie z.B. durch einen  |
| SYTAX ERROR in der hochauflösenden Grafik "hängen" bleiben, drücken Sie |
| die Funktionstaste f1 (GRAPHIC), dann 0 und dann RETRUN. Diese bewirkt  |
| eine automatische Rückkehr zum Textmodus, wenn Sie mit dem              |
| 40-Zeichen-Bildschirm arbeiten und einen Grafik-Bildschirm aktiviert    |
| haben.                                                                  |
+-------------------------------------------------------------------------+


3.    Nun können Sie  damit  beginnen, Ihre grafischen Befehle  einzu-
      geben.

Zunächst müssen  Sie den grafischen  Cursor  (Pixel Cursor) an die  Stelle des
Bildschirms  setzen, an der Sie  zu zeichnen beginnen  wollen.  Dazu dient die
LOCATE-Anweisung.

Geben Sie also folgende Programmzeile ein.

50 LOCATE 150,130

Diese Anweisung   positioniert den grafischen Cursor   auf  dem Bildschirm (im
Gegensatz zum Text-Cursor ist der grafische Cursor nicht sichtbar).

150 ist die x-Koordinate (horizontal)  und 130 die y-Koordinate (vertikal) auf
dem Bildschirm.  Die x-Koordinate reicht  von  0-319 und die y-Koordinate  von
0-199 (in Bildpunkten).

Die aktuelle Position des grafischen Cursors  können Sie mit der RDOT-Funktion
(s. dort in Kapitel 4.6) ermitteln.


4.   Jetzt lassen Sie uns einen Kreis zeichnen.

Geben Sie folgende Programmzeile ein:

60 CIRCLE 1,150,130,40,40

[SEITE 4-140]

Die erste Zahl (1) bedeutet,  daß der Kreis in der Vordergrundfarbe gezeichnet
wird. Eine 0 bewirkt hier,  daß  der Kreis in der Hintergrundfarbe gezeichnet,
also gelöscht wird.

Der Befehl bewirkt weiter,  daß ein Kreis   in der Mitte des  Bildschirmes ge-
zeichnet  wird.  Die  CIRCLE-Anweisung kennt  9  verschiedene Parameter, damit
können Sie die verschiedensten Kreise und geometrische Figuren zeichnen.

Was die einzelnen Zahlen bedeuten, entnehmen Sie bitte der Beschreibung dieses
Befehls im Kapitel 4.6.

5.    Nun versuchen Sie, ein Rechteck zu zeichnen.

Geben sie ein:

80 BOX 1,20,100,80,160,,1

Diese Anweisung bewirkt, daß links vom  Kreis ein Quadrat gezeichnet wird. Die
BOX-Anweisung (s. dort in Kapitel 4.6) besitzt  sieben Parameter, die es Ihnen
erlauben, verschiedene Rechtecke zu zeichnen.

Der erste  Wert kann 0 oder 1  sein.   Bei 1 wird das  Quadrat  in der Vorder-
grundfarbe gezeichnet,  bei 0 in der  Hintergrundfarbe, also gelöscht.  Der 2.
und 3. Wert sind die x- und y-Koordinaten der oberen linken  Ecke. Der 4.  und
5. Wert sind  die x-  und y-Koordinaten der  unteren rechten  Ecke. Der letzte
Wert kann 0 oder 1 sein.   0 bedeutet, daß  nur die Umrahmung gezeichnet wird.
1. füllt das Rechteck aus.

Nun  wechseln Sie die Farbe  im Vordergrund und  zeichnen ein weiteres Quadrat
mit den unten stehenden Koordinaten.

Schreiben Sie also folgende Programmzeilen:

 90 COLOR 1,9:REM FARBWECHSEL IM VORDERGRUND
100 BOX 1,220,100,200,160


6.    Mit  Hilfe der DRAW-Anweisung   (s. dort in Kapitel 4.6)  lassen
      sich auch einzelne Linien auf den Bildschirm zeichnen.  Folgende
      Anweisung zieht  eine  Linie unterhalb  der  vorher gezeichneten
      Figuren:


120 DRAW 1,20,180 TO 280,180

[SEITE 4-141]

Nun kurz  erläutert, was  die einzelnen Zahlen   bedeuten.   Der erste Wert  1
bedeutet Vordergrundfarbe.  20 und  180 sind die x-  und y-Koordinaten für den
Startpunkt. Die Werte 280 und 180 sind die x- und y-Koordinaten des Endpunkts.
Probieren Sie einige DRAW-Anweisungen einmal selbst aus.

Die DRAW-Anweisung  läßt  sich  auch so variieren, daß die gezeichneten Linien
ihre Richtung ändern.

Versuchen Sie einmal folgende Programmzeile:


130 DRAW 1,10,20 TO 300,20 TO 150,80 TO 10,20


Sie  sehen, daß der  Computer nun  ein  Dreieck zeichnet.  Die vier Wertepaare
stehen für die  jeweiligen Koordinaten der  drei Seiten.  Es ist also möglich,
verschiedene mathematischen Figuren zu zeichnen.

Es ist Ihnen vielleicht  aufgefallen, daß sich der  der grafische Cursor, wenn
x = 0  und y = 0  sind,  am oberen linken  Ende  des Computers befindet (HOME-
Position).


        Die Abbildung zeigt Ihnen die Anordnung der x- und y-Koordinaten
        auf dem Bildschirm:


        0,0   .--------------------------------------. 319,0
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
              |                                      |
        0,199 `--------------------------------------' 319,199


Es  gibt auch  die   Möglichkeit,  einzelne  Punkte auf Ihrem   Bildschirm  zu
zeichnen.

Geben Sie folgende Programmzeile ein:

150 DRAW 1,150,190

Mit dieser Anweisung wird ein Punkt unter dem Kreis gezeichnet.

[SEITE 4-142]


7.    Mit der DRAW-Anweisung können  Sie auch Bereiche des Bildschirms
      durch Umrandung hervorheben.

Sollten Sie jedoch einmal  eine Fläche mit Farbe  ausmalen wollen, so benutzen
Sie die PAINT-Anweisung (s. dort in Kapitel 4.6).

Geben Sie z.B. ein

160 PAINT 1,150,97

Dieser Befehl  malt den Kreis, den  Sie in Programmzeile  60 gezeichnet haben,
vollständig aus.

Nun zwei Befehle, die das oben gezeichnete Dreieck  und das Quadrat rechts des
Kreises ausmalen:

100 PAINT 1,50,25
200 PAINT 1,255,125

.--------------------------------------------------------------------.
| Hinweis:                                                           |
|                                                                    |
| Sie müssen bei der PAINT-Anweisung den Startpunkt innerhalb der    |
| auszumalenden Figure wählen, andernfalls wird die Figur nicht      |
| ausgemalt.                                                         |
`--------------------------------------------------------------------'

8.    Es ist auch möglich, Text im Grafik-Modus auf dem Bildschirm an-
      zuzeigen.

Geben Sie z.B. folgendes ein:

210 CHAR 1,10,1,"GRAFISCHES BEISPIEL"

Bei diesem Befehl wird der Text ab Spalte 10 in Zeile 1 angezeigt.

9.    Der Maßstab, in der eine grafische  Anweisung auf dem Bildschirm
      zeichnet, kann mit der SCALE-Anweisung verändert werden.

Damit können sie mehrere Figuren gleichzeitig  auf dem Bildschirm abbilden. Im
folgenden soll eine weitere Möglichkeit der SCALE-Anweisung erläutert werden.

Bei der hochauflösenden Grafik sind 320x200 Punkte möglich, im Mehrfarbenmodus
jedoch nur   160x200.   Der Nachteil   der geringeren  Auflösung  wird durch 2
zusätzliche Farben gemildert.    Sie haben also  für jeden  Bildpunkt jetzt  4
Farben zur Verfügung.

[SEITE 4-143]

Koordinaten-Skalierung

Die   SCALE-Anweisung  dehnt den  grafische Koordinatenbereich   in  x- und y-
Richtung auf 1024 aus, unabhängig  davon, ob in   der hohen Auflösung oder  im
Mehrfarbenmodus gearbeitet wird.

SCALE 1         ändert den Koordinatenmaßstab (x/y von 0 bis 1023)
SCALE 0         stellt den Koordinatenmaßstab auf die voreingestellten Werte
                (x/y von 0 bis 319/199) zurück.

Die bisher beschriebenen und  eingegebenen Befehlszeilen bilden  ein Programm.
Um jeder durch dieses Programm  erstellten Figur eine  andere Farbe zu  geben,
werden noch die  Zeilen 70, 110, 140, 170,  190 und 210 mit  COLOR-Anweisungen
eingefügt (s. Programmliste weiter unten).

Geben  Sie das Programm ein  und starten Sie es  durch Eingabe des RUN-Befehls
(RETURN-Taste nicht vergessen).

Nachdem Sie alle Beispiele einmal ausprobiert haben,  empfiehlt es sich, diese
auf eine Diskette oder Kassette speichern zu, damit sie Sie auch später wieder
verwenden können. Weitere   Informationen über den  Gebrauch der beschriebenen
BASIC-Anweisungen finden Sie im Kapitel 4.6.

Programmbeispiel:

 10 COLOR 0,1
 20 COLOR 1,3
 30 COLOR 4,1
 40 COLOR GRAPHIC 1,1
 50 LOCATE 150,130
 60 CIRCLE 1,150,130,40
 70 COLOR 1,7:REM FARBE BLAU 1. QUADRAT
 80 BOX 1,20,100,80,160,,1
 90 COLOR 1,9:REM RAHMENFARBE HELLBRAUN 2. QUADRAT
100 BOX ,220,100,280,160
110 COLOR 1,10:REM FARBE BRAUN FUER LINIEN
120 DRAW 1,20,180 TO 280,180
130 DRAW 1,10,20 TO 300,20 TO 150,80 TO 10,20
140 COLOR 1,6:REM FARBE GRUEN FUER PUNKT
150 DRAW 1,150,190:REM ZEICHNET PUNKT UNTERM KREIS
160 PAINT 1,150,97:REM FUELLT DEN KREIS AUS
170 COLOR 1,3:REM FARBE ROT FUER DAS DREIECK
180 PAINT 1,50,25:REM FUELLT DAS DREIECK AUS
190 COLOR 1,2:REM FARBE WEISS FUER DAS 2. QUADRAT
200 PAINT 1,225,125:REM FUELLT DAS 2. QUADRAT AUS
210 COLOR 1,14:REM SCHREIBT TEXT HELLGRAU
220 CHAR 1,10,1,"GRAFISCHES BEISPIEL"

[SEITE 4-144]

SPRITES: PROGRAMMIERBARE UND BEWEGBARE OBJEKTE

Ihr  C128 bietet Ihnen ferner  die Möglichkeit, selbst  entworfene Figuren auf
dem  Bildschirm zu bewegen.  Dieses  geschieht mit  der SPRITE-Anweisung.  Sie
brauchen  zum Erstellen von Sprites kein  Millimeterpapier mehr,  wenn sie mit
dem eingebauten Sprite-Editor (s.a. SPRDEF-Befehl im Kapitel 4.6) arbeiten.

Im folgenden wird beschrieben, wie Sie Sprites entwerfen und benutzen können.

Sollten Sie schon einmal mit dem C64 gearbeitet haben, so kennen Sie schon die
Grundbegriffe  der Sprite-Grafik.  Die  Sprite-Grafik  befähigt den  Computer,
Figuren jeglicher Form beliebig über den Bildschirm  laufen zu lassen. Sprites
lassen  sich in 16  verschiedenen Farben zeichnen  und  jedes Sprite kann bunt
dargestellt werden. Die folgenden  Anweisungen erlauben Entwurf und  Benutzung
von Sprites.

SPRDEF
SSHAPE
GSHAPE
SPRSAV
SPRITE
MOVSPR
SPRCOLOR
COLLISION

Sprite-Entwurf

Als erstes müssen Sie sich über das Aussehen des von Ihnen gewünschten Sprites
im klaren  sein, bevor Sie  es auf  dem Bildschirm  bewegen können (z.B.  eine
Rakete oder einen Rennwagen).

Im C128-Modus können Sie auf 3 verschiedene Arten Sprites erzeugen:

1.      Mit dem SSHAPE-, SPRSAVE- und SPRITE-Anweisungen.
2.      Mit dem SPRDEF-Befehl.
3.      Mit POKE-Anweisungen wie beim C64 (s. Kap. 5.3.1).

[SEITE 4-145]

1. DER GEBRAUCH DER SSHAPE-, SPRSAV- UND SPRITE-ANWEISUNGEN

Die  Verwendung   dieser Anweisungen erlaubt   auf schnelle  und einfache Art,
Sprites als Teile einer Grafik zu erzeugen.  Die einzelnen Anweisungen sind in
Kapitel 4.6 dieses Handbuches beschrieben.

Hier die Beschreibung eines Sprite-Entwurfsvorgangs:

- Zeichnen  Sie  ein beliebiges Bild  mit Hilfe  der DRAW-,  CIRCLE-, BOX- und
  PAINT-Anweisungen  aus dem  vorherigen Kapitel. Die  äußeren  Grenzen dieser
  Zeichnung  werden durch eine  24  x 21-Punktmatrix im hochauflösenden  Modus
  oder eine 12 x 21-Punktmatrix im Mehrfarbenmodus festgelegt.

- Benutzen  Sie die SSHAPE-Anweisung, um dieses  Bild in  einer Zeichenketten-
  Variablen zu speichern.

- Übertragen  Sie Ihren Entwurf mit Hilfe  der SPRSAV-Anweisung in die Sprite-
  Grafik.

- Aktivieren Sie das Sprite mit der SPRITE-Anweisung, malen Sie es aus, wählen
  Sie einen Farbmodus in vergrößern Sie das Sprite.

- Bewegen Sie das Sprite mit Hilfe der MOVSPR-Anweisung.

2. DER SPRDEF-BEFEHL

Der SPRDEF-Befehl ist der schnellste  und einfachste Weg, Sprites zu erzeugen.
Der SPRDEF-Befehl  schaltet  den  Sprite-Editor ein.   Genauere  Informationen
entnehmen Sie bitte der Befehlsbeschreibung im Kapitel 4.6.

Im folgenden sehen Sie an einem detaillierten Beispiel, wie Sie ein Sprite als
Teil einer Grafik selbst entwerfen können.

Dieses Beispiel arbeitet mit der hochauflösenden  Grafik. Für Umschaltungen in
den Grafikmoduds bei  schwarzen Hintergrund geben  Sie folgende Programmzeilen
ein:

 5   COLOR 0,1:REM HINTERGRUND SCHWARZ
10 GRAPHIC 1,1:REM HOCHAUFLOESENDE GRAFIK

[SEITE 4-146]

Das folgende  kurze   Programm zeichnet  einen   Rennwagen am   oberen  linken
Bildrand:

15 BOX 1,2,2,45,45:REM ZEICHNET RECHTECK UMS AUTO
20 DRAW 1,17,10 TO 28,10 TO 26,30 TO 19,30 TO 17,10:REM KAROSSERIE
22 DRAW 1,11,10 TO 15,10 TO 15,18 TO 11,18 TO 11,10:REM OBERES LINKES RAD
24 DRAW 1,30,10 TO 34,10 TO 34,18 TO 30,18 TO 30,10:REM OBERES RECHTES RAD
26 DRAW 1,11,20 TO 15,20 TO 15,28 TO 11,28 TO 11,20:REM UNTERES LINKES RAD
28 DRAW 1,30,20 TO 34,20 TO 34,28 TO 30,28 TO 30,20:REM UNTERES RECHTES RAD
30 DRAW 1,26,28 TO 19,28:REM KUEHLERGRILL
32 BOX 1,20,15,26,18,90,1:REM WINSCHUTZSCHEIBE
35 BOX 1,150,35,195,40,90,1:REM STRASSE
37 BOX 1,150,135,195,140,90,1:REM STRASSE
40 BOX 1,150,215,195,220,90,1:REM STRASSE
42 DRAW 1,50,180 TO 300,180: DRAW 1,50,180 TO 50,190:REM ZIELLLINE
43 DRAW 1,300,180 TO 300,190: DRAW 1,50,190 TO 300,190:REM ZIELLINIE
44 CHAR 1,18,23,"Z I E L":REM SCHREIBT ZIEL

Lassen Sie das geschriebene Programm  einmal laufen.  Sie  sehen in der oberen
rechten Ecke einen  weißen  Rennwagen in  einem Rechteck.  Außerdem haben  Sie
eine     angedeutete Rennstrecke in  dem    unteren  Feld mit einer  Ziellinie
gezeichnet.  Das Auto  ist  noch keine Sprite,  denn  es  fehlt ihm noch   die
Fähigkeit, sich zu bewegen. Dazu ist es notwendig, das gerade gezeichnete Bild
in einer Zeichenkettenvariablen zu speichern.

Fügen Sie hierzu folgende Zeile in ihr Programm ein:

45 SSHAPE A$,11,10,34,31:REM SPEICHERN DES BILDES IN EINEM STRING

Die   Zahlen 11,10,34,31 sind die  Koordinaten  der linken  oberen und rechten
unteren   Ecke  des Bildes.  Sie   müssen die  Position  der Koordinaten genau
bestimmen, sonst besteht  die Gefahr, daß das Sprite  nicht korrekt oder nicht
gespeichert wird.

Die Variable A$ speichert eine binäre Zeichenkette,  die aus Nullen und Einsen
besteht   und  im  Speicher  des  Computers   abgelegt  wird.  Jedem Punkt des
Bildschirms ist ein Bit im grafischen Speicher  des Computers zugeordnet.  Ist
das Bit an (1), ist der Punkt in der  gewählten Vordergrundfarbe sichtbar. Ist
das Bit aus (0), hat der Punkt die gewählte Hintergrundfarbe.

[SEITE 4-147]

Ihr Bild ist nun gespeichert. Im nächsten Schritt wird  das in A$ gespeicherte
Bild in ein Sprite übertragen.

Dies kann durch folgende Anweisungen realisiert werden:

SPRSAV n,v$
SPRSAV v$,n

Mit dieser Anweisung können Sie die in einer Zeichenkettenvariablen abgelegten
Bitmuster als Sprite-Daten verwenden bzw. das  Bitmuster eines Sprites an eine
Zeichenkettenvariable übergeben.

n  Ein ganzzahliger Wert zwischen 1 und 8 für die Sprite-Nummer.
v$ Eine beliebige Zeichenkettenvariable, die die Binärinformation aufnimmt
   oder enthält.

Die folgenden  SPRSAV-Anweisungen legen das  in A$  gespeicherte Bild in  zwei
Sprites ab.

Machen Sie dazu folgenden Ergänzung zu dem bisherigen Programm:

50 SPRSAV A$,1:REM SPEICHERT INHALT VON A$ IN SPRITE 1
55 SPRSAV A$,2:REM SPEICHERT INHALT VON A$ IN SPRITE 2

Bevor Sie die Sprites nun sehen können, müssen Sie diese erst aktivieren.

Dies  geschieht durch  die  SPRITE-Anweisung, die  auch die  Größe des Objekts
bestimmen   kann.   Außerdem   werden   der  grafische   Modus   entweder  als
hochauflösend oder mehrfarbig  durch die SPRITE-Anweisung festgelegt sowie die
Vorder-  und Hintergrundfarben   definiert.    Die   folgenden  Programmzeilen
aktivieren die Sprites:

60 SPRITE 1,1,7,0,0,0,0:REM AKTIVIERT SPRITE 1
65 SPRITE 2,1,3,0,0,0,0:REM AKTIVIERT SPRITE 2

Im folgenden werden die einzelnen Parameter der SPRITE-Anweisung erklärt.

SPRITE n[,[akt][,Farbe][,Pri][,xdehn]
        [,[ydehn][,[Modus]]]]]]

[SEITE 4-148]

           n  Ganzzahliger  Wert  zwischen  1  und  9 für  die Sprite-
              Nummer.

         akt  Ein ganzzahliger  Wert von 0 bis  1, der  angibt, ob das
              Sprite aktiviert (1) oder inaktiviert (0) ist.

       Farbe  Ganzzahliger Wert zwischen   1 und  16 für die   Sprite-
              Farbe.  Die Zuordnung  der Codes zu  den  Farben sind in
              der COLOR- Anweisung (Kapitel 4.6) beschrieben.

         Pri  Ein ganzzahliger Wert  von 0 bis 1.   Bei  0 wandert das
              Sprite während  der Bewegung vor ggfs. vorhandenen Bild-
              schirmobjekten vorbei, bei 1 dahinter.

       xdehn  Ein ganzzahliger  Wert von 0  oder 1, der angibt, ob das
              Sprite in x-Richtung gedehnt ist (1) oder nicht (0).

       ydehn  Ein ganzzahliger Wert von 0  oder 1, der angibt, ob  das
              Sprite in y-Richtung gedehnt ist (1) oder nicht (0).

       Modus  Ein ganzzahliger  Wert von 0 oder  1, der angibt, ob das
              Sprite im hochauflösenden  (0)  oder im Mehrfarben-Modus
              (1) angezeigt werden soll.

Die  MOVSPR-Anweisung gibt Ihrem  Sprite nun die  Bewegung.  Sie plaziert oder
bewegt ein Sprite an eine  bestimmte Stelle  des Bildschirms. Ihre  allgemeine
Form ist:

MOVSPR n,x,y
MOVSPR n,+/-x1,+/-y1
MOVSPR n,Winkel#Geschw

           n  Ein ganzzahliger Wert zwischen 1  und 8, der die  Nummer
              des Sprites angibt.

         x,y  Die absoluten Koordinaten, bei denen das Sprite positio-
              niert werden soll.

 +/-x1,+/-y1  Die  zur letzten  Sprite-Position relativen Koordinaten,
              bei denen das Sprite positioniert werden soll.

      Winkel  Ein ganzzahliger  Wert  zwischen 0 und  360, der angibt,
              unter welchem Winkel des Sprite bewegt werden soll.

[SEITE 4-149]

Fügen Sie bitte folgende Zeilen an Ihr Programm an:

70 MOVSPR 1,240,0:REM POSITION DES SPRITES 1
80 MOVSPR 2,120,0:REM POSITION DES SPRITES 2

Zeile 70   bewirkt,  daß das   Sprite 1   zu  der  Position  240/0 des  Punkt-
koordinatensystems bewegt wird.
Zeile 80  bewirkt analog, daß das  Sprite 2 zu  der Position 120/0  des Punkt-
koordinatensystems bewegt wird.

Folgende Programmzeilen bewegen die Sprites entlang einer definierten Linie:


85 MOVSPR 1,180#6:REM BEWEGT SPRITE 1 VON OBEN NACH UNTEN
87 MOVSPR 2,180#7:REM BEWEGT SPRITE 2 VON OBEN NACH UNTEN

Der erste Wert dieser Anweisung ist  die Sprite-Nummer.  Der zweite Wert (180)
ist der Winkel, unter  dem das Sprite  vom Ausgangspunkt wegbewegt  wird.  Die
letzte Zahl gibt die Geschwindigkeit an, mit der das Sprite bewegt wird.

Nun  lassen Sie einmal  Ihr Programm durchlaufen und  Sie  sehen, daß es Ihnen
gelungen  ist, eine Rennbahn mit  zwei Rennwagen zu programmieren.  Lassen Sie
jetzt Ihrer Phantatsie freien Lauf und probieren Sie eigene Objekte aus.

[SEITE 4-150]

Es folgt noch einmal das komplette Programm:

 5 COLOR 0,1
10 GRAPHIC 1,1
15 BOX 1,2,2,45,45
20 DRAW 1,17,10 TO 28,10 TO 26,30 TO 19,30 TO 17,10
22 DRAW 1,11,10 TO 15,10 TO 15,18 TO 11,18 TO 11,10
24 DRAW 1,30,1O TO 34,10 TO 34,18 TO 30,18 TO 30,10
26 DRAW 1,11,20 TO 15,20 TO 15,28 TO 11,28 TO 11,20
28 DRAW 1,30,20 TO 34,20 TO 34,28 TO 30,28 TO 30,20
30 DRAW 1,26,28 TO 19,28
32 BOX 1,20,14,26,18,90,1
35 BOX 1,150,35,195,40,90,1
37 BOX 1,150,135,195,140,90,1
40 BOX 1,150,215,195,220,90,1
42 DRAW 1,50,180 TO 300,180:DRAW 1,50,180 TO 50,190
43 DRAW 1,300,180 TO 300,190:DRAW 1,50,190 TO 300,190
44 CHAR 1,18,23,"ZIEL"
45 SSHAPE A$,10,10,33,31
50 SPRSAV A$,1
55 SPRSAV A$,2
60 SPRITE 1,1,7,0,0,0,0
65 SPRITE 2,1,3,0,0,0,0
70 MOVSPR 1,240,0
80 MOVSPR 2,120,0
85 MOVSPR 1,180#6
87 MOVSPR 2,180#7

Zeile 5      -  Der Hintergrund des Bildschirms wird schwarz.
Zeile 10     -  Schaltet die hochauflösenden Grafik ein und löscht den
                Bildschirm.
Zeile 15     -  Zeichnet ein Rechteck oben links.
Zeilen 20-32 -  Zeichnen ein Rennauto.
Zeilen 35-44 -  Zeichnen die Rennbahn und die Ziellinie.
Zeilen 50-55 -  Übertragen den Teil der Zeichenketten-Variablen in die
                Sprites 1 und 2.
Zeilen 70-80 -  Bewegen die Sprites zum oberen Bildschirmrand.
Zeilen 85-87 -  Bewegen die Sprites von oben nach unten.

[SEITE 4-151]

VERBINDEN VON SPRITES ZU EINEM GRÖßEREN OBJEKT

Wollen Sie größere Figuren auf Ihrem Bildschirm erstellen, müssen Sie einzelne
Sprites zu der gewünschten Gesamtfigur  zusammenfügen. Die folgende  Anleitung
zeigt Ihnen, wie Sie zwei Sprites zusammenfügen können:


 -      Malen Sie wieder ein beliebiges Bild mit Hilfe der DRAW-, BOX-
        und PAINT-Anweisungen. Verdoppeln Sie diesmal jedoch die Größe
        Ihrer Fläche auf 48 x 21 Punkte.

 -      Benutzen Sie zwei SSHAPE-Anweisungen, um die zwei Sprites ein-
        zeln zu speichern.  Teilen  Sie nun ihre  48 x 21 Punkte große
        Bildfläche in zwei  gleichgroße Bildflächen (24x21) und  spei-
        chern   Sie    die     Sprites   mit  Ihren     entsprechenden
        Koordinaten.  Benutzen  Sie  zwei verschiedene  Zeichenketten-
        variablen (A$).

 -      Übertragen  Sie die Daten  des Bildes in  separate Sprites mit
        Hilfe des SPRSAV-Befehls.

 -      Aktivieren Sie die Sprites mit der SPRITE-Anweisung.

 -      Positionieren Sie das zweite  Sprite  so, daß sich der   erste
        Punkt  des zweiten Sprites  mit  dem letzten Punkt  des ersten
        deckt. Jetzt haben Sie die Sprites miteinander verbunden.

Probieren Sie nun noch folgende Programmzeilen aus:

100 MOVSPR 1,10,10

Der erste  Wert ist  die Sprite-Nummer.  Diese  Anweisung  plaziert  das erste
Sprite an die Position x=10/y=10.  Nun  positionieren Sie das zweite Sprite 24
Punkte rechts vom ersten:

200 MOVSPR 2,34,10


 -      Jetzt ist  es  Ihnene möglich, Sprites  auf  dem Bildschirm zu
        einer von Ihnen gewünschten Position zu bewegen.

[SEITE 4-152]

Zum Abschluß noch ein Beispiel für verbundene Sprites:

 10 COLOR 0,1:REM HINTERGRUND SCHWARZ
 20 GRAPHIC 1,1:REM LOESCHT BILDSCHIRM
 30 BOX 1,1,1,51,25:REM RECHTECK UM SPRITES
 40 DRAW 1,3,3 TO 40,3 TO 47,12 TO 0,19 TO 3,3
 45 REM ZEICHNET EINE RAKETE
 50 CHAR 1,1,1"RAKT":REM SCHREIBT RAKT IN DIE RAKETE
 60 SSHAPE C$,2,2,25,22:REM SICHERT TEIL 1 IN C$
 70 SSHAPE D$,26,2,48,22:REM SICHERT TEIL 2 IN D$
 80 SPRSAV C$,1:REM SPEICHERT C$ IN SPRITE 1
 90 SPRSAV D$,2:REM SPEICHERT D$ IN SPRITE 2
100 SPRITE 1,1,2,0,0,0,0:REM AKTIVIERT SPRITE 1
110 SPRITE 2,1,2,0,0,0,0:REM AKTIVIERT SPRITE 2
120 MOVSPR 1,80,100:REM VERSCHIEBT SPRITE 1
130 MOVSPR 2,104,100:REM VERSCHIEBT SPRITE 2

4.8 KLÄNGE UND MUSIK MIT DEM C128

Der C128  hat im Vergleich zu  anderen  Microcomputern eine äußerst leistungs-
fähigen Musik- und Geräusch-Synthesizer. Der Klangbaustein (SID-Chip) befähigt
den C128,  drei verschiedene  Töne  gleichzeitig zu  erzeugen.  Jeder Ton kann
außerdem in  vier verschiedenen Klangfarben  gespielt werden.  Der Synthesizer
erlaubt  programmierbare  Anschlagzeit, Abschwellzeit, Haltezeit und Auskling-
zeit (ADSR-Parameter) und hat die Fähigkeit, bestimmte Töne hervorzuheben oder
auszublenden.  Außerdem besitzt der  SID ein programmierbares Filter,  mit dem
Klänge und Geräusche verändert werden können.

Um die Möglichkeiten  des SID-Bausteins voll zu nutzen,  bietet das  BASIC 7.0
des C128 eine Reihe neuer Anweisungen. Sie  machen das Programmieren von Musik
schneller und einfacher.

Um   Ihre eigenen  "Videoclips" zu  erstellen,  können  Sie jetzt Ihre Grafik-
programme   mit  eigener  Musik  kombinieren.   Dies  sind   die  neuen Musik-
Anweisungen dafür:

SOUND
ENVELOPE
VOL
TEMPO
PLAY
FILTER

[SEITE 4-153]

Wie in den vorherigen Abschnitten wird jeder einzelne  Befehl kurz erklärt. Im
Laufe dieser Beschreibungen entsteht dann wieder ein kleines Programm.

Die SOUND-Anweisung ermöglicht es Ihnen,  schnell und einfach Ton- oder Klang-
effekte wählbarer Frequenz und Dauer zu erzeugen und sie über den Monitor oder
ein Fernsehgerät auszugeben:

SOUND Stimme,Frequenz,Dauer[,[Richtung]
        [,[Maxfr][,[Stufe][,[Welle][,Impbr]]]]]

Die einzelnen Parameter bedeuten:

     Stimme  Sie können von 1 bis 3 wählen:

             1       Stimme 1 (Ton)
             2       Stimme 2 (Ton)
             3       Stimme 3 (Ton)

   Frequenz  Ein ganzzahliger Wert  zwischen  0  und 65535  wählt  die
             Frequenz.

      Dauer  Sagt, wie lange  der Ton anhalten  soll (in Schritten von
             60stel Sekunden).  Ein ganzzahliger  Wert zwischen 0  und
             32767.

   Richtung  ganzzahliger Wert zwischen 0 und 2.

      Maxfr  ganzzahliger Wert zwischen 0 und 65535.

      Stufe  ganzzahliger Wert zwsichen 0 und 32767.

      Welle  ganzzahliger Wert zwischen 0 und 3 mit folgender Bedeutung:

             0 Dreieck
             1 Sägezahn
             2 Rechteck
             3 Rauschen

             Voreingestellt ist 2.


      Impbr  ganzzahliger Wert  zwischen  0  und 4095.  Bestimmt   das
             Tastverhältnis.

Nähere Angaben über die SOUND-Anweisung entnehmen Sie bitte dem Kapitel 4.6.

[SEITE 4-154]

Wollen sie z.B. einen Ton von 1 Sekunde  erzeugen, muß der  Wert für die Dauer
von einer Sekunde 60, für 10 Sekunden 600 usw. sein.

Nun probieren Sie bitte folgendes kurzes Programm:

10 VOL 5
20 SOUND 1,512,60

Lassen Sie das Programm laufen. Der C128 spielt einen kurzen Ton. Die Zeile 10
bestimmt die Lautstärke. Die Zahl 512 in Zeile 20 bestimmt die Frequenz.

Ändern Sie jetzt die Tonhöhe mit folgender Zeile:

30 SOUND 1,1000,60

Sie  hören, daß der Ton  wesentlich höher ist, als  der vorhergehende.  Aller-
dings werden beide Töne nur eine Sekunde gespielt.

Versuchen Sie folgendes:

40 SOUND 1,0,60

Sie hören den tiefsten Ton, der möglich ist.

Nun durchlaufen  Sie  die von 0-65535  reichenden Tonhöhen   in einer Schleife
(FOR ... NEXT):

50 FOR I=0 TO 65535
60 SOUND 1,I,1
70 NEXT

Dieser Programmteil  durchläuft den gesamten definierbaren Frequenzbereich von
unten nach oben.

Ersetzen Sie jetzt die Zeile 60 durch die folgende:

60 SOUND 3,I,1,,,,3

Jetzt durchläuft das Programm den gesamten Bereich  des Rauschgenerators.  Die
niedrigen Frequenzen  klingen wie  Rumpeln,   die hohen  Frequenzen wie   eine
startende Rakete.

[SEITE 4-155]

Probieren Sie einmal folgende Variante aus.  Es handelt sich dabei um ein Pro-
gramm, das eine Flugzeugschlacht durch verschiedene Geräusche simuliert.

 10 REM FLUGZEUGSCHLACHT
 20 VOL 5
 30 FOR I=850 TO 1015
 40 SOUND 3,I,1
 50 SOUND 1,1015-I,1
 60 NEXT
 70 SOUND 3,965,60,,,,3
 80 FOR I=1023 TO 850 STEP -1
 90 SOUND 3,I,1
100 SOUND 1,I-150,1
110 NEXT
120 FOR J=1000 TO 0 STEP -7
130 SOUND 3,J,1
140 NEXT
150 SOUND 3,965,60,,,,3
160 GOTO 30

Durch Drücken der STOP-Taste können Sie das Programm beenden.

Im folgenden werden noch einmal die einzelnen Befehlszeilen erläutert:

Zeile   20      stellt die Lautstärke auf 5.
Zeilen  30-60   bewirken  das eigentliche Fluggeräusch.  Wie Sie sehen
                und hören, nimmt die Tonhöhe  bei Zeile 30 ab und  bei
                Zeile 50 zu.

Zeile   70      erzeugt ein Maschinengewehrgeräusch.
Zeilen  80-110  produzieren das Geräusch eines abstürzenden Flugzeugs.
                Damit   der   Absturz realistischer  wirkt, setzen die
                Tonhöhen unterschiedlich ein (s. Zeile 90 u. 100).
Zeilen 120-140  erzeugen  das Detonationsgeräusch  des Flugzeugs  beim
                Aufprall.
Zeile  150      entspricht der  Zeile 70.
Zeile  160      veranlaßt die Programmwiederholung ab Zeile 30.

Die SOUND-Anweisung ist  eigentlich nur dazu geacht, musikalische Nebeneffekte
zu erzielen.  Wollen  Sie richtige Lieder auf  ihrem C128 spielen, können  Sie
andere Befehl nutzen.

[SEITE 4-156]

GERÄUSCHE UND MUSIK IM C128-MODUS

Zu Beginn einige Grundlagen:

Jeder  Ton, den sie  hören, ist eine durch  die Luft übertragene Welle.  Diese
Tonwelle bewegt sich mit einer bestimmten Geschwindigkeit (Frequenz).

            Lautstärke ^
                       |
                       |  .---.
                       |.'     `         .
                       |        `       '
                       |         `.___.'
                       |
                       |
                       +-------------------> t
                                             Zeit

Die Klangfarbe der Töne wird durch ihre Wellenform bestimmt.

Der C128 kann vier verschiedene Wellenformen erzeugen:

         +--------------------------------------------
         |    /\      /\      /\      /\
         |   /  \    /  \    /  \    /  \
Dreieck  |  /    \  /    \  /    \  /    \
         | /      \/      \/      \/      \
         |
         |   /|  /|  /|  /|  /|  /|  /|  /|
Sägezahn |  / | / | / | / | / | / | / | / |
         | /  |/  |/  |/  |/  |/  |/  |/  |
         |
         |        +-------+       +-------+
         |        |       |       |       |
Rechteck |        |       |       |       |
         | -------+       +-------+       |
         |
         +------------------------------------------->
                                                 Zeit

MUSIKERZEUGUNG MIT DEM C128

Zum Verändern  der Klangfarbe  eines  Tones können  Sie die ENVELOPE-Anweisung
benutzen. Sie kontrolliert die ADSR-Parameter und die Wellenform.

Das allgemeine Format der ENVELOPE-Anweisung ist wie folgt:

ENVELOPE n[,[An][,Ab][,[Ha][,[Au][,[Wf]
        [,[Ib]]]]]]

[SEITE 4-157]

Die einzelnen Parameter bedeuten:

 n - Nummer der Hüllkurve (0 bis 9),
An - Anschlagzeit  (0 bis 15),
Ab - Abschwellzeit (0 bis 15),
Ha - Haltezeit     (0 bis 15),
Au - Ausklingzeit  (0 bis 15),
Wf - Wellenform :
     0 Dreieck
     1 Sägezahn
     2 Rechteck
     3 Rauschen
     4 Ringmodulation

Ib - Impulsbreite (0 bis 4095).

Lassen Sie  uns die einzelnen Begriffe  wie Hüllkurve,  Wellenform und Impuls-
breite erläutern:

Die  Hüllkurve ist das  Zusammenspiel der einzelnen Faktoren (ADSR-Parameter),
die den Lautstärkeverlauf eines  Tones ausmachen (Anschlagzeit, Abschwellzeit,
Haltezeit und  Ausklingzeit). Eine Gitarre  hat z.B. andere ADSR-Parameter als
eine Flöte.

Unter  der Wellenform versteht man  die Art der   Wellen, die z.B.  ein Musik-
instrument  erzeugt.  Sie  enstehen  durch die  Kombination  von musikalischen
Harmonischen eines Tones. Harmonische sind das Vielfache des Grundtones.

Die Impulsbreiten sind Veränderungen  der Rechteckform, wodurch sich auch  das
Verhältnis der Harmonischen zueinander verändert.

Sie sehen also, daß die  ENVELOPE-Anweisung die Programmierung der grundlegen-
den Musikbestandteile erlaubt.

Der C128 bietet bereits Klangarben für 10 verschiedene Musikinstrumente, deren
ADSR-Parameter bereits voreingestellt sind  und die mit der ENVELOPE-Anweisung
noch verändert werden können.  Sie brauchen  nur die entsprechende Hüllkurven-
Nummer einzugeben und der C128 liefert die vorprogrammierten Parameter selbst.

Wenn Sie eigene Hüllkurven mit neuen Klangformen  erstellen wollen, müssen Sie
die einzelnen Parameter der ENVELOPE-Anweisung ändern.

[SEITE 4-158]

Weitere  Einzelheiten zu den vorprogrammierten  Hüllkurven entnehmen Sie bitte
der nachfolgenden Tabelle:

0       0       9       0       0       2       1536    Klavier
1       12      0       12      0       1               Akkordeon
2       0       0       15      0       0               Zirkusorgel
3       0       5       5       0       3               Trommel
4       9       4       4       0       0               Flöte
5       0       9       2       1       1               Gitarre
6       0       9       0       0       2       512     Cemballo
7       0       9       9       0       2       2048    Orgel
8       8       9       4       1       2       512     Trompete
9       0       9       0       0       0               Xylophon


Geben Sie nun die folgende Programmzeile ein.

10 ENVELOPE 9,10,5,10,5,2,4000:PLAY"T9"

Der nächste Schritt bestimmt die Lautstärke ihres Musikprogramms.

20 VOL 8

Die VOL-Anweisung gibt  die  Lautstärke zwischen 0   und  15 an,  wobei 0  das
Minimum (aus) und 15 das Maximum ist.

Mit der PLAY-Anweisung können Sie Noten spielen:

PLAY"Zeichenkette"

Zeichenkette  - ist  eine Zeichenkette aus  speziellen Buchstabenbefehlen, die
die Tonerzeugung   und  Abspielfolge festlegen.   Die Bedeutung  der einzelnen
Parameter entnehmen Sie bitte dem Kapitel 4.6.

Der nächste Schritt kontrolliert das Spieltempo für die gewünschten Noten. Die
TEMPO-Anweisung hilft Ihnen dabei.

Hier ist die allgemeine Form:

TEMPO n

[SEITE 4-159]

n muß ein  ganzzahliger Wert zwischen 0 und  255 sein. Fehlt in ihrem Programm
dieser Befehl, so setzt der Computer die Länge  8 fest. Die tatsächliche Dauer
berechnet sich:

Dauer = 19.22/n in Sekunden

Setzen Sie das Tempo = 0, so wird die Note gehalten.

Schreiben Sie nun folgende Programmzeile:

30 TEMPO 100

Es wird jetzt Zeit, zu lernen, wie Sie ein Lied spielen können. dies geschieht
analog  zum  PRINT-Befehl,  indem     Sie  die  gewünschten  Noten   bei   der
PLAY-Anweisung in Anführungszeichen eingeben.

Mit folgender PLAY-Anweisung spielt der Computer die Tonleiter:

40 PLAY"C D E F G A B"                  Anm.: Der Note B entspricht im
                                        Deutschen die Note H.

Sie können nun folgende Zeichen vor die einzelnen Noten setzen.

# - Die Note wird einen halben Ton höher gespielt.
$ - Die Note wird einen halben Ton niedriger gespielt.
. - verlängert die Note um die Hälfte ihres Wertes.

Sie können außerdem  die Dauer  der  Töne variieren, indem Sie  folgende Buch-
staben vor die einzelnen Noten setzen:

W - Die folgende Note wird als ganze Note gespielt.
H - Die folgende Note wird als halbe Note gespielt.
Q - Die folgende Note wird als viertel Note gespielt.
I - Die folgende Note wird als achtel Note gespielt.
S - Die folgende Note wird als sechzehntel gespielt.

[SEITE 4-160]

Durch ein in Anführungsstriche gesetztes "R" erreichen sie,  daß der Ton ange-
halten wird.

Es  ist weiter  möglich, den Synthesizer   des C128 durch  zusätzliche Steuer-
zeichen in der PLAY-Anweisung  für unterschiedliche Effekte beim Abspielen von
Musik zu programmieren.

Diese folgen in einer Tabelle:

Kontrollzeichen         Beschreibung    Bereich         Voreinstell.

Un                      Lautstärke      0-9             9
Tn                      Hüllkurve       0-9             0
Vn                      Stimme          1-3             0
Xn                      Filter          0=an,1=aus      0
On                      Oktave          0-6             4

Normalerweise  brauchen Sie die  Steuerzeichen  nicht zu benutzen. Sie  können
jedoch  damit  die  Möglichkeiten des  Synthesizers  erheblich differenzierter
ausschöpfen. Wenn Sie in der PLAY-Anweisung  mit in eine Hüllkurve definieren,
so achten Sie darauf,  daß der gewählte Wert die  Hüllkurve betrifft,  für die
Sie mit der ENVELOPE-Anweisung Ihre spezifische Parameter gesetzt haben.

Weil der SID-Chip nur ein Filter hat, wird es bei allen drei Stimmen genutzt.

Fügen Sie folgende Programmzeilen  an Ihr bisheriges  Programm und  achten Sie
auf den Unterschied zu Zeile 40:

50 PLAY"U5 V1 O5 C D E F G A B"

Diese Zeile spielt ebenfalls die Tonleiter,  allerdings ist die Lautstärke auf
5 heruntergesetzt, die Stimme 1 wurde gewählt und die Noten werden eine Oktave
(5) höher gespielt. Nun Ihr Programm zwei parallele Stimmen.

Eine 3. Stimme bei eingeschaltetem Filter können  Sie durch die folgende Zeile
erreichen:

60 PLAY"U7 V3 O6 X1 C D E F G A B"

[SEITE 4-161]

Hier werden noch einmal die einzelnen Zeichen der Zeile 60 kurz erklärt.

U7 - setzt die Lautstärke auf 7
V3 - wählt die 3. Stimme
O6 - setzt die 3. Stimme auf die 6. Oktave
X1 - stellt das Filter an

Nähere  Angaben entnehmen  Sie  bitte der  Beschreibung  der PLAY-Anweisung in
Kapitel 4.6.

Ihr Programm spielt  nun alle drei  Stimmen.  Jede eine  Oktave  höher als die
vorhergehende.

Bis zu diesem Zeitpunkt haben Sie nur ganze Noten  gespielt. In einem weiteren
Programmbeispiel sollen auch halbe, achtel usw. Noten gespielt werden.

Ändern Sie die Noten, indem Sie die oben genannten Buchstaben einfügen:

70 PLAY "U7 V2 O6 X1 H CD Q EF I GA S B"

Zeile 70  spielt in der  6. Oktave mit der Stimme  2 in  der Lautstärke 7. Das
Filter ist eingeschaltet.

Hier eine Erläuterung der zusätzlichen Steuerzeichen in der PLAY-Anweisung:

C und D werden als halbe Noten gespielt.
E und F werden als viertel Noten gespielt.
G und A werden als achtel Noten gespielt.
B wird als sechzehntel Note gespielt.

Nun ergänzen Sie die Noten, indem Sie  die Töne um  eine halbe Oktave erhöhen,
erniedrigen oder die Töne verlängern:

80 PLAY "U8 V0 O4 X0 . H CD Q# EF I$ GA . S# B"

C und D werden als halbe Noten um die Hälfte ihres Wertes verlängert.
E und F - werden als viertel Noten eine halbe Oktave höher gespielt.
G und A - werden als achtel Noten eine halbe Oktave niedriger gespielt.
B - wird um die Hälfte des Wertes verlängert und einen halben Ton höher
gespielt.

[SEITE 4-162]

Wenn Sie  schon die Wellenform,  ADSR-Parameter, Lautstärke  und Tempo gewählt
haben, sollten   Sie nun  das  Filter  wählen. Die  FILTER-Anweisung verändert
ebenfalls Klangfarbe und -höhe.

Das im SID eingebaute Filter gibt Ihnen die Möglichkeit die Wellenform hervor-
zuheben oder zu eleminieren.  Damit ändert  das Filter das Timbre (Klangfarbe)
eines Tons.

Der SID-Chip kann drei verschiedene Filtertypen simulieren:


1. Tiefpaß Filter
2. Hochpaß Filter
3. Bandpaß Filter

L ^                             Der Tiefpaß schneidet  alle Frequenzen ab, die
  |                             oberhalb  der  Grenzfrequenz  liegen und  läßt
  |                             alle Töne durch, die unterhalb liegen. Der Ton
  |        |                    klingt voluminös bis dumpf.
  |-----.  |
  |      \ |
  |       \|
  |        \
  |        |\
  |        | `--------
  +--------+-----------------> f
           Tp        Frequenz

L ^                             Analog  dazu läßt  der Hochpaß  nur Frequenzen
  |                             durch, die  oberhalb der Grenzfrequenz liegen.
  |                             Die  darunterliegenden  werden  abgeschnitten.
  |     |                       Der Ton klingt dünn bis scharf.
  |     |  .----------
  |     | /
  |     |/
  |     /
  |    /|
  |---' |
  +-----+--------------------> f
        Hp           Frequenz

L ^                             Der  Bandpaß läßt  nur  Frequenzen durch,  die
  |                             oberhalb  einer  unteren  und unterhalb  einer
  |                 T2          oberen  Grenzfrequenz liegen.  Der  Ton klingt
  |     |           |           hohl oder wie ein Stimmlaut.
  |     |  .-----.  |
  |     | /       \ |
  |     |/         \|
  |     /           \
  |    /|           |\
  |---' |           | `-----
  +-----+--------------------> f
        T1           Frequenz

[SEITE 4-163]

Die FILTER-Anweisung legt die Grenzfrequenz, den  Filtertyp sowie die Resonanz
fest.

Die allgemeine Form lautet:

FILTER [Freq][,[Typ][,[Bp][,[Hp][,[Res]]]]]

Die Erklärung der einzelnenen Parameter:

       Freq  Ein   ganzzahliger  Wert  zwischen 0   und 2047,  der die
             Filterfrequenz festlegt.

         Tp  schaltet den Tiefpaß
             (0 = aus, 1 = an)

         Bp  schaltet den Bandpaß
             (0 = aus, 1 = an)

         Hp  schaltet den Hochpaßfilter
             (0 = aus, 1 = an)

        Res  Ein ganzzahliger Wert zwischen 0 und 15, der die Resonanz
             festlegt.

Ergänzen Sie ihr Programm um die folgende Zeile:

35 FILTER 1023,1,0,0,10

Die  Zeile 35 setzt die Grenzfrequenz  auf 1023 und schaltet das Tiefpaßfilter
ein.   Das Hochpaßfilter und  der Bandpaß werden ausgeschaltet.  Außerdem wird
die Resonanz auf 10 eingestellt. Hören sie, wie die Töne klingen.

Jetzt ändern Sie die Zeile 35 wie folgt:

35 FILTER 1023,0,1,0,10

Dies  bewirkt,  daß das Tiefpaßfilter  aus und  gleichzeitig das Bandpaßfilter
eingeschaltet wird. Hören Sie sich jetzt noch einmal die Töne an.

Ändern Sie die Zeile 35 wie folgt ab:

35 FILTER 1023,0,0,1,10

[SEITE 4-164]

Achten Sie auf den Unterschied, wenn ein Filter nach dem anderen ausgeschaltet
wird. Experimentieren Sie noch ein wenig  mit den einzelnen Filtern. Hier sind
einige Beispiele für Filterbefehle mit anderem Grenzfrequenzen.

35 FILTER 2000,0,0,1,15
35 FILTER 1500,0,1,0,5
35 FILTER 1000,1,0,0,8


Das erste Beispiel setzt die Grenzfreuenz auf  2000 und wählt die Resonanz 15.
Das Hochpaßfilter ist eingeschaltet.
Das zweite Beispel setzt die Grenzfrequenz  auf 1500, legt  die Resonanz auf 5
fest und schaltet das Bandpaßfilter ein.
Beim dritten  Beispiel ist   die  Grenzfrequenz auf  1000 festgelegt  und  die
Resonanz auf 8. Das Tiefpaßfilter ist eingeschaltet.

SCHREIBEN EINES MUSIKPROGRAMMS

Lassen Sie uns   einmal    die einzelnen Bestandteile     eines Musikprogramms
zusammenfügen.

Hier ist ein Beispielprogramm:

10 ENVELOPE 9,10,5,10,5,2,4000:PLAY"T9"
20 VOL 8
30 TEMPO 30
35 FILTER 1024,0,1,0,10
40 PLAY"C D E F G A E"
50 PLAY"U5 V1 O5 C D E F G A B"
60 PLAY"U7 V2 O6 X1 C D E F G A B"
70 PLAY"U7 V2 O6 X1 H CD Q# EF I$ GA . S# B"
80 PLAY"U8 V1 O4 X0 . H CD Q# EF I$ GA . S# B"

Es folgt eine systematische Erklärung der einzelnen Programmzeilen.

Zeile 10 wählt die  Hüllkurve  9.   Die  PLAY-Anweisung  übernimmt die
         neuen ADSR-Parameter.
Zeile 20 setzt die Lautstärke auf die Stufe 8.
Zeile 30 bestimmt das Tempo.
Zeile 35 filtert  die Noten der Zeilen  60-70.  Die Grenzfrequenz wird
         bei  1024  festgelegt.  Das  Hochpaßfilter wird eingeschaltet
         und die Resonanzfrequenz bei 10 festgelegt.
Zeile 40 spielt die Noten C D E F G A B (Tonleiter).
Zeile 50 spielt die gleichen Noten wie Zeile 40.  Setzt die Oktave und
         die Lautstärke auf 5 fest.

[SEITE 4-165]

Zeile 60 spielt  die gleichen Noten wie  in Zeile 40  und 50, nur  mit
         geänderter Lautstärke, anderer   Stimme  und anderer  Oktave.
         Das Filter ist eingeschaltet.
Zeile 70 unterscheidet sich von den vorherigen Zeilen, indem ihre Töne
         auf  halbe,   viertel,   achtel, sechzehntel  Noten  geändert
         werden.
Zeile 80 spielt die   gleiche Melodie wie  Zeile  70, das  Filter  ist
         jedoch ausgeschaltet.


Nun haben Sie  alle  Informationen, die Sie brauchen,  um  Ihre eigenen Musik-
programme zu schreiben.

Versuchen Sie einmal, die Noten  eines  bekannten Musikstücks in den  Computer
einzugeben und verbinden Sie ein Grafikprogramm mit Ihrem Musikprogramm.


WEITERE MÖGLICHKEITEN DES FILTERS

Bisher haben Sie immer nur jeweils  eine Filterkombination benutzt. Sie können
aber auch alle drei Filtermöglichkeiten kombinieren.


L ^
  |
  |
  |
  |-----.    .----      Das  Kerbfilter   (Notch  reject  Filter)   läßt  alle
  |     |    |          Frequenzen oberhalb  und unterhalb der Grenzfrequenzen
  |     |    |          durch,  außer  den  Frequenzen,  die  im  Bereich  des
  |     `----'          Bandpaßfilters liegen.
  +------------------>
             Frequenz

L ^
  |
  |     .----.
  |     |    |
  |     |    |          Sie können  auch Tiefpaß-, Hochpaß-  und Bandpaßfilter
  |     |    |          miteinander   verbinden.   Verbinden   sie  z.B.   das
  |-----'    |          Bandpaßfilter  mit dem  Tiefpaßfilter, so  werden alle
  |          `----      Frequenzen, die in diesem Bereich liegen, angehoben.
  +------------------>
             Frequenz

[SEITE 4-166]

L ^
  |
  |     .----.
  |     |    |
  |     |    |
  |     |    `----      Durch das  Kombinieren von Bandpaß-  und Hochpaßfilter
  |     |               werden  alle  Frequenzen  oberhalb  der  Grenzfrequenz
  |-----'               hervorgehoben.
  +------------------>
                    P

Experimentieren Sie einmal mit den Filtern, um die verschiedenen Möglichkeiten
der Musikgestaltung kennenzulernen.

KAPITEL 5

5. C64-Modus

   5.1 BASIC 2.0 im C64-Modus
   5.2 Befehle, Anweisungen, Funktionen und Variable
   5.3 Farben und Grafik im C64-Modus
   5.4 Musik im C64-Modus

[5-1]

5. C64-Modus

Die Tastaturbedienung im C64-Modus ist in Kapitel 3.1 ausführlich beschrieben,
so daß hier nicht noch einmal näher darauf eingegangen wird.

-------------------------------------------------------------------------+
Achtung: Der C64-Modus unterstützt in jedem Fall jedoch nur die
ASCII-Tastatur.
Wird in den C64-Modus geschaltet, sollte die ASCII/DIN-Taste vorher
freigegeben, also entriegelt werden, da sonst die Tastaturbelegung
nicht mir der Tastenbeschriftune übereinstimmt.
-------------------------------------------------------------------------+

5.1 BASIC 2.0 IM C64-MODUS

Dieser  Abschnitt  ist  kein Leitfaden zum  Erlernen  allgemeiner Programmier-
techniken oder der  Programmiersprache BASIC, sondern ein Nachschlagewerk  für
mit allgemeinen Programmierkonzepten   vertraute Anwender, die  auf den  nach-
folgenden  Seiten alle  wissenswerten   Fakten für  die  Erstellung effektiver
BASIC-Programme finden.  Anfängern wird  die  Lektüre  der in der   Commodore-
Sachbuchreihe veröffentlichten BASIC-Kurse empfohlen.

In diesem Abschnitt wird der Sprachumfang  der Grundversion 2.0 des Commodore-
BASIC beschrieben. Diese Version ist sowohl für den C64-Modus als auch für den
C128-Modus gültig.  Kapitel 4 (C128-Modus) enthält die Beschreibung der Erwei-
terungen des Commodore-BASIC  zur Version 7.0, wie sie  nur für den C128-Modus
gültig sind.

Da  die  Sprachstruktur und  die Syntax  für  die nachfolgenden Beschreibungen
bereits im Kapitel 4.1 bis 4.4 behandelt wurden, wird hier darauf verzichtet.

5.2 BESCHREIBUNGEN DER EINZELNEN BEFEHLE, ANWEISUNGEN, FUNKTIONEN
    UND VARIABLEN

Zur Erleichterung  des  Auffindens eines  bestimmten BASIC-Befehls  oder einer
-Anweisung, -Funktion  oder -Variablen  sind die  nachfolgenden Beschreibungen
nicht entsprechend der in Kapitel  4.4 beschriebenen Sprachstruktur von  BASIC
gegliedert, sondern es   sind alle  Sprachelemente zusammengefaßt und   alpha-
betisch geordnet.

[5-2]

ABS-Funktion

Format:       v=ABS(x)

Zweck:        Liefert den Absolutwert des Ausdrucks x.

Beispiel:     PRINT ABS(7*(-5))
              35
              READY.

[5-3]

ASC-Funktion

Format:       v=ASC(x$)

Zweck:        Liefert einen  numerischen, ganzzahligen Wert zwischen 0
              und 255,  der  den ASCII-Code  des  ersten Zeichens  der
              Zeichenkette x$ repräsentiert.  Ist x$ eine Zeichenkette
              der Länge 0 (Leerstring), so wird eine ILLEGAL QUANTITY-
              Fehlermeldung ausgegeben.

Beispiel:     10 A$="TEST"
              20 PRINT(A$)
              RUN
              84
              READY.

[5-4]

ATN-Funktion

Format:       v=ATN(x)

Zweck:        Liefert den Arcus Tangens  von x im Bogenmaß  im Bereich
              -PI/2 bis PI/2.   Der Ausdruck x   kann von jedem  nume-
              rischen  Typ sein;  die Berechnung  von ATN erfolgt  auf
              jeden Fall binär im Gleitkommaformat.

Beispiel:     10 INPUTA
              20 PRINT ATN(A)
              RUN
              ?3
              1.24904577
              READY.
[5-5]

CHR$-Funktion

Format:       v$=CHR$(n)

Zweck:        Liefert  eine  Ein-Byte-Zeichenkette, deren  Zeichen den
              ASCII-Code  n hat.  Deshalb  muß n im Bereich zwischen 0
              und 255 liegen.   CHR$ wird gewöhnlich   dazu verwendet,
              spezielle Zeichen oder Steuercodes zu erzeugen.

Beispiele:    PRINT CHR$(147)

              Löscht den Bildschirm

              PRINT CHR$(66)

              Druckt ein B an der Cursorposition

[5-6]

CLOSE-Anweisung

Format:       CLOSE Filenummer

Zweck:        Beendet die Ein-/Ausgabe über einen Ein-/Ausgabe-Kanal.

Bemerkungen:  Filenummer ist die Nummer zwischen  1 und 255, unter der
              die Datei mit der OPEN-Anweisung eröffnet wurde.

              Der Zusammenhang zwischen einer bestimmten Datei und der
              Filenummer wird    durch die  CLOSE-Anweisung     aufge-
              hoben. Die Datei kann  dann mit der OPEN-Anweisung unter
              derselben  oder einer anderen Filenummer wieder eröffnet
              werden, oder es  kann eine beliebige  andere Datei unter
              dieser Filenummer eröffnet werden.

              CLOSE, auf   eine sequentielle Ausgabedatei  angewendet,
              schreibt den  letzten  Datenpuffer  in  die  Datei   und
              schließt diese mit einer Dateiendemarke ab.

Beispiel:     10 OPEN4,4
              20 PRINT#4,"DIESES SIND DRUCKDATEN"
              30 CLOSE4
[5-7]

Format:       CLR

Zweck:        Setzt alle numerischen Variablen auf Null, alle Zeichen-
              kettenvariablen  auf   die  Länge 0,  leert  den Stapel-
              speicher  und  den  Speicher  für Felder  und  setzt den
              Zeiger  für  freien Speicherplatz auf den  Wert zurückt,
              der  sich aus der  Größe des   BASIC-Programms ohne alle
              Variablen ergibt.

Bemerkungen:  CLR kann auch innerhalb eines BASIC-Programms ausgeführt
              werden.  Das Programm kann dann fortgesetzt werden, wenn
              die oben beschriebenen Bedingungen, insbesondere solche,
              die sich auf GOSUB beziehen, berücksichtigt werden.

Beispiel:     X=25
              CLR
              PRINT X
              0
              READY.
[5-8]

CMD-Befehl

Format:       CMD Filenummer[,Liste von Ausdrücken]

Zweck:        Adressiert ein Gerät an einer Ein-/Ausgabe-Schnittstelle
              und  läßt  dieses  Gerät   nach der  Ausgabeoperation im
              adressierten Zustand.

Bemerkungen:  CMD hat dieselbe Parameterliste wie die PRINT#-Anweisung
              (s.  dort).

Beispiel:     REM PROGRAMMLISTE AUF DRUCKER AUSGEBEN
              OPEN4,4
              CMD4,"PROGRAMMLISTE"
              LIST
              PRINT#4,"CMD-MODUS WIRD BEENDET"
              CLOSE4

[5-9]

CONT-Befehl

Format:       CONT

Zweck:        Setzt  ein Programm, das  durch  Drücken der  STOP-Taste
              oder  durch  die STOP-  oder  END-Anweisung unterbrochen
              oder beendet wurde, fort.

Bemerkungen:  Die Programmausführung wird  unmittelbar an der  Stelle,
              an der die  Unterbrechung auftrat, fortgesetzt. Wenn die
              Unterbrechung nach der Textanzeige einer INPUT-Anweisung
              durch  Drücken  der RETURN-Taste  ohne  vorherige  Text-
              eingabe erfolgte, wird das Programm mit der Wiederholung
              dieser Anzeige (? oder Text) fortgesetzt.

              CONT  wird üblicherweise  in  Verbindung mit  der  STOP-
              Anweisung  zur Fehlersuche in Programmen verwendet. Nach
              der   Programmunterbrechung   können  Zwischenergebnisse
              angezeigt oder durch  Direkt-Modus-Anweisungen verändert
              werden.  Die Programmausführung wird mit der Eingabe von
              CONT oder  GOTO zusammen  mit  einer  bestimmten Zeilen-
              nummer im Direkt-Modus fortgesetzt.

              CONT ist ungültig, wenn  das Programm mit einer  Fehler-
              meldung abgebrochen wurde oder während der Unterbrechung
              verändert wurde.

Beispiel:     Siehe Beispiel bei der STOP-Anweisung.

[5-10]

COS-Funktion

Format:       v=COS(x)

Zweck:        Liefert  den Cosinus von  x  im Bogenmaß. Die Berechnung
              von COS(x) erfolgt binär im Gleitkommaformat.

Beispiel:     10 X=2*COS(.4)
              20 PRINTX
              RUN
              1.84212199
              READY.
[5-11]

DATA-Anweisung

Format:       DATA Konstantenliste

Zweck:        Speichert numerische und/oder  Zeichenketten-Konstanten,
              auf  die  mit der  READ-Anweisung  (s. dort) zugegriffen
              werden kann.

Bemerkungen:  DATA-Anweisungen sind nicht ausführbare Anweisungen, die
              an  beliebiger Stelle im   Programm stehen können.  Jede
              DATA-Anweisung kann  soviele Konstanten  enthalten  wie,
              getrennt   durch   Kommata,   in  eine  Befehlszeile (80
              Zeichen) passen.   Die  Zahl  der  DATA-Anweisungen  ist
              beliebig.  Die READ-Anweisung  liest die einzelnen DATA-
              Zeilen in der  Reihenfolge ihrer  Zeilennummern.  Die in
              diesen  Zeilen enthaltenen  Daten werden unabhängig  von
              ihrer  Zahl   und   deren Plazierung  im  Programm   als
              kontinuierliche Elementliste aufgefaßt.

              Konstantenliste kann Zeichenketten- und/oder  numerische
              Konstanten  jeden   Formats, d.h.    Zeichenketten sowie
              Gleitkomma-  oder  ganze  Zahlen enthalten.   Numerische
              Ausdrücke  sind nicht erlaubt.  Zeichenketten-Konstanten
              in DATA-Anweisungen müssen nur dann in Anführungsstriche
              (")  eingekleidet  werden, wenn sie Kommas, Doppelpunkte
              oder vor- und/oder nachstehende signifikante Leerstellen
              enthalten.

              Der   in  der  READ-Anweisung  deklarierte  Variablentyp
              (numerisch oder     Zeichenkette) muß  mit   dem  in den
              zugehörigen  DATA-Anweisungen  enthaltenen Konstantentyp
              übereinstimmen.

[5-12]

              Der Lesezeiger kann  mit der RESTORE-Anweisung (s. dort)
              auf   den  Anfang der   ersten  DATA-Anweisung  gestellt
              werden.

Beispiel:     10 DATA"DAS","WETTER","IST","HEUTE","SCHOEN!"
              20 FOR I=1TO5
              30 READ A$
              40 PRINT A$;" ";
              50 NEXT
              RUN
              DAS WETTER IST HEUTE SCHOEN!
              READY.
[5-13]

DEF FN-Anweisung

Format:       DEF FN Name[(Argumentliste)]=Funktionsdefinition

Zweck:        Definiert und  benennt  eine  vom Anwender programmierte
              BASIC-Funktion.

Bemerkungen:  Name muß ein  erlaubter Variablenname sein. Dieser Name,
              dem FN vorangestellt wird,   wird als Name  der Funktion
              betrachtet.

              Argumentliste ist das  Argument der Funktion, das in der
              Funktionsdefinition durch eine oder mehrere  Gleitkomma-
              variable  bezeichnet  wird.   Letztere werden dann  beim
              Aufruf  der   Funktion  durch  die   aktuellen Parameter
              ersetzt.

              Funktionsdefinition ist ein beliebiger Ausdruck, der die
              Operation,  die   die  Funktion  ausführen  soll,  bein-
              haltet.   Die Länge des   Ausdrucks ist auf  eine BASIC-
              Anweisungszeile  (80  Zeichen) beschränkt.   In   diesem
              Ausdruck verwendete Variablennamen dienen nur der forma-
              len  Funktionsdefinition und  sind nicht  mit  Programm-
              variablen desselben Namens zu verwechseln.  Ein in einer
              Funktionsdefinition verwendeter Variablenname  kann  als
              Parameter auftreten oder  auch nicht.  Ist er Parameter,
              so  wird sein  Wert  beim Aufruf  der Funktion  ersetzt;
              andernfalls  wird  der   derzeitige  Wert der  Variablen
              verwendet.

              Mit DEF FN  können  keine anwenderspezifischen  Zeichen-
              kettenfunktionen definiert werden.

              Wenn im  Funktionsnamen  ein  Variablentyp  spezifiziert
              wird,   so   wird der  Wert   des Ausdruckes  diesem Typ
              angepaßt,  bevor er der  aufrufenden Anweisung übergeben
              wird. Wenn ein Variablentyp im Funktionsnamen deklariert
              wurde,  der  nicht zu  dem  Typ paßt,  den  der Ausdruck
              liefert, so  wird eine  TYPE MISMATCH-Fehlermeldung aus-
              gegeben.

[5-14]
              Die DEF FN-Anweisung muß  ausgeführt werden, ehe die da-
              durch definierte Funktion das erste Mal aufgerufen wird,
              sonst wird eine  UNDEFINED FUNCTION-Fehlermeldung ausge-
              geben.

              DEF FN kann nicht im Direkt-Modus verwendet werden.

Beispiel:     410 DEF FN AB(X)=X^3/Y^3
              420 T=FN AB(I)

              Zeile 410 definiert die Funktion, die  in Zeile 420 auf-
              gerufen wird.  Dabei wird die Variable X durch den aktu-
              ellen Wert von I ersetzt.  Die Variable Y behält den ihr
              zum Zeitpunkt des Funktionsaufrufes zugeordneten Wert.

[5-15]

DIM-Anweisung

Format:       DIM Liste indizierter Variabler

Zweck:        Definiert  die maximale  Anzahl  von Elementen für Feld-
              variablen und   reserviert den  Speicher für  die  Feld-
              variable.

Bemerkungen:  Wenn ein   Feldvariablenname ohne  eine  vorausgegangene
              DIM-Anweisung  verwendet  wird,   so ist  als  maximaler
              Index 10 erlaubt.  Wird ein größerer Index angegeben, so
              wird eine BAD SUBSCRIPT-Fehlermeldung ausgegeben.

              Der kleinste Feldindex  ist   immer 0.  Indizes   müssen
              ganzzahlig sein.

              Die DIM-Anweisung setzt alle Elemente des spezifizierten
              Feldes anfänglich auf Null bzw. Leerstring.

              Es können Felder  mit bis zu 255 Dimensionen  deklariert
              werden, von denen jedes maximal 32767 Elemente enthalten
              darf.   Auf jeden Fall ist die  Feldgröße durch den ver-
              fügbaren Speicher begrenzt.

Beispiele:    10 DIM A(20)
              20 FOR I=0 TO 20
              30 READ A(I)
              40 NEXT
              50 DATA 1,2,3...

              10 DIM R3(5,5):REM 36 ELEMENTE

              10 DIM D$(2,2,2):REM 27 ELEMENTE

[5-16]

END-Anweisung

Format:       END

Zweck:        Beendet  den   Programmlauf,  schließt alle   geöffneten
              Dateien und setzt den Interpreter in den Direkt-Modus.

Bemerkungen:  END-Anweisungen zur  Programmbeendigung  können an jeder
              Stelle eines Programms stehen.

              Die  END-Anweisung   erzeugt keine Bildschirmmeldung wie
              z.B. BREAK bei der STOP-Anweisung.

              Am  Ende eines  Programms  (letzte  Zeile) ist  die END-
              Anweisung wahlfrei.

Beispiel:     520 IF K>1000 THEN END

[5-17]

EXP-Funktion

Format:       v=EXP(x)

Zweck:        Liefert die x-te  Potenz der Zahl e.  x muß kleiner oder
              gleich    88.02969191 sein,  sonst  wird eine  OVERFLOW-
              Fehlermeldung generiert.

Beispiel:     10 X=5
              20 PRINT EXP(5-1)
              RUN
              54.5981501
              READY.

[5-18]

FOR...NEXT-Anweisung

Format:       FOR num Var=x TO y [STEP z]
              .
              .
              .
              NEXT [num Var][,num Var...]

Zweck:        Erlaubt  die   Mehrfachverarbeitung   einer  Folge   von
              Befehlen,  Anweisungen und/oder Funktionen in einer Pro-
              grammschleife mit   einer  definierten Zahl  von  Durch-
              läufen.

Bemerkungen:  num Var wird als Zähler für die Durchläufe verwendet und
              muß eine  Gleitkommavariable sein. Der  erste numerische
              Ausdruck x  ist  der Anfangswert, der zweite  numerische
              Ausdruck y ist der Endwert des Zählers.

              Alle  Anweisungen und   Programmzeilen nach   der   FOR-
              Anweisung bis  zur  ersten   NEXT-ANweisung werden  aus-
              geführt. Dann wird der Zähler  um den Wert von z erhöht,
              und es wird  geprüft, ob  er  größer als der Endwert   y
              geworden ist.   Wenn er nicht  größer ist, verzweigt der
              Interpreter zurück   zu  der   Anweisung nach  der  FOR-
              Anweisung, und  der   Ablauf wird  wiederholt.   Ist der
              Zähler  größer  als y,  so wird   das Programm  nach der
              NEXT-Anweisung  fortgesetzt.  Dies   versteht man  unter
              einer FOR...NEXT-Schleife.

              Wenn für z ein negativer  Wert angegeben ist, so muß der
              Endwert y kleiner als der Anfangswert  x sein. y wird in
              diesem Fall bei jedem  Durchlauf um den  Wert von z ver-
              mindert, bis der Zähler kleiner als der Endwert y wird.

              Wird STEP z  nicht  angegeben,  so wird  der  Zähler bei
              jedem Durchlauf um 1 erhöht.

              FOR...NEXT-Schleifen  dürfen auch geschachtelt   werden,
              d.h. eine Schleife  darf  auch  innerhalb einer  anderen
              angeordnet sein.   Jeder Schleifenzähler muß dann jedoch
              einen eigenen Namen   erhalten.    Für alle  Zähler   in
[5-19]        geschachtelten  Schleifen reicht  eine   NEXT-Anweisung,
              gefolgt  von   den  einzelnen Zählervariablen   in   der
              richtigen Reihenfolge  und durch Kommas  getrennt,  wenn
              die  einzelnen  NEXT-Anweisungen unmittelbar aufeinander
              folgen würden.

              Die Variablen in  der  NEXT-Anweisung können weggelassen
              werden.  In diesem Fall bezieht sich jede NEXT-Anweisung
              auf die zuletzt interpretierte FOR-Anweisung. Findet der
              Interpreter eine NEXT-Anweisung ohne vorangegangene FOR-
              Anweisung, so   gibt er   eine  NEXT WITHOUT FOR-Fehler-
              meldung aus und bricht das Programm ab.

              Wegen des  begrenzten Stapelspeichers dürfen nur maximal
              9 FOR...NEXT-Schleifen ineinander geschachtelt werden.

              Die  Beispiele  auf den  nächsten  Seiten erläutern  das
              Gesagte näher.

Beispiel 1:   10 REM GESCHACHTELTE SCHLEIFEN
              20 FOR I=1 TO 3 : FOR J=1 TO 3 : PRINT I;J
              30 NEXT J,I
              RUN
              1 1
              1 2
              1 3
              2 1
              2 2
              2 3
              3 1
              3 2
              3 3
              READY.
[5-20]
Beispiel 2:   10 REM VARIABLENAENDERUNG NACH SETZEN DER SCHLEIFE
              20 K=10
              30 FOR I=1 TO K STEP 2
              40 PRINT I;
              50 K=K+10
              60 PRINT K
              70 NEXT
              RUN
              1 20
              3 30
              5 40
              7 50
              9 60
              READY.

Beispiel 3:   10 REM DER ZWEITE WERT IST KLEINER ALS DER ERSTE
              20 J=0
              30 FOR I=1 TO J
              40 PRINT I
              50 NEXT
              RUN
              1
              READY.

              In diesem  Beispiel wird die  Schleife nur einmal durch-
              laufen, weil der Anfangswert größer als der Endwert ist,
              was  jedoch  erst  beim   Erreichen  der  NEXT-Anweisung
              geprüft wird.

Beispiel 4:   10 REM GANZZAHL-VARIABLE ALS ZAEHLER
              20 FOR I%=1 TO 10: PRINT I%:NEXT
              RUN
              ?SYNTAX ERROR IN 20
              READY.

+-----------------------------------------------------+
Achtung:
Ganzzahl-Variablen als Schleifenzähler sind verboten.
+-----------------------------------------------------+

[5-21]

FRE-Funktion

Format:       v=FRE(x)

Zweck:        Liefert die Anzahl  der noch  nicht benutzten  Bytes  im
              BASIC-Programmspeicher.  Für x kann ein beliebiges Argu-
              ment angegeben werden, da es keinerlei Wirkung hat.  Als
              Blindargument muß es jedoch vorhanden sein.

Bemerkungen:  Da  die übergebene Zahl  vom Interpreter  als ganze Zahl
              behandelt wird, deren   Bereich nur zwischen -32768  und
              32767 definiert ist,  kann ? FRE(0) auch  negative Werte
              liefern,  wenn der verfügbare  Speicher  mehr als  32767
              Bytes  beträgt.   In  diesem   Fall berechnet  sich  der
              tatsächlich verfügbare Speicher aus  der Summe von 65536
              und der angezeigten negativen Zahl.

Beispiel:     PRINT FRE(0)
              1433
              READY.
[5-22]

GET- UND GET#-Anweisungen

Format:       GET[#log Dateinr,]Variablenliste

Zweck:        Liest ein Zeichen von  der Tastatur oder aus einer Datei
              und weist dieses Zeichen der nächsten Variablen in Vari-
              ablenliste zu.

 log Dateinr  Ein ganzzahliger Wert zwischen  1 und 255, unter der die
              Datei eröffnet wurde.

Bemerkungen:  GET ohne  die  Angabe einer logischen Dateinummer  liest
              aus dem Tastaturpuffer  den Code der  zuletzt gedrückten
              Taste und  weist  ihn der  nächsten Variablen (numerisch
              oder Zeichenkette) in der angegebenen Variablenliste zu.
              Wurde keine  Taste gedrückt, so liefert  GET den  Wert 0
              bzw. eine Zeichenkette der Länge 0 (Leerstring).

              GET#  liest ein  Zeichen  aus  der unter  der  logischen
              Dateinummer eröffneten Datei.  Wurde eine  Datei mit der
              Geräteadresse 0 eröffnet, so ist GET# identisch mit GET,
              da der Tastatur die Geräteadresse 0 zugeordnet ist.

Beispiel:     10 PRINT"WARTEN AUF GEDRUECKTE TASTE"
              20 GET A$:IFA$=""THEN20
[5-23]

GOSUB- und RETURN-Anweisungen

Format:       GOSUB Zeilennummer
              .
              .
              .
              RETURN

Zweck:        Verzweigt  in ein  Unterprogramm,  das  mit Zeilennummer
              beginnt,  und kehrt  nach  Ausführung des Unterprogramms
              ins Hauptprogramm zurück.

Bemerkungen:  Die RETURN-Anweisung(en) in einem Unterprogramm bewirken
              einen  Rücksprung  zu  der  Anweisung,   die der zuletzt
              interpretierten GOSUB-Anweisung folgt.

              Ein Unterprogramm  kann  mehrere RETURN-Anweisungen ent-
              halten,   wenn   der  Rücksprung    von    verschiedenen
              Bedingungen abhängig sein soll.

              Ein Unterprogramm  kann an beliebiger Stelle im Programm
              stehen,   muß   jedoch    vom   Interpreter  von  Haupt-
              programmteilen     unterschieden   werden  können.    Um
              unbeabsichtigtes Durchlaufen   eines  Unterprogramms  zu
              vermeiden, sollte vor dem Unterprogramm eine STOP-, END-
              oder GOTO-Anweisung stehen, die die Programmsteuerung um
              das  Unterprogramm herumführt.   Wenn die Unterprogramme
              am  Anfang des Programms  stehen, werden diese schneller
              ausgeführt.

              Unterprogramme können  in bis zu 23  Ebenen geschachtelt
              werden.

Beispiel:     10 GOSUB 40
              20 PRINT"AUS DEM UNTERPROGRAMM ZURUECK"
              30 END
              40 PRINT"IM UNTERPROGRAMM"
              50 RETURN
              RUN
              IM UNTERPROGRAMM
              AUS DEM UNTERPROGRAMM ZURUECK
              READY.

GOTO-Anweisung

Format:       GOTO Zeilennummer

Zweck:        Verzweigt unbedingt  aus der normalen Programmabfolge zu
              einer spezifizierten Zeilennummer.

Bemerkungen:  Wenn  Zeilennummer   eine Zeile mit   einer ausführbaren
              Anweisung  kennzeichnet,  werden  diese  und  die darauf
              folgenden Zeilen abgearbeitet.

              Existiert die  spezifizierte  Zeile  nicht, so  wird die
              Fehlermeldung UNDEF'D STATEMENT ERROR angezeigt.

Beispiel:     10 READ R
              20 PRINT"R= ";R,
              30 A=3.14*R^2
              40 PRINT"FLAECHE=";A
              50 GOTO 10
              60 DATA 5,7,12
              RUN
              R=5        FLAECHE=78.5
              R=7        FLAECHE=153.86
              R=12       FLAECHE=452.16
              ?OUT OF DATA ERROR IN 10
              READY.

[5-25]

IF-Anweisung

Format:       IF Ausdruck THEN Anweisungen
              IF Ausdruck GOTO Zeilennummer

Zweck:        Erlaubt die Verzweigung  zu anderen Anweisungen  oder in
              verschiedene Programmteile, abhängig vom logischen Wahr-
              heitsgehalt eines numerischen Ausdrucks.

Bemerkungen:  Wenn das Ergebnis von  Ausdruck logisch "wahr", also von
              Null verschieden  ist, wird  die THEN- oder GOTO-Klausel
              ausgeführt.

              THEN kann entweder von einer Zeilennummer zum Verzweigen
              oder von einer oder mehreren Anweisungen gefolgt werden.

              GOTO wird immer von  einer Zeilennummer gefolgt. Ist das
              logische Ergebnis  von Ausdruck  "falsch", also Null, so
              wird  die  THEN- oder   GOTO-Klausel  ignoriert, und das
              Programm  wird   mit  der folgenden  Befehlszeile  fort-
              gesetzt.

              IF...THEN-Anweisungen können  auch  geschachtelt werden,
              wobei   die   Schachtelungen  nur   durch  die  Befehls-
              zeilenlänge (80 Zeichen) begrenzt werden:

              IF A=B THEN IF B=C THEN PRINT"A=C"

              Wird    eine  im  Direkt-Modus    eingegebene IF...THEN-
              Anweisung  von  einer Zeilennummer gefolgt, so generiert
              der Interpreter eine  UNDEFINED STATEMENT-Fehlermeldung,
              selbst wenn vorher eine  Zeile mit dieser Nummer  einge-
              geben wurde.

              Bei Verwendung von IF zum Testen  eines Wertes, der sich
              aus  einer  Gleitkommaberechnung  ergeben  hat,  ist  zu
              beachten, daß die interne Darstellung des Wertes ungenau
              sein  kann.     Deshalb sollte  ein  Test  immer für den
              Bereich gemacht werden, innerhalb dessen die Genauigkeit
              variiert.   Es   sollte  also  z.B.  beim   Testen einer
[5-26]        Variablen  auf  den  berechneten Wert 1.0 folgendermaßen
              verfahren werden:

              IF ABS(A-1.0)<=1.0E-6THEN...

              Dieser Test liefert  das Ergebnis "wahr",  wenn der Wert
              von A gleich 1.0  mit einem relativen Fehler von weniger
              als 1.06E-6 ist.

Beispiel 1:   100 IF I THEN GET I

              Diese  Anweisung  prüft auf eine  gedrückte Taste, falls
              der Wert von I nicht Null ist.

Beispiel 2:   100 IF (I>10) AND (I<20) THEN DB=1979-1:GOTO300
              110 PRINT "BEREICHSUEBERSCHREITUNG"

              Wenn  I größer als 10  und  kleiner als 20  ist, wird DB
              berechnet,  und das  Programm  wird mit  Zeile 300 fort-
              gesetzt. Sonst wird Zeile 110 ausgeführt.

INPUT-Anweisung

Format:       INPUT ["Text";] Variablenliste

Zweck:        Erlaubt Dateneingabe über die  Tastatur während der Pro-
              grammausführung.  Die   Dateneingabe wird  durch Drücken
              der RETURN-Taste beendet.

Bemerkungen:  Trifft der Interpreter auf eine INPUT-Anweisung, so wird
              der Programmlauf  angehalten,  ein Fragezeichen wird auf
              dem   Bildschirm  ausgegeben, um    zu zeigen,  daß  das
              Programm Dateneingabe erwartet und der Cursor blinkt.

              Wurde  Text spezifiziert, so wird  dieser vor dem Frage-
              zeichen abgebildet.   Die geforderten Daten  können dann
              über die Tastatur eingegeben werden.  Diese Daten werden
              der (den)  Variablen  in der  Variablenliste zugeordnet;
              deshalb muß die Zahl  der Dateneinheiten (getrennt durch
              Kommas) mit  der Zahl der  Veriablen in der  Liste über-
              einstimmen.

              Die Variablen in  der Liste dürfen  Namen für numerische
              und    Zeichenketten-Variablen     (auch  Feldvariablen)
              sein. Der Typ  jeder  eingegebenen Dateneinheit muß  mit
              dem Typ der korrespondierenden Variablen übereinstimmen.

              Eingegebene  Zeichenketten müssen  nicht  in Anführungs-
              striche  (") eingekleidet werden,  es sei denn, sie ent-
              halten Kommas und/oder Doppelpunkte.

              Die Dateneingabe ist auf die Länge einer logischen Bild-
              schirmzeile  (80   Zeichen) begrenzt.  Wegen  des Frage-
              zeichens können  also  höchstens  78  Zeichen eingegeben
              werden.  Wird diese  Zahl überschritten, nimmt INPUT die
              zuletzt eingegebene logische Bildschirmzeile als gesamte
              Eingabe.    Als logische  Bildschirmzeile   werden Bild-
              schirmdaten von bis zu 80 Zeichen, gerechnet vom Zeilen-
              anfang   bis zum  Wagenrücklauf-Code     (RETURN-Taste),
              betrachtet.

[5-28]
              Wird  bei  INPUT der  falsche  Datentyp eingegeben, also
              z.B.   Zeichenketten  anstatt numerischer,   so wird die
              Meldung ?REDO FROM START ausgegeben, und es wird auf die
              richtige Eingabe gewartet.

              Im Direkt-Modus ist INPUT nicht  erlaubt. In diesem Fall
              wird die ILLEGAL DIRECT-Fehlermeldung ausgegeben.

              Werden bei INPUT zuviele Dateneinheiten eingegeben, wird
              die EXTRA IGNORED-Meldung   ausgegeben.    Bei zuwenigen
              Dateneinheiten werden die fehlenden  mit der Anzeige  ??
              nachgefordert.

Beispiel 1:   10 REM EINGABE VON ZUVIELEN ZEICHEN
              20 INPUT A$
              30 PRINT:PRINT A$
              RUN
              ?DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
              DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
              ****

              ****

              Es wurde 78 mal  D und 4 mal  * eingegeben. Da INPUT bei
              Überschreitung der Maximallänge  nur die letzte logische
              Bildschirmzeile    berücksichtigt, wird   nur  ****  der
              Stringvariablen A$ zugeordnet.

Beispiel 2:   10 INPUT X
              20 PRINTX"ZUM QUADRAT IST"X^2
              RUN
              ?5
              5 ZUM QUADRAT IST 25
              READY.

Beispiel 3:   10 PI=3.14159265
              20 INPUT"RADIUS EINGEBEN";R
              30 A=PI*R^2
              40 PRINT"KREISFLAECHE IST";A
              50 PRINT
              60 GOTO 20
              RUN
              RADIUS EINGEBEN?7.4
              KREISFLAECHE IST 172.033614

              RADIUS EINGEBEN? usw.
[5-29]

INPUT#-Anweisung

Format:       INPUT#log Dateinr,Variablenliste

Zweck:        Liest Daten aus  einer sequentiellen  oder Relativ-Datei
              und weist sie Programmvariablen zu.

Bemerkungen:  log Dateinr ist die   Nummer,  unter der die  Datei  zur
              Eingabe mit der OPEN-Anweisung (s. dort) eröffnet wurde.

              Variablenliste  enthält die  Namen der  Variablen, denen
              die Datenelemente aus  der Datei zugewiesen werden.  Die
              Datentypen müssen den Variablentypen entsprechen.

              INPUT#  gibt  kein ?  als Anzeige aus, wenn als Eingabe-
              gerät die Tastatur gewählt wurde.

              Die Dateneinheiten  in  der Datei  müssen  genauso ange-
              ordnet sein,  als  würden sie  über  die Tastatur einge-
              geben.  Vor-  und  nachlaufende Leerstellen,  Wagenrück-
              lauf- und Zeilenvorschub-Codes werden ignoriert.  Trenn-
              zeichen   zwischen  Variableninhalten können  Komma oder
              Doppelpunkt sein; der Wagenrücklaufcode trennt auf jeden
              Fall einzelne Datenelemente voneinander.

              Bei  Nichtübereinstimmung  von  Daten- und  Variablentyp
              wird  eine  FILE  DATA  ERROR-Fehlermeldung  ausgegeben.
              Beim  Versuch,  Daten am  Dateiende  zu  lesen oder  bei
              Zeitüberschreitung   an  der   Eingabeschnittstelle  (s.
              STATUS-Systemvariable)   liefert  INPUT#   einen  Wagen-
              rücklauf-Code (CHR$(13)).

[5-30]
              INPUT# kann maximal 80 Zeichen lesen.

Beispiel:     10 REM LESEN VON KASSETTE BIS FILEENDE
              20 OPEN3,1,0
              30 INPUT#3,A$
              40 IF STATUS AND 64 THEN FE=1
              50 PRINT A$
              60 IF FE THEN CLOSE3:END
              70 GOTO 30

              Die Abfrage des  Rechner-Statuswortes (hier in Zeile 40)
              wird bei   STATUS  in diesem   Kapitel ausführlich   be-
              schrieben.

[5-31]

INT-Funktion

Format:       v=INT(x)

Zweck:        Liefert die größte ganze Zahl, die kleiner oder gleich x
              ist.

Beispiel:     PRINT INT(99.89),INT(-12.11)
              99         -13
              READY.

[5-32]

LEFT$-Funktion

Format:       v$=LEFT$(x$,n)

Zweck:        Übergibt eine Zeichenkette, die aus den n linken Zeichen
              von  x$  besteht. n  muß  im Bereich  zwischen 0 und 255
              liegen.  Wenn  n größer als  die Länge von  x$ ist, wird
              die gesamte Zeichenkette x$ geliefert.  Wenn n Null ist,
              dann  wird  eine Zeichenkette   der Länge 0 (Leerstring)
              übergeben.

Beispiel:     10 A$="COMMODORE BUEROMASCHINEN"
              20 B$=LEFT$(A$,9)
              30 PRINT B$
              RUN
              COMMODORE
              READY.

[5-33]

LEN-Funktion

Format:       v=LEN(x$)

Zweck:        Übergibt die  Anzahl der Zeichen in der Zeichenkette x$.
              Es werden alle Zeichen, also auch die nicht abdruckbaren
              und Leerzeichen, gezählt.

Beispiel:     10 X$="COMMODORE BRAUNSCHWEIG"+CHR$(13)
              20 PRINTLEN(X$)
              RUN
              23
              READY.

[5-34]

LET-Anweisung

Format:       [LET]Variable=Ausdruck

Zweck:        Weist den Wert eines Ausdrucks einer Variablen zu.

Bemerkungen:  Das Wort LET ist  wahlfrei, d.h. bei der Zuweisung eines
              Wertes zu einer Variablen genügt das Gleichheitszeichen.

Beispiel:     110 LET D=12:LET E=12*2
              120 LET F=144/12
              130 LET SUM=D+E+F

              ist gleichbedeutend mit:

              110 D=12:E=12*2
              120 F=144/12
              130 SUM=D+E+F

[5-35]

LIST-Befehl

Format:       LIST [Zeile1][-[Zeile2]]

Zweck:        Listet  einen Teil  oder  ein  ganzes Programm  auf  das
              gegenwärtig  aktivierte  Ausgabegerät (Bildschirm, Druk-
              ker, Kassette, Floppy Disk).

Bemerkungen:  Der BASIC-Interpreter wird nach  der Ausführung von LIST
              immer in den Direkt-Modus gesetzt.

              Mit LIST  ohne  Zeilennummernangabe wird das  ganze Pro-
              gramm beginnend mit der kleinsten Zeilennummer gelistet.
              Das  Listen wird  entweder  durch das  Programmende oder
              durch Drücken der STOP-Taste  beendet.  Wird  nur Zeile1
              angegeben, so wird nur diese eine Zeile gelistet.

Beispiele:    LIST             Listet  das gesamte im Speicher befind-
                               liche Programm.

              LIST 500         Listet Zeile 500.

              LIST 150-        Listet alle Zeilen  von Zeile 150  ein-
                               schließlich bis Programmende.

              LIST -1000       Listet alle Zeilen  vom Anfang des Pro-
                               gramms bis Zeile 1000 einschließlich.

              LIST 150-700
                               Listet alle Zeilen  von  Zeile 150  bis
                               Zeile 700 einschließlich.

[5-36]

LOAD-Befehl

Format:       LOAD"Dateiname"[,Geräteadresse][,Verschieb]

Zweck:        Lädt eine Programmdatei von einem externen Speichergerät
              (Kassette, Floppy Disk) in den Speicher des Rechners.

Bemerkungen:

   Dateiname  ist der  Name,  unter dem  das   Programm mit der  SAVE-
              Anweisung   (s.  dort)  auf  ein externes  Speichergerät
              gespeichert wurde.

     Geräte-  muß ein ganzzahliger Wert zwischen 1  und 15 sein.  Wird
     adresse  Geräteadresse  weggelassen,  so  wird  das  Programm von
              Gerät 1 (Kassettenstation) geladen.

   Verschieb  Ein ganzzahliger Wert, der  angibt,  ob das Programm  an
              den Anfang des BASIC-Programmspeichers  (0) oder an  die
              Adresse,  mit der es auch  auf Kassette oder Floppy-Disk
              gespeichert wurde (1), geladen wird.  Voreingestellt ist
              hier 0.  Der Wert  dieses Parameters  muß immer 1  sein,
              wenn  Maschinenspracheprogramme   geladen werden sollen.
              Durch LOAD  werden  alle eröffneten Dateien geschlossen,
              sowie   alle  gesetzten  Variablen  und  das  ggfs.   im
              Speicher befindliche  Programm gelöscht, ehe  das spezi-
              fizierte Programm geladen wird.

[5-37]

              Wenn  LOAD  innerhalb  eines Programms  ausgeführt wird,
              wird  das  dadurch  geladene BASIC-Programm  sofort  ge-
              startet,  wobei alle  eröffneten  Dateien offen bleiben.
              Dadurch  können mehrere  Programme oder Programmsegmente
              miteinander  verkettet werden.  Gesetzte Variablen blei-
              ben durch die Verkettung erhalten.

              Das nachgeladene Programm darf jedoch höchstens genau so
              groß sein, wie das aufrufende.

Beispiele:    Laden eines Programms von Kassette:

              LOAD"TESTPRG"
              PRESS PLAY ON TAPE

              Laden eines Maschinenspracheprogramms von Diskette:

              LOAD"MULT",8,1
[5-38]

LOG-Funktion

Format:       v=LOG(x)

Zweck:        Liefert den natürlichen Logarithmus von  x. x muß größer
              als  Null sein;  andernfalls wird eine ILLEGAL_QUANTITY-
              Fehlermeldung ausgegeben.

Beispiel:     PRINT LOG(45/7)
              1.86075234
              READY.

[5-39]

MID$-Funktion

Format:       v=MID$(x$,n[,m])

Zweck:        Liefert eine Teilzeichenkette von x$  mit m Zeichen, be-
              ginnend beim  n-ten Zeichen von x$.    n und m müssen im
              Bereich zwischen 0 und  255 liegen.  Wird m weggelassen,
              oder sind rechts vom n-ten Zeichen weniger als m Zeichen
              in  x$ vorhanden, so  werden ab  dem n-ten Zeichen  alle
              rechten Zeichen von x$ geliefert.  Ist  n größer als die
              Länge von x$, so  wird  eine  Zeichenkette der  Länge  0
              (Leerstring) übergeben.

Beispiel:     10 A$="GUTEN"
              20 B$="MORGEN ABEND MITTAG"
              30 PRINT A$;MID$(B$,8,5)
              RUN
              GUTEN ABEND
              READY.
[5-40]

NEW-Befehl

Format:       NEW

Zweck:        Löscht das  gegenwärtig im Speicher befindliche Programm
              sowie alle Variablen.

Bemerkungen:  NEW wird gewöhnlich im  Direkt-Modus eingegeben, ehe ein
              neues  Programm  ediert wird.  Der Interpreter setzt den
              Rechner auf jeden  Fall  nach Ausführen  von NEW in  den
              Direkt-Modus.

[5-41]

ON...GOSUB- und ON...GOTO-Anweisungen

Format:       ON Ausdruck GOTO Zeilennummernliste
              ON Ausdruck GOSUB Zeilennummernliste

Zweck:        Verzweigt zu  einer von mehreren  spezifizierten Zeilen-
              nummern in  Abhängigkeit des Wertes,  der von 'Ausdruck'
              geliefert wird.

Bemerkungen:  Der  Wert von  'Ausdruck' bestimmt,  zu  welcher Zeilen-
              nummer aus  der Liste  das Programm verzweigt.  Wenn der
              Wert z.B.  3  ist, so stellt die 3.  Zeilennummer in der
              Liste das Sprungziel dar.

              Vor der Verzweigung wird der Wert auf jeden Fall in eine
              ganze Zahl umgewandelt, d.h., ggfs.  vorhandene Dezimal-
              stellen werden abgeschnitten.

              Bei  der  ON...GOSUB-Anweisung  muß  jede  spezifizierte
              Zeilennummer   die  Anfangszeile   eines  Unterprogramms
              kennzeichnen.

              Ist der Wert des Ausdrucks negativ, so wird eine ILLEGAL
              QUANTITY-Fehlermeldung  ausgegeben.   Ist  er Null  oder
              größer  als  die Anzahl  der  in  der Liste  angegebenen
              Zeilennummern, so  wird das  Programm mit der  auf diese
              Anweisung folgenden Zeile fortgesetzt.

Beispiel:     100 ON L-1 GOTO 150,300,320,220

              Für  L=2 wird  nach Zeile  150 verzweigt,  für  L=3 nach
              Zeile 300, usw.

[5-42]

OPEN-Anweisung

Format:       OPEN log Dateinr[,Geräteadresse
                   [,Sekundäradr[,"Dateiname"]]]

Zweck:        

              Eröffnet  eine Ein/Ausgabe-Datei  bzw.   einen Ein-/Aus-
              gabekanal für ein Gerät.

Bemerkungen:  'log Dateinr' muß zwischen 1 und 255 liegen.

              Falls  keine  'Geräteadresse'  angegeben  wird,  wird  1
              angenommen (Kassettenstation).

              Für  'Dateiname'  kann  eine  bis zu  16  Zeichen  lange
              Zeichenkette angegeben werden.

              Im  Falle der  Ein-/Ausgabe über  die  IEEE 488-Schnitt-
              stelle (seriell  oder parallel) werden  mit jeder GET#-,
              INPUT#- oder PRINT#-Anweisung die Geräteadresse und eine
              ggfs.   spezifierte  Sekundäradresse  über die  Schnitt-
              stelle gesendet.

              Bei   Floppy-Disk-Dateien  wird   der  Dateityp   mit  P
              (Programmdatei)  angenommen,   falls  nicht  S   oder  U
              (sequentielle Datendatei),  getrennt durch Komma  an den
              Dateinamen  angefügt wurde.   Wird  nach einem  weiteren
              Komma ein  W angegeben, so wird  die spezifizierte Datei
              zum Schreiben eröffnet, andernfalls zum Lesen.

              Bei  Kassettendateien bezeichnet eine  Sekundäradresse 0
              eine Eingabedatei,  1 eine Ausgabedatei und  2 eine Aus-
              gabedatei bei der mit der CLOSE-Anweisung (s. dort) eine
              Bandendemarke hinter die Datei geschrieben wird.

              Dateien   bzw.     Datenkanäle   können   für   Tastatur
              (Geräteadr.   0),  Kassettengerät  (Geräteadr.  1)  oder
              Bildschirm (Geräteadr. 3) eröffnet werden.

[5-43]

              Geräteadressen  größer als 3  beziehen sich  auf Geräte,
              die  an die  IEEE488-Schnittstelle (seriell  oder paral-
              lel) angeschlossen werden können (z.B.  4 für Drucker, 8
              für Floppy Disk).

Beispiel:     10 REM EROEFFNUNG EINES KASSETTEN-
              15 REM SCHREIBFILES
              20 REM ANSCHLIESSENDER BANDENDEMARKE
              30 OPEN 6,1,2,"DATENFILE"
              40 FOR I=1 TO 10
              50 PRINT#6,CHR$(I)
              60 NEXT
              70 CLOSE 6

              Weitere  Beispiele für  die  Dateieröffnung bei  Floppy-
              Disk-Betrieb sind im Kapitel 6.6 beschrieben.


[5-44]

PEEK-Funktion

Format:       v=PEEK(n)

Zweck:        Liefert den Inhalt der Speicherzelle mit der Adresse 'n'
              als  ganzzahligen  Wert zwischen  0  und  255.  Für  'n'
              müssen  ganzzahlige  Werte zwischen  0  und 65535  ange-
              geben  nehmen.   PEEK   ist  das  Gegenstück  zur  POKE-
              Anweisung (s. dort).

Beispiel:     A=PEEK(53281) AND 15

              Der Wert  der Variablen A ist nach  dieser Anweisung der
              Code  für die gegenwärtig  eingestellte Hintergrundfarbe
              (C64-Modus) des Bildschirms.

[5-45]

POKE-Anweisung

Format:       POKE n,m

Zweck:        Schreibt  eine  8-Bit-Binärinformation  in  eine  spezi-
              fizierte Speicherzelle.

Bemerkungen:  Der Wert  des ganzzahligen Ausdrucks  'n' bezeichnet die
              zu  beschreibende  Speicherzelle;  der  Wert  des  ganz-
              zahligen  Ausdrucks 'm'  bezeichnet  das zu  speichernde
              Datum.

              'n'  muß im  Bereich zwischen  0  und 65535  und 'm'  im
              Bereich zwischen 0 und 255 liegen.

              Das Gegenstück zur POKE-Anweisung  ist die PEEK-Funktion
              (s. dort), deren Argument eine Speicherzelle bezeichnet,
              deren Inhalt ausgelesen werden soll.

              POKE  und  PEEK   sind  effektive  Hilfsmittel  für  die
              Datenspeicherung,  das   Laden  von  Unterprogrammen  in
              Maschinensprache sowie  die Übergabe von  Parametern und
              Ergebnissen  zwischen BASIC-Hauptprogrammen  und Maschi-
              nensprache-Unterprogrammen.

Beispiel 1:   10 REM FARB- UND ZEICHENSTEUERUNG
              20 POKE 1024,1:POKE 55296,6

              Hier  wird  der  Buchstabe  A  in blauer  Farbe  in  der
              HOME-Position des Bildschirms abgebildet (C64-Modus).

Beispiel 2:   10 REM ALLE TASTEN HABEN WIEDERHOLFUNKT.
              20 POKE 650,120
              30 REM NUR DIE CURSORSTEUERTASTEN HABEN
              40 REM WIEDERHOLFUNKTION
              50 POKE 650,0

[5-46]

POS-Funktion

Format:       v=POS(n)

Zweck:        Liefert die gegenwärtige Spaltenposition des Cursors auf
              dem  Bildschirm.  Die   äußerst  linke  Spalte  ist  die
              Position 0.

              'n'  ist  ein Blindargument,  das  aus formalen  Gründen
              jedoch angegeben werden muß.

Beispiel:     IF POS(0)>20 THEN PRINTCHR$(13)

[5-47]

PRINT- und PRINT#-Anweisungen

Format:       PRINT[#log Dateinr,][Liste von Ausdr]

Zweck:        Gibt  Daten an  den  Bildschirm oder  über einen  spezi-
              fizierten Ausgabekanal aus.

Bemerkungen:  Wird  'Liste von  Ausdr' nicht  angegeben, so  wird eine
              Leerzeile  gedruckt.  Andernfalls  werden die  Ausdrücke
              ausgewertet und  deren Werte  an das in  der zugehörigen
              OPEN-Anweisung  unter 'log  Dateinr'  spezifizierte Aus-
              gabegerät oder die Ausgabedatei ausgegeben.

              Es   sind  numerische   und/oder  Zeichenkettenausdrücke
              erlaubt.

              Zeichenkettenkonstanten müssen  in Anführungsstriche (")
              eingekleidet werden.

              Die Position  jedes zu druckenden Datums  (Datum ist die
              Einzahl von Daten) wird durch die Interpunktion, die die
              Daten  in der Liste  voneinander trennt,  bestimmt.  Der
              BASIC-Interpreter teilt die Druckzeile in Druckzonen von
              je  10 Leerstellen  ein.   Ein Komma  in  der Liste  von
              Ausdrücken  bewirkt, daß  der  Wert des  darauffolgenden
              Ausdrucks ab dem  Anfang der nächsten Druckzone gedruckt
              wird, wohingegen ein  Semikolon bewirkt, daß der nächste
              Wert unmittelbar hinter den vorausgehenden Wert gedruckt
              wird.

              Ein Komma  oder Semikolon am  Ende einer Liste  von Aus-
              drücken  bedeutet,  daß die  Werte  der nächsten  PRINT-
              Anweisung in der nächsten Druckzone derselben Zeile oder
              unmittelbar anschließend in der derselben Zeile gedruckt
              werden.   In beiden  Fällen wird  ein Wagenrücklauf-Code
              unterdrückt.

              Ist die  zu druckende Zeile länger als  40 Zeichen (oder
              wahlweise 80  beim C128-Modus),  so wird die  Ausgabe in
              der nächsten physikalischen Zeile fortgesetzt.

[5-48]

              Gedruckten   Zahlenwerten   folgt   immer   eine   Leer-
              stelle.  Positiven  Zahlenwerten  ist  eine  Leerstelle,
              negativen  ein  Minus-Zeichen  vorangestellt. Jede  Zahl
              zwischen  0  und  0.01  wird in  der  wissenschaftlichen
              Exponentialdarstellung   (s.   Kapitel   2.4)  wiederge-
              geben.  Die PRINT-Anweisung  (nicht PRINT#) kann durch ?
              abgekürzt werden.

Beispiel 1:   10 X=5
              20 PRINT X+5,X-5,X*(-5),X^5
              RUN
              10         0         -25         3125
              READY.

              Die  Kommata   zwischen  den  Ausdrücken   in  Zeile  20
              bewirken,  daß  jeder  Wert   an  den  Anfang  einer  10
              Leerstellen breiten Druckzone gedruckt wird.

Beispiel 2:   10 INPUT X
              20 PRINT X"HOCH 2 IST"X^2"UND";
              30 PRINT X"HOCH 3 IST"X^3
              40 PRINT
              50 GOTO 10
              RUN
              ? 9
              9 HOCH 2 IST 81 UND 9 HOCH 3 IST 729

              ? usw.

              Hier bewirkt das Semikolon am Ende von Zeile 20, daß die
              Werte beider  PRINT-Anweisungen in den Zeilen  20 und 30
              in dieselbe Zeile gedruckt werden.  Zeile 40 bewirkt das
              Drucken einer Leerzeile.

Beispiel 3:   10 FOR X=1 TO 5
              20 J=J+5
              30 K=K+10
              40 ?J;K;
              50 NEXT
              RUN
              5 10 10 20 15 30 20 40 25 50
              READY.

[5-49]

              Bei  diesem Beispiel wurde  in Zeile  40 für  die PRINT-
              Anweisung   das  ?-Zeichen   gewählt.    Die  Semikolons
              bewirken  das Drucken  der  einzelnen Werte  unmittelbar
              hintereinander getrennt  durch 2 Leerstellen  (jede Zahl
              wird von einer  Leerstelle gefolgt, positiven Zahlen ist
              eine Leerstelle  vorangestellt).  Wird das  Programm mit
              LIST  ausgelistet, so  wird  das ?-Zeichen  in Zeile  40
              durch das Wort PRINT ersetzt.

[5-50]

READ-Anweisung

Format:       READ Variablenliste

Zweck:        Liest Daten aus einer DATA-Anweisung (s. dort) und weist
              sie Variablen zu.

Bemerkungen:  Eine  READ-Anweisung kann  nur in  Verbindung  mit einer
              DATA-Anweisung benutzt werden.

              Jeder Variablen aus der  Liste, die eine numerische oder
              eine  Zeichenketten-Variable sein  kann, wird  immer nur
              ein Wert aus  der DATA-Anweisung zugewiesen.  Daten- und
              Variablentypen müssen  übereinstimmen.  Andernfalls wird
              eine SYNTAX ERROR-Fehlermeldung aus- gegeben.

              Eine   einzelne  READ-Anweisung  kann   sequentiell  auf
              mehrere  DATA-Anweisungen  zugreifen  wie  auch  mehrere
              READ-Anweisungen   auf  eine   DATA-Anweisung  zugreifen
              können.

              Wenn  die  Anzahl der  Variablen  in der  Variablenliste
              größer  ist als die  Anzahl von  Elementen in  der (den)
              DATA-Anweisung(en),   wird  eine  OUT   OF  DATA-Fehler-
              meldung ausgegeben. Sind  weniger Variablen in der Liste
              spezifiziert,   als   Elemente   in  der   (den)   DATA-
              Anweisung(en)  vorhanden sind,  so lesen  folgende READ-
              Anweisungen die  noch nicht gelesenen  Elemente.  Folgen
              in einem  solchen Fall keine  weiteren READ-Anweisungen,
              so  bleiben überzählige  Datenelemente unberücksichtigt.
              Um DATA-Anweisungen  wiederholt von Anfang  an zu lesen,
              kann die RESTORE-Anweisung (s.  dort) verwendet werden.

[5-51]

Beispiel 1:   80 FOR I=1 TO 10
              90 READ A(I)
              100 NEXT
              110 DATA 3.08,5.19,3.12,3.98,4.24
              120 DATA 5.08,5.55,4.00,3.16,3.37
              .
              .
              .

              In  diesem  Programmsegment   werden  die  Elemente  der
              DATA-Anweisungen der  Zeilen 110 und  120 in das  Feld A
              gelesen.

Beispiel 2:   10 PRINT "PLZ","STADT","LAND"
              20 READ PZ,S$,L$
              30 DATA 6000,"FRANKFURT","HESSEN"
              40 PRINT PZ,S$,L$
              RUN
              PLZ        STADT      LAND
              6000       FRANKFURT  HESSEN
              READY.

              Hier  werden numerische und  String-Daten aus  der DATA-
              Anweisung in Zeile 30 gelesen und ausgedruckt.

[5-52]

REM-Anweisung

Format:       REM [Kommentar]

Zweck:        Mit  dieser Anweisung  können erläuternde  Kommentare in
              ein Programm eingefügt werden.

Bemerkungen:  REM-Anweisungen  werden nicht  ausgeführt,  jedoch exakt
              wiedergegeben, wenn das Programm gelistet wird.

              Von  einer  GOTO-  oder  GOSUB-Anweisung kann  zu  einer
              REM-Anweisung verzweigt werden.   Das Programm wird dann
              mit  der   nächsten  auf  die   REM-Anweisung  folgenden
              ausführbaren Anweisung fortgesetzt.

              Der Text  nach REM  sollte keine Zeichen  enthalten, die
              bei gedrückter  SHIFT-Taste eingegeben wurden,  da diese
              beim LISTen  als BASIC-Schlüsselwörter interpretiert und
              ausgedruckt werden.

Beispiel:     10 REM BERECHNUNG DER MITTLEREN
              15 REM GESCHWINDIGKEIT
              20 FOR I=1 TO 20
              30 SUM=SUM+V(I)
              40 NEXT
              50 VM=SUM/(I-1)


[5-53]

RESTORE-Anweisung

Format:       RESTORE

Zweck:        Setzt den  Lesezeiger der READ-Anweisung  auf den Anfang
              der ersten DATA-Anweisung im Programm.

Bemerkungen:  Nach der  Ausführung einer RESTORE-Anweisung  greift die
              nächste READ-Anweisung auf das erste Datenelement in der
              ersten DATA-Anweisung im Programm zu.

Beispiel:     .-------------------------------------------------------.
              |  10 READ A,B,C                                        |
              |  20 PRINT A,B,C                                       |
              |  30 RESTORE                                           |
              |  40 READ D,E,F                                        |
              |  50 PRINT D,E,F                                       |
              |  60 DATA 57,68,79                                     |
              |  RUN                                                  |
              |  57         68         79                             |
              |  57         68         79                             |
              |  READY.                                               |
              `-------------------------------------------------------'

[5-54]

RIGHT$-Funktion

Format:       v$=RIGHT$(x$,n)

Zweck:        Liefert  die rechten  'n' Zeichen  aus  der Zeichenkette
              'x$'.  Wenn  'n' gleich oder  größer der Länge  von 'x$'
              ist,   wird  'x$'  übergeben.    Für  'n'=0   wird  eine
              Zeichenkette der Länge 0 (Leerstring) übergeben. 'n' muß
              einen Wert zwischen 0 und 255 haben.

Beispiel:     .------------------------------------------------------.
              |  10 A$="COMMODORE BUEROMASCHINEN"                    |
              |  20 PRINT RIGHT$(A$,14)                              |
              |  RUN                                                 |
              |  BUEROMASCHINEN                                      |
              |  READY.                                              |
              `------------------------------------------------------'

[5-55]

RND-Funktion

Format:       v=RND(x)

Zweck:        Liefert eine  Zufallszahl zwischen 0 und  1, die, abhän-
              gig vom Argument 'x', unterschiedlich erzeugt wird:

              x>0:    Es wird  immer der  nächste Wert  einer Zufalls-
                      zahlenreihe, die   durch einen numerischen Algo-
                      rithmus im BASIC-Interpreter berechnet wird, ge-
                      liefert.  Die Reihe ist  vom Wert des Argumentes
                      'x' unabhängig   und  wird beim  Einschalten des
                      Rechners  durch  einen   zufälligen  Anfangswert
                      initialisiert.

              x<0:    Jedes    Argument    x  initialisiert  eine neue
                      Zufallszahlenreihe.  Gleiche Argumente führen zu
                      gleichen Zufallszahlenreihen.

              x=0:    Aus  verschiedenen,  voneinander    unabhängigen
                      Zeitgebern wird  durch  einen Algorithmus   eine
                      Zufallszahl erzeugt.


Beispiel:       ,------------------------------------------------------------.
                |10 FOR I=1 TO 5                                             |
                |20 PRINT INT(RND(X)*100);                                   |
                |30 NEXT                                                     |
                |RUN                                                         |
                |24 30 83 45 1                                               |
                |READY.                                                      |
                `------------------------------------------------------------'

[5-56]

RUN-Befehl

Format:       RUN [Zeilennummer]

Zweck:        Startet  das  gegenwärtig  im  Programmspeicher  befind-
              liche BASIC-Programm.

Bemerkungen:  Wird 'Zeilennummer' angegeben,  so wird das Programm mit
              der dadurch bezeichneten  Zeile gestartet. Andern- falls
              beginnt die Ausführung mit der niedrigsten Zeilennummer.

              Vor  dem   Programmstart  wird  durch   RUN  zuerst  CLR
              (s. dort) ausgeführt.

              Ein Programm  wird durch Rücksetzen  des Interpreters in
              den Direkt-Modus beendet, wenn:

              1. keine ausführbaren Zeilen mehr vorhanden sind.

              2. eine END- oder STOP-Anweisung ausgeführt wurde.

              3. ein Fehler während der Ausführung auftritt.


[5-57]

SAVE-Befehl

Format:       SAVE ["Dateiname"[,Geräteadr[,Option]]]

Zweck:        Speichert  eine  BASIC-Programmdatei  auf  einem  spezi-
              fizierten Ausgabegerät.

Bemerkungen:  Wenn 'Geräteadr' nicht  angegeben wird,  so wird  das im
              Programmspeicher befindliche BASIC-Programm auf Kassette
              (Geräteadresse 1) gespeichert.

              Als 'Option' kann bei Speicherung auf Kassette eine Null
              (keine  Bandendemarke nach der  Programmdatei) angegeben
              werden.

              Wird  'Dateiname'  nicht  vergeben (nur  bei  Kassetten-
              speicherung  erlaubt),  so   wird  überhaupt  kein  Name
              gespeichert.    Wird  für   'Dateiname'   eine  Zeichen-
              kettenvariable  gesetzt,   so  muß  diese   in  Klammern
              angegeben werden.

Beispiel:     SAVE
              SAVE "TESTPRG"
              SAVE(A$),1,0

              Weitere  Beispiele sowie eine  detaillierte Beschreibung
              der  SAVE-Anweisung bei Floppy-Disk-Betrieb  finden sich
              in Kapitel 6.2.

[5-58]

SGN-Funktion

Format:       v=SGN(x)

Zweck:        Liefert das Vorzeichen des Argumentes 'x' in folgender
              codierter Form:

              x>0      liefert  1

              x=0      liefert  0

              x<0      liefert -1


Beispiel:     ON SGN(A)+2 GOTO 100,200,300

              Das Programm verzweigt nach Zeile 100, wenn der Wert von
              A negativ ist, nach Zeile 200, wenn er Null ist und nach
              Zeile 300, wenn er positiv ist.

[5-59]

SIN-Funktion

Format:       v=SIN(x)

Zweck:        Liefert den  Sinus von 'x' im  Bogenmaß.  Die Berechnung
              von  SIN(x)   erfolgt  binär  in  Gleitkommadarstellung.
              Zwischen SIN(x) und COS(x) besteht der Zusammenhang

              COS(x)=SIN(x+3.14159265/2)

Beispiel:     PRINT SIN(1.5)
              .997494987
              READY.


[5-60]

SPC-Funktion

Format:       SPC(n)

Zweck:        Liefert 'n' Leerstellen. SPC  kann nur in Verbindung mit
              der PRINT-  oder PRINT#-Anweisung verwendet  werden. 'n'
              muß Werte zwischen 0 und 255 einnehmen.

Beispiel:     PRINT"HIER"SPC(15)"DA"
              HIER             DA
              READY.

[5-61]

SQR-Funktion

Format:       v=SQR(x)

Zweck:        Liefert die  Quadratwurzel von 'x'. 'x'  muß größer oder
              gleich Null sein.

Beispiel:     10 FOR X=10 TO 25 STEP 5
              20 PRINT X, SQR(X)
              30 NEXT
              RUN
              10                  3.16227766
              15                  3.87298335
              20                  4.47213595
              25                  5
              READY.

[5-62]

STATUS-Systemvariable

Format:       v=STATUS
              v=ST

Wirkung:      Liefert ein  Rechnerstatusbyte, dessen Inhalt  auf Grund
              der  letzten Ein/Ausgabe-Operation  gesetzt  wird. Dabei
              gelten  je nach  benutztem Ein-Ausgabegerät  die folgen-
              den Statuswerte:

              ST-Bit ST-  Kassette         ser. IEC-Bus
              Bit    Wert

              0       1                    Zeitablauf beim Schreiben

              1       2                    Zeitablauf beim Lesen

              2       4   kurzer Block

              3       8   langer Block

              4      16   fataler Fehler

              5      32   Prüfsummenfehler

              6      64   Dateiende        Datenende

              7    -128   Bandende         Gerät nicht angeschlossen


Beispiel:       ,------------------------------------------------------------.
                |  10 OPEN 6,1,2,"MASTERFILE"                                |
                |  20 GET#6,A$                                               |
                |  30 IF ST AND 64 THEN 60                                   |
                |  40 ?A$                                                    |
                |  50 GOTO 20                                                |
                |  60 ?A$:CLOSE6                                             |
                `------------------------------------------------------------'

              Die  Datei MASTERFILE  wird bis  zum Dateiende  von Kas-
              sette gelesen und angezeigt.

[5-63]

STOP-Anweisung

Format:       STOP

Zweck:        Bricht ein  laufendes Programm  ab und setzt  den Inter-
              preter in den Direkt-Modus.

Bemerkungen:  STOP-Anweisungen  dürfen an  beliebiger Stelle  in einem
              Programm stehen. Wird ein STOP ausgeführt, so meldet der
              Interpreter dies mit:

              BREAK IN nnnnn

              wobei 'nnnnn' die Zeilennummer ist, bei der das Programm
              abgebrochen wurde.

              Die   STOP-Anweisung  schließt   nicht,  wie   die  END-
              Anweisung  ggfs.  eröffnete  Dateien.  Nach einer  STOP-
              Anweisung  kann  das  Programm  durch Eingabe  von  CONT
              (s. dort) im Direkt-Modus fortgesetzt werden.

Beispiel:     10 INPUT A,B,C
              20 K=(A+3)/2:L=B*3
              30 STOP
              40 M=C*K+100:PRINT M
              RUN
              ? 1,2,3
              BREAK IN 30
              READY.
              CONT
              106
              READY.

[5-64]

STR$-Funktion

Format:       v$=STR$(x)

Zweck:        Liefert die Zeichenkettendarstellung von 'x'.

Beispiel:     10 INPUT"GIB BITTE EINE ZAHL EIN";N
              20 PRINT N,LEN(STR$(N))
              30 GOTO 10
              RUN
              GIB BITTE EINE ZAHL EIN? -124
              -124      4
              GIB BITTE EINE ZAHL EIN? 2
              2         2
              GIB BITTE EINE ZAHL EIN? usw.

              Im  zweiten Fall ist  die Länge  von STR$(2)  deshalb 2,
              weil  in   der  Zeichenkettendarstellung  von  positiven
              Zahlen  der  Zahl  immer eine  Leerstelle  vorangestellt
              wird.

[5-65]

SYS-Anweisung

Format:       SYS Ausdruck[,Parameterliste]

Zweck:        Übergibt die  Programmsteuerung an ein  Unterprogramm in
              Maschinensprache,  das bei einer  spezifizierten Adresse
              beginnt (s.a. USR-Funktion).

Bemerkungen:  Der Wert  von 'Ausdruck' muß eine ganze  Zahl zwischen 0
              und  65535  sein.  Er  bezeichnet  die  Adresse im  Pro-
              grammspeicher  des C128,  bei der  das  Unterprogramm in
              Maschinensprache  beginnt.  Die  Rückkehr in  das BASIC-
              Hauptprogramm erfolgt durch den Assemblerbefehl RTS.

              In  'Parameterliste' können Parameter  angegeben werden,
              die  dem  Maschinensprache-Unterprogramm übergeben  wer-
              den sollen.

              Die   Auswertung  dieser   Parameter   muß  jedoch   vom
              Maschinensprache-Unterprogramm vorgenommen werden!

Beispiel:     SYS 7*2^12,X,Y

              Die   Zeichenfolge  ',X,Y'  muß   vom  Maschinensprache-
              unterprogramm,  das bei  der Adresse  28676  beginnt, so
              ausgewertet  werden,  daß   der  Textzeiger  des  Inter-
              preters nach  Beendigung des Unterprogramms  auf das 'Y'
              zeigt.

[5-66]

TAB-Funktion

Format:       TAB(n)

Zweck:        Tabuliert  über  'n'  Spalten  in  der  aktuellen  Bild-
              schirmzeile.   Steht der Cursor  vor der  Ausführung von
              TAB(n) bereits rechts von  der 'n'-ten Spalte, so werden
              'n' Spalten der Folgezeile übertabuliert.

              TAB  bezieht  sich immer  auf  den  Zeilenanfang in  den
              äußerst linken Bildschirmspalte (Spalte 0).  Die äußerst
              rechte  Position  in  einer  Zeile ist  dann  Spalte  39
              (wahlweise Spalte 79 im C128-Modus).

              'n' muß zwischen Null und 255 liegen.

              TAB kann  nur in Verbindung mit der  PRINT- oder PRINT#-
              Anweisung verwendet werden.

Beispiel:     10 PRINT"WARTE"TAB(15)"BETRAG":PRINT
              20 READ A$,B$
              30 PRINT A$TAB(15)B$
              40 DATA "BUTTER","DM 2.50"
              RUN
              WARE            BETRAG

              BUTTER          DM 2.50
              READY.

[5-67]

TAN-Funktion

Format:       v=TAN(x)

Zweck:        Liefert den Tangens von 'x' im Bogenmaß.  Die Berechnung
              von TAN(x) erfolgt binär im Gleitkommaformat.

Beispiel:     PRINT TAN(5)/2
              -1.6902575
              READY.

[5-68]

TIME-Systemvariable

Format:       v=TIME
              v=TI

Zweck:        Liefert  den momentanen  Stand der  internen System-Uhr,
              die alle 1/60 Sekunde fortgeschrieben wird.  Die System-
              Uhr ist  keine Echtzeit-Uhr.  Sie  wird beim Einschalten
              des Rechners initialisiert.

Beispiel:     PRINT TI
              154788
              READY.

[5-69]

TIME$-Anweisung
TIME$-Systemvariable

Format:       TIME$=x$        als Anweisung
              TI$=x$
              v$=TIME$        als Systemvariable
              v$=TI$

Zweck:        Als  Anweisung wird  die Systemuhr  auf  eine gewünschte
              Zeit in Form einer 6-Byte-Zeichenkette in der Anordnung:

              hhmmss (Stunden Minuten Sekunden)

              gesetzt.  Diese  Uhrzeit  wird  vom  System  zeitgerecht
              fortgeschrieben  und kann  jederzeit  als Systemvariable
              ausgelesen werden.

Beispiel:     10 INPUT"BITTE ZEIT (HHMMSS)
                       EINGEBEN";TI$
              20 FOR I=1 TO 1000:NEXT
              30 PRINT TI$
              RUN
              BITTE ZEIT (HHMMSS) EINGEBEN? 141223
              141234
              READY.

[5-70]

USR-Funktion

Format:       v=USR(x)

Zweck:        Verzweigt   zu   einem   Maschinensprache-Unterprogramm,
              dessen Startadresse vorher in die Zellen mit der Adresse
              85  und  86  der  zero page  (Organisationsspeicher  des
              Interpreters,  s.   Anhang  H) gespeichert  werden  muß.
              Zelle  85 enthält  den niederwertigen  und Zelle  86 den
              höherwertigen Adreßteil.  Das  Argument x wird im ersten
              Gleitkommaakkumulator des Interpreters übergeben, in den
              auch  das Ergebnis  des  Unterprogramms abgelegt  werden
              muß,  damit  das  BASIC- Hauptprogramm  dieses  Ergebnis
              unmittelbar einer Variablen zuweisen kann.

Beispiel:     10 B=T*SIN(Y)
              20 C=USR(B/2)
              30 D=USR(B/3)

[5-71]

VAL-Funktion

Format:       v=VAL(x$)

Zweck:        Liefert den numerischen Wert einer Zeichenkette, die aus
              Ziffern besteht.  Außerdem sind die Zeichen .  + - und E
              an   den   richtigen   Stelle  erlaubt.    Beginnt   die
              Zeichenkette mit einem anderen Zeichen als einer Ziffer,
              einem Punkt, Plus- oder Minuszeichen, so liefert VAL(x$)
              Null.

Beispiel:     10 X$="0.0053"
              20 PRINT VAL(X$)
              RUN
              5.3E-03
              READY.

[5-72]

VERIFY-Befehl

Format:       VERIFY ["Dateiname"[,Geräteadr]]
                     [,Verschieb]

Zweck:        Vergleicht  ein gegenwärtig im  Programmspeicher befind-
              liches  Programm  mit  einem  auf  einem  spezifizierten
              Ausgabegerät gespeicherten Programm byteweise und meldet
              ggfs. Unterschiede.

Bemerkungen:  'Geräteadr' ist mit 1 (Kassettenstation) voreingestellt.

              Wird  'Dateiname' nicht  angegeben  (nur bei  Kassetten-
              files erlaubt), so erfolgt  der Vergleich mit dem ersten
              auf Kassette gefundenen Programm.

   Verschieb  Ein ganzzahliger Wert  von 0 oder 1, der  angibt, ob das
              zu vergleichende Programm  am Anfang des BASIC-Programm-
              Speichers (0)  oder bei einer anderen  Adresse (1) (z.B.
              Maschinenspracheunterprogramm)  beginnt.  Voreingestellt
              ist hier der Wert 0.

Beispiele:    VERIFY "PRGFILE"
              PRESS PLAY ON TAPE
              OK
              FOUND PRGFILE
              VERIFYING
              VERIFY OK oder VERIFYING ERROR
              READY.

              VERIFY "MULT",8,1

              Das Maschinensprache-Programm MULT auf Diskette wird mit
              dem speicherresidenten Programm verglichen, das nicht am
              Anfang des BASIC-Programmspeichers beginnt.

[5-73]

WAIT-Anweisung


Format:       WAIT Adresse,n[,m]

Zweck:        Hält  die  Programmausführung  an, bis  eine  angegebene
              Speicherzelle  des  C128  ein  spezifiziertes  Bitmuster
              angenommen hat.

Bemerkungen:  Zur Prüfung des  spezifizierten Bitmusters wird zwischen
              dem   Inhalt   der   durch  'Adresse'   gekennzeichneten
              Speicherzelle   und  dem   Ganzzahl-Ausdruck   'm'  eine
              Exklusiv-ODER-Verknüpfung   gebildet.   Dieses  Ergebnis
              wird durch  ein logisches UND  mit dem Ganzzahl-Ausdruck
              'n'  verknüpft.  Wenn  das Ergebnis  Null ist,  wird das
              Bitmuster   der   spezifizierten  Speicherzelle   erneut
              getestet.  Erst  wenn das Ergebnis  von Null verschieden
              ist, wird die  nächste BASIC-Anweisung ausgeführt.  Wenn
              'm'   weggelassen  wird,   wird  sein   Wert   mit  Null
              angenommen.

+----------------------------------------------------------------------------+
|  ACHTUNG                                                                   |
|  Die WAIT-Anweisung kann nicht mit der STOP-Taste abgebrochen werden.      |
+----------------------------------------------------------------------------+

Beispiele:    WAIT 1,16,16

              Die Programmausführung wird solange angehalten, bis eine
              Taste der Kassettenstation gedrückt wird.

              WAIT A,2^n        mit 'n'=0,1,....,7

              Die Programmausführung  wird solange angehalten  bis das
              Bit 'n' der durch A spezifizierten Speicherzelle logisch
              1 ist.

[5-74]

5.3 FARBEN UND GRAFIK IM C64-MODUS

Wir haben nun schon den  BASIC-Sprachumfang des C64-Modus kennengelernt.  Eine
der hervorragenden  Eigenschaften  dieses Modus   besteht jedoch  auch in  der
Möglichkeit,  Farbgrafiken zu erstellen.   Ein  einfaches Beispiel ist  das im
Laufe dieses Abschnittes beschriebene  Springballprogramm.  Aber  die Möglich-
keiten des C64-Modus sind unvergleichlich größer.

In diesem  Abschnitt werden wir Ihnen  zeigen,  wie Sie Farbgrafiken erstellen
und z.B. in Spielen einsetzen können.

Wir gehen dabei von den Standardfarben  des Bildschirms (hellblaue Schrift auf
dunkelblauem Hintergrund mit hellblauem Rand) aus und wollen Ihnen zeigen, wie
Sie  die Farben  ändern können und  wie Sie  die vielen  Grafiksymbole im C64-
Modus einsetzen können.

FARBGEBUNG MIT PRINT-BEFEHLEN

Die Einstellung der Farben  geschieht anhand eines  Musters, das sich mit ein-
fachen Mitteln auf dem  Bildschirm ihres Fernsehgeräts oder  Monitors erzeugen
läßt.

Sie benutzen dazu die CTRL-Taste auf der linken  Seite der Tastatur. Die CTRL-
Taste wird  stets zusammen mit einer anderen  Taste so verwendet, daß zunächst
die CTRL-Taste niedergehalten  und dann die  gewünschte andere Taste  gedrückt
wird.

[5-75]

Sie haben eine Skala  von 16 Zeichenfarben zur  Verfügung. Durch Benutzung der
CTRL-Taste und  der  Zifferntaste  können Sie folgende   Farbkombinationen er-
zeugen:

           1                2                3                4
        schwarz           weiß              rot             grün

           5                6                7                8
        violett        dunkelgrün          blau             gelb

Durch Verwendung der Commodore-Taste ganz unten links  auf der Tastatur zusam-
men mit den Zifferntasten erhalten Sie folgende Farben:

           1                2                3                4
        hellbraun         braun           hellrot         dunkelgrau

           5                6                7                8
         grau            hellgrün        hellblau         hellgrau

Geben Sie nun NEW ein und machen folgendes Experiment:

Nach  dem Zeilenanfang 10  PRINT"  drücken Sie zusammen die  CTRL-  und die 1-
Taste. Lassen Sie  dann die CTRL-Taste los und  drücken die S-Taste. Betätigen
Sie nun  die CTRL-Taste zusammen mit der  2-Taste und dann  die P-Taste allein
usw.  Wählen  Sie auf diese Weise eine  Farbe nach der   anderen und geben Sie
zwischen den Buchstaben das Wort Spektrum.

10 PRINT"  S P E K T R U M"
           | | | | | | | |
CTRL       1 2 3 4 5 6 7 8

Wie bei  der Cursorsteuerung werden  auch die Farbsteuerzeichen  als grafische
Zeichen dargestellt.

Bei gleichzeitigem  Drücken von  CTRL-  und  3-Taste erscheint  das  englische
Pfund-Zeichen und von CTRL- und 7-Taste der Pfeil nach links.
                                                                     [5-76]
Die nachfolgende Tabelle gibt eine Zusammenstellung dieser Farbcodes.

         Taste       Farbe            Taste           Farbe

      [CTRL] [1]    SCHWARZ          [C=] [1]        ORANGE
      [CTRL] [2]    WEIß             [C=] [2]        BRAUN
      [CTRL] [3]    ROT              [C=] [3]        HELLROT
      [CTRL] [4]    TüRKIS           [C=] [4]        GRAU 1
      [CTRL] [5]    VIOLETT          [C=] [5]        GRAU 2
      [CTRL] [6]    GRüN             [C=] [6]        HELLGRüN
      [CTRL] [7]    BLAU             [C=] [7]        HELLBLAU
      [CTRL] [8]    GELB             [C=] [8]        GRAU 3

Wie Sie  schon  bemerkt haben, werden  die  Steuerzeichen nur  beim Listen des
Programms  sichtbar, bei der  Programmausführung, d.h. beim Drucken des Wortes
Spektrum tauchen sie nicht  mehr auf.  Der  Text wird  vielmehr (mit  den ent-
sprechenden Farbvariationen) ausgegeben.

Spielen Sie nun einige Möglichkeiten durch,  um mit der Farbsteuerung vertraut
zu werden und  vergessen Sie nicht, daß  Sie noch weitere Farbmöglichkeiten im
Zusammenhang mit der Commodore-Taste haben.

* Anmerkung: Nach Beendigung eines Programms, bei dem Sie die Farbsteuerung
             angewandt haben, bleibt der C128 in dem Modus, den Sie zuletzt
             eingeschaltet haben. Durch Drücken der Tasten RUN/STOP und
             RESTORE kommen Sie in den Normalfarbenmodus zurück.


                                                                     [5-77]
Farb-CHR$-Codes

Einige Farben können  über die CHR$-Funktion  direkt angesprochen  werden. Sie
haben dieselbe Wirkung wie das  Drücken der CTRL-Taste und der  entsprechenden
Ziffern-Taste.

Probieren Sie folgendes Beispiel aus:

10 PRINT CHR$(147):REM CLR
20 PRINT CHR$(30);"CHR$(30)FAERBT MICH"

Die Schrift  sollte nun grün  sein.  In vielen  Fällen ist die  Verwendung der
CHR$-Funktion zur  Farbsteuerung wesentlich  einfacher als die  Verwendung der
Farbtasten.

Das nachfolgende Programm erzeugt Farbbalken auf dem Bildschirm.

,-------------------------------------------------------------------------.
|   10 REM AUTOMATISCHE FARBBALKEN                                        |
|   20 PRINT CHR$(147):REM CHR$(147) = CLR                                |
|   30 PRINTCHR$(18);"   ";:REM REVERSER BALKEN                           |
|   40 CL= INT(16*RDN(1))+1                                               |
|   50 ON CL GOTO 60,70,80,90,100,110,120,130,140,                        |
|            150,160,170,180,190,200,210                                  |
|   60 PRINTCHR$(5);:GOTO 30                                              |
|   70 PRINTCHR$(28);:GOTO 30                                             |
|   80 PRINTCHR$(30);:GOTO 30                                             |
|   90 PRINTCHR$(31);:GOTO 30                                             |
|  100 PRINTCHR$(144);:GOTO 30                                            |
|  110 PRINTCHR$(156);:GOTO 30                                            |
|  120 PRINTCHR$(158);:GOTO 30                                            |
|  130 PRINTCHR$(159);:GOTO 30                                            |
|  140 PRINTCHR$(129);:GOTO 30                                            |
|  150 PRINTCHR$(149);:GOTO 30                                            |
|  160 PRINTCHR$(150);:GOTO 30                                            |
|  170 PRINTCHR$(151);:GOTO 30                                            |
|  180 PRINTCHR$(152);:GOTO 30                                            |
|  190 PRINTCHR$(153);:GOTO 30                                            |
|  200 PRINTCHR$(154);:GOTO 30                                            |
|  210 PRINTCHR$(155);:GOTO 30                                            |
`-------------------------------------------------------------------------'

[5-78]

FARBGEBUNG DURCH PEEK UND POKE

Nun lernen Sie  eine Methode kenn,  wie Sie  sich  im C64-Modus umschauen  und
Informationen an  die  von  Ihnen  ausgewählte Stelle  bringen können,  um den
Computer zu steuern.

Die Inhalte einiger Speicherzellen  haben  eine ganz bestimmte Bedeutung.   So
gibt es  Speicherzellen, in denen im  C64-Modus festgelegt  wird, welche Bild-
schirm- oder Rahmenfarbe ausgewählt ist, welches Zeichen auf dem Bildschirm in
welcher Farbe angezeigt wird, und wo es dort stehen soll.

Wenn man  den Inhalt dieser Speicherplätze ändert,  so kann man damit auch die
o.a. Parameter ändern.

Farben können geändert werden. Objekte  können  auf dem Bildschirm  erscheinen
und sich bewegen.

Schreibt man Werte direkt in den Computer-Speicher, so geschieht das mit Hilfe
des  POKE-Befehls (s.  dort  in Kapitel 5.2).  Man sagt  deshalb auch, daß man
einen Wert in eine Speicherzelle gepoket hat.

Man kann Speicherzellen durch ihre Adresse ansprechen:

z.B.       53280        oder        53281

Wir  haben hier zwei  Speicherplätze  angegeben, deren Inhalte die Bildschirm-
und die Hintergrundfarbe bestimmen.

Geben Sie bitte folgendes ein:

POKE 53281,7

[5-79]

Nach dem Drücken der RETURN-Taste erhalten Sie einen gelben Bildschirm, da der
Wert 7  die Farbe  gelb definiert und  wir  sie in die Speicherzelle,  die die
Bildschirmhintergrundfarbe wählt,  gepoket haben.  Versuchen  Sie dasselbe mit
anderen Zahlenwerten.

Sie  können jede Zahl zwischen 0  und 255 verwenden;  sinnvoll sind jedoch nur
Zahlen zwischen 0 und 15.

Der nachstehenden Tabelle können Sie entnehmen, wie die Zahlenwerte den Farben
zugeordnet sind.

                  0  scharz              8  hellbraun
                  1  weiß                9  braun
                  2  rot                10  rosa
                  3  grün               11  dunkelgrau
                  4  violett            12  grau
                  5  dunkelgrün         13  hellgrün
                  6  blau               14  hellblau
                  7  gelb               15  hellgrau

Diese Farben können bei verschiedenen Farbmonitoren durchaus variieren.

Nun wollen  wir  uns verschiedene Kombinationen  von  Hintergrund- und Rahmen-
farben anschauen.

Dabei hilft uns folgendes Programm:

,-------------------------------------------------------------------------.
|  10 FOR BA=0 TO 15                                                      |
|  20 FOR BO=15 TO 1 STEP-1                                               |
|  30 POKE 53280, BA                                                      |
|  40 POKE 53281, BO                                                      |
|  50 FOR X=1 TO 2000 : NEXT X                                            |
|  60 NEXT BO : NEXT BA                                                   |
`-------------------------------------------------------------------------'

Zwei  Schleifen werden ineinander geschachtelt,  um alle  Kombinationen zu er-
fassen. Die zusätzliche Schleife in Zeile 50 verzögert  den ganzen Vorgang nur
ein bißchen.

Wenn  Sie die Werte, die  für  den jeweiligen Farbwechsel verantwortlich sind,
während des Farbwechselprogramms  auf  dem Bildschirm sichtbar machen  wollen,
fügen Sie folgende Programmzeile hinzu:

25 PRINT CHR$(147);"RAHMEN=";PEEK(53280)AND15,
         "HINTERGRUND=";PEEK(53281)AND15

[5-80]

BILDSCHIRMGRAFIK

Bisher haben Sie den Cursor nur durch PRINT-Befehle gesteuert.

Damit  läßt  sich jeder  Punkt des  Bildschirms  erreichen,  diese Methode ist
jedoch im allgemeinen sehr langsam und verbraucht wertvollen Speicherplatz.

Im  C64-Modus  gibt es   aber  auch Speicherplätze,  die die  Bildschirmfarben
bestimmen.

DER BILDSCHIRMSPEICHER

Der Bildschirm im  C64-Modus besteht aus 25  Zeilen zu je  40 Zeichen.   Daher
können Sie 1000  Zeichen auf ihm unterbringen  und brauchen natürlich genauso-
viele Speicherplätze, die Informationen darüber enthalten, welche Zeichen sich
in  den einzelnen Bildschirmenpositionen  befinden.  Sie können sich den Bild-
schirm als rechtwinkliges  Gitter vorstellen (s.  nächste Seite), wobei  jedes
kleine Rechteck in diesem Gitter einer Speicherzelle entspricht.

Sie können in diese  Speicherzellen Werte zwischen  0 und  255 hineinschreiben
(poken).

                              Spalte
            0         10        20        30       39

1024 -----> OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO   0
1064        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1104        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1144        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1184        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1224        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1264        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1304        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1344        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO      Z
1384        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO      e
1424        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO   10 i
1464        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO      l
1504        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO      e
1544        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1584        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1624        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1664        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1704        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1744        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1784        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1824        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO   20
1864        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1904        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1944        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
1984        OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO   24
                                                   ^
                                                  2023

Der Bildschirmspeicher im  C64-Modus beginnt bei der  Adresse  1024 und reicht
bis zur Adresse 2023.

[5-81]

Die Speicherzelle 1024 entspricht dabei der linken oberen Ecke des Bildschirms
und die Speicherzelle 2023 der unteren rechten Ecke.

Um eine  bestimmte Position auf dem  Bildschirm zu erreichen, können  Sie nach
folgendem Rechenschema vorgehen:

  Bildschirmadresse = 1024 + Spalte + 40 * Zeile

Nehmen  wir nun an,  Sie wollen einen  Ball etwa in  der Mitte des Bildschirms
erscheinen lassen (Spalte  20, Zeile 12).  Die Speicheradresse dafür errechnet
sich wie folgt:

  1024 + 20 + 40 * 12 = 1524

Nun löschen Sie den Bildschirm durch gleichzeitiges Drücken der SHIFT- und der
CLR/HOME-Tasten und geben Sie dann ein:

  POKE 1524,81

Dabei bedeuten die Zahlen folgendes:

  1524 = Adresse der Bildschirmmitte
  81   = Zeichencode (Ball)

DER FARBSPEICHER

Sie haben nun einen Ball in der Mitte des  Bildschirms erzeugt. Dies haben Sie
erreicht, ohne den PRINT-Befehl zu nutzen. Sie haben einen  Wert direkt in den
Bildschirmspeicher geschrieben. Leider können  Sie den Ball noch  nicht sehen,
er hat nämlich dieselbe Farbe wie der Hintergrund.

Es gibt jedoch einen weiteren Speicher im C64-Modus, bei  dem Sie durch Ändern
der Speicherinhalte die  Farben von einzelnen Zeichen  auf dem  Bildschirm be-
stimmen können. Geben Sie folgendes ein.

  POKE 55796,2

Dabei bedeuten die einzelnen Zahlen folgendes:

  55796 = Adresse der Farbzelle für die Bildschirmmitte
  2     = Farbcode (rot)

[5-82]

Der Ball wird daraufhin rot. Da Sie außer  der Information über das Zeichen in
einer bestimmten Bildschirmposition auch  die Farbinformationen  brauchen, ge-
hörten  zu jeder Position auf dem  Bildschirm zwei  Speicherstellen. Der Farb-
speicher  beginnt bei der Adresse 55296  (linke obere Ecke) und hat natürlich,
wie der Bildschirmspeicher, 1000 Speicherzellen.

                              Spalte
            0         10        20        30       39

55296 ----->OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO   0
55336       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55376       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55416       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55456       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55496       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55536       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55576       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55616       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO      Z
55656       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO      e
55696       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO   10 i
55736       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO      l
55776       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO      e
55816       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55856       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55896       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55936       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
55976       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
56016       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
56056       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
56096       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO   20
56136       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
56176       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
56216       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
56256       OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO   24
                                                   ^
                                                  2023

Die Farbcodes liegen zwischen 0 und 15 und und entsprechen denen, die wir oben
benutzt haben, um  Hintergrund und Rahmen  zu ändern (siehe Farbtabelle weiter
oben).

Die Formel zur Berechnung der Farbspeicheradresse entspricht jener zur Berech-
nung der Bildschirmadresse:

  Farbspeicheradresse = 55296 + Spalte + 40 * Zeile

[5-83]

Ein Springballspiel

,-------------------------------------------------------------------------.
|   10 PRINTCHR$(147) : REM CLR/HOME                                      |
|   20 POKE53280,7 : POKE53281,0                                          |
|   30 X=1 : Y=1                                                          |
|   40 DX=1 : DY=1                                                        |
|   50 POKE 1024+X+39*Y,81                                                |
|   60 POKE 55296+X+39*Y,1                                                |
|   70 FOR T=0 TO 10 : NEXT                                               |
|   80 X=X+DX                                                             |
|   90 IF X=0 OR X=39 THEN DX= -DX                                        |
|  100 Y=Y+DY                                                             |
|  110 IF Y=0 OR Y=24 THEN DY= -DY                                        |
|  120 GOTO 50                                                            |
`-------------------------------------------------------------------------'

Nachdem in  Zeile  10 der  Bildschirm  gelöscht wurde,  wird  in Zeile 20  die
Hintergrundfarbe scharz und die Rahmenfarbe gelb gewählt.

Die Variablen X und Y in Zeile 30 stehen für die Zeile und Spalte, in der sich
der Ball augenblicklich befindet.

Die Variablen  DX  und DY der  Zeile 40  geben  die horizontale  und vertikale
Bewegungsrichtung des Balls an. DX = +1 entspricht einer Bewegung nach rechts.
DX = -1 entspricht einer Bewegung nach  links.  Analog dazu entsprechen DX und
DY einer Bewegung nach oben bzw. unten.

In Zeile 50 wird  der Ball in der  durch Zeilen- und  Spaltennummer bestimmten
Position angezeigt.
In Zeile 60 ist eine Verzögerungsschleife eingefügt.
In Zeile 70 wird der Ball durch überschreiben mit einem Leerzeichen gelöscht.
In Zeile 80  wird durch Addition von  DX der Ball   in der richtigen  Richtung
bewegt.
Das Vorzeichen von DX wird umgedreht, wenn in  Zeile 90 festgestellt wird, daß
der Ball den linken oder rechten Rand berührt.
In den Zeilen 100 und 110  geschieht  dasselbe  für   den  oberen  und
                           unteren Rand.

[5-84]

Die Zeile  120 bewirkt einen  Sprung in die  Zeile 50, wo der  Ball in die neu
berechnete Position auf dem Bildschirm ausgegeben wird.

Wenn Sie in Zeile 50 die 81 gegen eine andere Zahl  austauschen, so können Sie
den Ball durch ein beliebiges Zeichen ersetzen.

Durch folgende Ergänzung können wir das  Programm noch ein bißchen intelligen-
ter machen:

 21 FOR L=1 TO 10
 25 POKE 1024+INT(RND(1)*1000),166
 27 NEXT L
115 IF PEEK(1024+X+40*Y)=166 THEN DX=-DX: GOTO 80

Die Zeilen 21-27  besetzen zufällig gewählte Bildschirmpositionen mit  Hinder-
nissen.

In Zeile 115 wird mit  Hilfe der PEEK-Funktion  geprüft, ob der Ball gegen ein
Hindernis stößt.  Ist dies der Fall, wird die Bewegungsrichtung geändert.


5.3.1 SPRITE-GRAFIK IM C64-MODUS
--------------------------------

EINLEITUNG

In den vorhergehenden Kapiteln haben Sie gesehen, wie man mit dem PRINT-Befehl
den  Bildschirm als Tabelle formatieren  kann und wie man  mit Hilfe des POKE-
Befehls an  beliebigen Stellen des   Bildschirm Zeichen ausdrucken kann.   Die
Konstruktion von  bewegten   Bildern verursacht  mit  beiden  Methoden  einige
Schwierigkeiten, da die  Objekte  aus vorgefertigten Symbolen  zusammengesetzt
werden müssen.  Weiterhin bringt das Bewegen  und Kontrollieren dieser Objekte
einen großen Aufwand an  Befehlen mit  sich.   Durch die begrenzte Anzahl  von
Grafiksymbolen sind Sie in der Formgebung der Objekte stark eingeschränkt.

Durch die  Verwendung  von  Sprites entfallen  die  meisten  oben aufgeführten
Probleme. Ein SPRITE stellt ein frei  programmiertes Objekt in hochauflösender
Grafik dar, dem durch BASIC-Befehle  jede beliebige Form gegeben werden  kann.
Durch  einfache Angabe der Position kann   das SPRITE auf  dem Bildschirm ver-
schoben werden. Die nötigen Berechnungen werden im C64-Modus intern erledigt.

[5-85]

Aber Sprites haben noch  mehr Vorteile. Ihre Farbe  kann geändert werden,  der
Zusammenstoß zweier Sprites kann   auf einfache Weise registriert werden.  Ein
Sprite kann sich vor oder hinter anderen vorbeibewegen  und man kann mit einem
Befehl seine Größe ändern.

All   diesen Vorteilen stehen  nur  geringe Schwierigkeiten beim Programmieren
gegenüber. Zugegeben, Sie müssen noch einiges darüber lernen,  wie man im C64-
Modus arbeitet und wie die  Zahlen intern verarbeitet werden. Aber schließlich
ist es doch ganz interessant und auch gar nicht so schwierig.

Wenn  Sie  die im  folgenden  angegebenen  Beispiele sorgfältig durcharbeiten,
werden  Sie bald  mit  selbstentworfenen Sprites einige  Kunststücke anstellen
können.

DER ENTWURF VON SPRITES

Die Sprites werden von einem speziellen Grafikbaustein,  dem VIC (Video Inter-
face Chip), unterstützt.   Die  Arbeit, die   das Entwerfen  der  Sprites, das
Kontrollieren ihrer Bewegungen und  Positionen und die Farbgebung  macht, wird
zum größten Teil von diesem Chip übernommen.

Der  Bereich, in dem  die Sprites generiert  werden, besteht  aus 64 Speicher-
stellen der  Art, wie Sie  sie schon bei  der  Behandlung des  Bildschirm- und
Farbspeichers kennengelernt haben.  Jede dieser  Speicherstellen kann man sich
in 8 kleine Teile, sog.  Bits, unterteilt denken,  die einzeln an- und  ausge-
schaltet werden können und auf diese Wiese die Form der Sprites bestimmen.  In
welchem Zustand (an  oder aus) die einzelnen  Bits  sind, wird durch  die Zahl
bestimmt, die in das betreffende Register geschrieben wird.

Zusätzlich  zu diesen  speziellen Registern werden  wir auch  Speicher im C64-
Modus nutzen, um Informationen  über die Form der  Sprites zu speichern.  In 8
Speicherzellen (direkt  hinter dem Bildschirmspeicher) werden  Daten abgelegt,
die dem Computer   mitteilen, in welchem  Speicherbereich  die  Daten für  die
Sprites gespeichert sind.

Wie sind die Sprites nun aufgebaut?

                                                                     [8-86]
Wie Sie wissen, besteht  der Bildschirm aus 25  Zeilen zu je 40  Zeichen. Jede
der sich  daraus ergebenden 1000  Bildschirmpositionen können  Sie durch POKE-
Befehle mit einem  Zeichen belegen.  Dieses  Zeichen  selbst ist wiederum  aus
einer 8x8-Punktmatrix zusammengesetzt.

Beim Entwerfen eines Sprites können Sie nun jeden  Punkt dieser Matrix einzeln
ansprechen  und erhalten dadurch eine  Auflösung von 320  x  200 (horizontal x
vertikal) Punkten für den gesamten Bildschirm.

Ein Objekt, das  Sie auf diese Weise   zusammensetzen, darf maximal 24  Punkte
breit und 21 Punkte hoch sein.

Als Beispiel haben wir aus diesem 24 x 21-Punktefeld einen Ballon konstruiert,
der unten abgebildet ist.

Am besten entwerfen Sie  das Objekt auf  fein gerastertem Papier  (z.B. Milli-
meterpapier), auf dem Sie  ein 24 Kästchen  breites und 21 Kästchen hohes Feld
markieren. Zeichnen Sie zuerst die Form so  ein, wie Sie Ihnen vorschwebt, und
füllen Sie dann die Felder  aus, die von den  von  Ihnen gezogenen Linien  ge-
schnitten werden.
Auf diese Weise haben  Sie die Form des Sprites  gestgelegt.  Sie müssen diese
aber nun noch in Daten umwandeln, die der Computer verarbeiten kann.

Schreiben Sie zu diesem  Zweck  an den oberen   Rand des 24 x  21-Punktefeldes
dreimal hintereinander die Zahlenreihe 128, 64, 32, 16, 8, 4, 2, 1. Die Zeilen
des Feldes numerieren Sie von 1 - 21 durch.

Legen Sie sich  nun für jede Zeile drei  Wertetabellen an, wie sie nachfolgend
aufgeführt sind. Tabelle 1 entspricht den ersten 8 Positionen einer Zeile, die
Tabellen  2 und 3 entsprechen  den Positionen 9  - 16  bzw.  17 - 24. Über die
ganzen Felder schreiben Sie nun wieder die oben angeführte Zahlenreihe von 128
- 1. Wir  ordnen  nun in unserer Spritezeichnung  jedem  ausgefüllten Feld die
Zahl 1 und jedem leeren Feld die Zahl 0 zu. Dann legen wir für jede Zeile drei
Tabellen an und schreiben die entsprechenden Werte in die einzelnen Felder.

[5-87]

                          GRUPPE |GRUPPE |GRUPPE
                             1   |   2   |   3
                                 |       |
                          1       1       1
                          2631    2631    2631
                          842684218426842184268421
                         +------------------------+
                       1 |.........#######........|
                       2 |.......###########......|
                       3 |......#############.....|
                       4 |......#####...#####.....|
                       5 |.....#####.###..####....|
                       6 |.....#####.###.#####....|
                       7 |.....#####.###..####....|
                       8 |......#####...#####.....|
                   Z   9 |......#############.....|
                   E  10 |......#############.....|
                   I  11 |......#.#########.#.....|
                   L  12 |.......#.#######.#......|
                   E  13 |.......#..#####..#......|
                      14 |........#..###..#.......|
                      15 |........#..###..#.......|
                      16 |.........#..#..#........|
                      17 |.........#..#..#........|
                      18 |..........#####.........|
                      19 |..........#####.........|
                      20 |..........#####.........|
                      21 |...........###..........|
                         +------------------------+
                          ^   ^    ^    ^    ^   ^
                          1   5    10   15   20  24
                                  SPALTE

Nehmen wir als Beispiel die Zeile 1 des oben dargestellten Sprites. Die ersten
8 Felder sind leer, d.h.  unsere Tabelle 1 enthält nur  Nullen. Um daraus eine
Zahl zu errechnen,  die der Computer verarbeiten  kann, müssen wir  den Inhalt
mit dem Wert   multiplizieren, der über  diesem Feld  steht  und die  Produkte
addieren. Da alle Felder 0 enthalten, erhalten  wir als erstes Datum als Summe
eine Null.

Die zweite Tabelle der Reihe ist nachstehend abgebildet


          128   64    32    16     8     4     2     1
        +-----------------------------------------------+
        |  0  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
        +-----------------------------------------------+
           ^     ^     ^     ^     ^     ^     ^     ^
           0 +  64  + 32  + 16  +  8  +  4  +  2  +  1  = 127

Die dritte Tabelle der ersten Reihe enthält wieder  Nullen. Die Summe ist also
auch 0. Die 1. Reihe useres Sprites  wird also durch die  Zahlen 0, 127, 0 be-
schrieben.

Um sie leicht  in einem Programm verwerten   zu können, schreiben  wir sie als
DATA-Zeile.

  DATA 0, 127, 0

[5-88]

Als weiteres Beispiel die Daten der zweiten Reihe unseres Sprites

        +-----------------------------------------------+
        |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  1  |
        +-----------------------------------------------+
                                                     ^
                                                     1  =   1

        +-----------------------------------------------+
        |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
        +-----------------------------------------------+
           ^     ^     ^     ^     ^     ^     ^     ^
          128 + 64  + 32  + 16  +  8  +  4  +  2  +  1  = 255

        +-----------------------------------------------+
        |  1  |  1  |  0  |  0  |  0  |  0  |  0  |  0  |
        +-----------------------------------------------+
           ^     ^
          128 + 64                                      = 192


Für die Reihe zwei erhalten wir als die DATA-Zeile:

  DATA 1,255,192

Um mit der beschriebenen Methode vertraut zu werden, sollten Sie nun die rest-
lichen 19 DATA-Zeilen selbst berechnen.

Nachdem Sie dies getan haben, probieren Sie folgendes Programm:

,-------------------------------------------------------------------------.
|   10 REM BALLONFAHRT                                                    |
|   20 PRINTCHR$(143):V=53248:REM BASISADR. DES VIC                       |
|   30 POKEV+21,4:REM SPRITE 2 AKTIVIEREN                                 |
|   40 POKE2042,13:REM DATEN FUER SPRITE 2                                |
|   50 FOR N=0 TO 62: READQ: POKE832+N,Q:NEXT                             |
|   60 FOR X=0 TO 200                                                     |
|   70 POKEV+4,X.REM NEUE X-KOORDINATE                                    |
|   80 POKEV+5,X:REM NEUE Y-KOORDINATE                                    |
|   90 NEXT X: GOTO 60                                                    |
|  100 DATA 0, 127, 0, 1, 255, 192, 3, 255, 224, 3, 231, 244              |
|  110 DATA 7, 217, 240, 7, 223, 240, 7, 217, 240, 3, 231, 224            |
|  120 DATA 3, 255, 224, 3, 255, 224, 2, 255, 160, 1, 127, 64             |
|  130 DATA 1, 62, 64, 0, 156, 128, 0, 156, 128, 0, 73, 0, 0, 73, 0, 0    |
|  140 DATA 62, 0, 0, 62, 0, 0, 62, 0, 0, 28, 0                           |
`-------------------------------------------------------------------------'

Wenn Sie  alles richtig  eingegeben haben,  fliegt  ein Ballon ruhig über  den
Bildschirm.  Um  das Programm zu verstehen, müssen  Sie wissen, welche Sprite-
Speicherstellen (Register) welche Funktionen kontrollieren.

[5-89]

Sie können das der folgenden Tabelle entnehmen:

Register        Beschreibung


0                X-Koordinate von Sprite 0
1                Y-Koordinate von Sprite 0
2-15             Bedeutung paarweise wie 0 und 1
                 für Sprites 1-7
16               Höchstes Bit-X-Koordinate
21               1 = Sprite aktiviert; 0 = Sprite inaktiviert
23               Sprite wird in Y-Richtung vergrößert
29               Sprite wird in X-Richtung vergrößert
39-46            Farben der Sprites 0-7

Sie müssen  außerdem wissen in welchem  64er Block die  Daten eines bestimmten
Sprites abgespeichert sind.

Diese Daten stehen in den 8 Registern direkt hinter dem Bildschirmspeicher.

        +-------------------------------------------------------+
        | 2040 | 2041 | 2042 | 2043 | 2044 | 2045 | 2046 | 2047 |
        +-------------------------------------------------------+
            ^      ^      ^      ^      ^      ^      ^      ^
SPRITE      0      1      2      3      4      5      6      7

Nun wollen wir Schritt für Schritt durchgehen, wie wir  unsere Sprites auf dem
Bildschirm bringen können.

  * Poken Sie in die Speicherstelle 21 den richtigen Wert (s. nächste Seite),
    damit das von Ihnen gewählte Sprite auf dem Bildschirm erscheint.

  * Lassen Sie den Sprite-Zeiger auf die Speicherstelle zeigen von der die
    Daten des Sprites gelesen werden sollen.

  * Schreiben Sie mit POKE die Daten in diese Speicherstelle.

  * Konstruieren Sie mit einer Schleife die X- und Y-Koordinaten für die
    Bewegung des Sprites.

  * Sie können zusätzlich die Farben des Sprites oder seine Größe (X- oder/und
    Y-Richtung) ändern. Die Parameter für die Größenänderungen stehen in den
    Registern 23 und 29.


                                                                     [5-90]
Einige Punkte des Programms wollen wir einmal näher erklären.

Zeile 20: v = 53248

Die  erste Speicheradresse des VIC wird  unter V abgespeichert. Zu diesem Wert
brauche nur noch die  Nummern des Registers   addiert wreden, um die  absolute
Speicheradresse zu erreichen.

Zeile 30: POKE V+21,4

Dieser Befehl läßt Sprite 2 auf dem Bildschirm erscheinen. Wenn Sie die unten-
stehende Tabelle anschauen können Sie die  Zugehörigkeit der einzelnen Sprites
erkennen:



          128   64    32    16     8     4     2     1  <- zugehörige Werte
           7     6     5     4     3     2     1     0  <- Sprite-Nummern
        +-----------------------------------------------+
     21 |  0  |  0  |  0  |  0  |  0  |  1  |  0  |  0  | = 4
        +-----------------------------------------------+
                                         ^
                                         eine 1 für den gewünschten Sprite

Jedes Sprite ist im Register 21 vertreten. So entspricht der Wert 4 dem Sprite
2. Sprite 7 entspricht dem  Wert 128 und beide zusammen  132 (128+4). Wenn Sie
die Sprites 2 und 7 einschalten wollten, müßten Sie Poke V+21, 132 eingeben.

Zeile 40: POKE 2042, 13

Der Computer  wird angewiesen,  die Daten  für  Sprite 2 (entspricht Speicher-
stelle 2042) aus Speicherblock  13 zu lesen (1  Speicherblock = 64 Bytes, d.h.
13*64 = 832). Die zweite Zahl in der Poke-Anweisung ist die Anfangsadresse des
zulesenden Sprites.

Ein Sprite verbraucht 63 Bytes.  Der Inhalt einer Tabelle, die wir für die Er-
mittlung der Datazeilen zusammengestellt  haben, entspricht einem Byte.  Daher
müssen also 63 Byte gelesen werden, um eine Sprite zu füllen.

Dies geschieht auf folgende Weise.

50 FOR N=62 : READ Q: POKE 832+N,Q:NEXT

                                                                     [5-91]

Durch diese Schleife werden 63  Datenbytes in den  13. Block gelesen, der  bei
der Adresse 832 (13*64) beginnt.

60 FOR X=0 TO 200
70 POKE V+4,X
80 POKE V+5,X

Da  die Register 4 und  5  die x- und y-Koordinaten   des Sprites 2 enthalten,
bewirkt dieser Programmteil (natürlich zusammen mit NEXT), daß sich das Sprite
2 diagonal über den Bildschirm bewegt.

Da der Koordinatenursprung in der linken oberen Bildschirmecke liegt, verläuft
die Bewegung von links oben  nach rechts unten.  Der  Computer liest die Daten
schnell genug, um die Bewegung kontinuierlich erscheinen zu lassen.

Wenn  sich mehrere  Sprites  über dem  Bildschirm  bewegen sollen,  wird jedem
Objekt  ein  eigener Speicherbereich  zugeordnet.    Die Zeile 90 bewirkt  den
Rücksprung nach Zeile 60, wodurch der ganze Vorgang wiederholt wird.

Der Rest des Programms besteht aus DATA-Zeilen, die die Informationen über die
Form des Ballons enthalten.

Fügen Sie nun folgende Zeile zu dem Programm hinzu und starten Sie es erneut:

55 POKE V+23,4:POKE V+29,4:REM SPRITE VERGROESSERN

Der Ballon ist  jetzt in x-  und  y-Richtung doppelt so  groß  wie vorher. Der
Grund dafür ist, daß die Zahl 4 in die Register 23 und 29 geschrieben wurden.

Es ist wichtig zu  berücksichtigen, daß die  linke obere  Ecke des  Sprites an
ihrem Platz bleibt.

Um das Programm noch interessanter zu machen, fügen Sie folgende Zeile hinzu:

30 POKE V+21,12
40 POKE 2042,13:POKE 2043,13
60 FOR X=1 TO 190
75 POKE V+6,X
85 POKE V+7,190-X

                                                                     [5-92]
Ein weiteres Sprite (Nr.  3) ist auf dem Bildschirm  erschienen, da wir in das
Register 21 eine 12 gepoket haben. Die 12 schaltet die Sprites 2 und 3 ein.

Durch die Zeilen 75 und 85 wird  das 3. Sprite  auf dem Bildschirm bewegt. Die
Speicherstellen V+6 und V+7 enthalten die x- und y-Koordinaten des Objekts.

Wenn Sie wollen, daß am Himmel noch ein bißchen mehr los ist, dann bringen Sie
an Ihrem Programm noch die folgenden Ergänzungen an:

30 POKE V+21,28
40 POKE 2042,13:POKE 2043,13:POKE 2044,13
55 POKE V+23,12:POKE V+29,12
78 POKE V+8,X
88 POKE V+9,100

Durch den POKE-Befehl in Zeile 30 wird ein weiteres Sprite erzeugt.

In  Zeile 40 wird festgelegt, daß  alle drei Sprites  ihre Daten dem 13. Block
entnehmen.

In Zeile 55 werden die Sprites 2 und  3 in x- und  y-Richtung auf das Doppelte
vergrößert.

Zeile 78 bewirkt, daß sich Sprite 3 in Richtung der x-Achse bewegt.

Da in Zeile 88 für die y-Koordinate der Wert 100  fest vorgegeben wird, bewegt
sich das 3. Sprite nur horizontal.

FARBGEBUNG DER SPRITES

Aus der Tabelle für Zeichenfarben können Sie die gewünschte Farbkodierung
(0-15) entnehmen.

Wenn Sie z.B.  dem  Sprite Nr.  1 die  Farbe hellgrün geben wollen, müssen Sie
folgenden Befehl eingeben:

  POKE V+40,13

Sie werden vielleicht beim Ausprobieren  des Beispielprogramms gemerkt  haben,
daß die Sprites nie den  rechten Bildrand erreichen. Der  Grund dafür ist, daß
die Bildschirmbreite  320 Punkten entspricht, das  X-Register jedoch nur Werte
zwischen 0 und 255 enthalten kann.  Wie kann man  nun ein Objekt dazu bringen,
sich über den ganzen Bildschirm zu bewegen?

                                                                     [5-93]
Man benutzt zu diesem  Zweck das Register  Nr.  16, das das höchstwertige  Bit
(auch MSB = Most Sigificant Bit) enthält. Das ist folgendermaßen zu verstehen:

Wir das n-te Bit dieses Registers gesetzt, so befindet sich das n-te Sprite in
der Bildschirmposition, die  einem X-Wert  von  mehr als 255 entspricht.   Der
aktuelle  X-Wert ergibt sich  dann, wenn man  zu dem  Wert,  der im X-Register
steht 256 hinzuzählt.

Soll z.B. das Sprite Nr. 2 eine X-Position  zwischen 256 und 320 einnehmen, so
muß  im Register Nr.  16 das  zweite Bit gesetzt  werden.   Sie müssen also in
dieses Register eine 4 poken.

  POKE V+16,4

Nun zählen wir den Inhalt des X-Registers, das  zum zweiten Sprite gehört (das
ist  Register  Nr. 4) von  0  bis 63 hoch.  Auf diese  Weise erreichen Sie die
restlichen X-Werte von 256 bis 319.

Sie  begreifen  das   Konzept am  besten,   wenn  Sie  das  folgende  Programm
analysieren, das eine  leicht abgeänderte  Version unseres bisherigen  Sprite-
Programms darstellt:

,-------------------------------------------------------------------------.
|  10 V=53248 : POKE V+21,4 : POKE 2042, 13                               |
|  20 FOR N=0 TO 62 : READ Q : POKE 832+N,Q : NEXT                        |
|  25 POKE V+5,100                                                        |
|  30 FOR X=0 TO 255                                                      |
|  40 POKE V+4,X                                                          |
|  50 NEXT                                                                |
|  60 POKE V+16,4                                                         |
|  70 FOR X=0 TO 63                                                       |
|  80 POKE V+4,X                                                          |
|  90 NEXT                                                                |
|  95 POKE V+16,0                                                         |
|  98 GOTO 30                                                             |
`-------------------------------------------------------------------------'

Die Zeile 10 enthält die Anfangsadresse des VIC.  Das Sprite 2 wird aktiviert,
und der Block, von dem eingelesen wird, wird bestimmt.

In Zeile 20 wird aus den DATA-Zeilen in den Block 13 eingelesen.

In Zeile 25 wird die Y Koordinate festgelegt.

In Zeile  30 wird eine Schleife  für die X  Koordinaten 0-255 aufgebaut und in
Zeile 40 ausgegeben.

                                                                     [5-94]
In Zeile 60 wird das MSB für Sprite Nr. 2 gesetzt.

In Zeile 70 beginnt die Schleife, die das Sprite zum rechten Bildschirmrand
wandern läßt.

Die Zeile 95  ist ebenfalls wichtig, da hier  das MSB wieder ausschaltet wird,
so daß die Bewegung wieder am linken Bildrand starten kann.

5.4 MUSIK IM C64-MODUS
----------------------

Die Tonerzeugung im C64-Modus hat zwei Hauptanwendungsgebiete:

Das Spielen von Musikstücken und das Erzeugen von Klangeffekten

Wir werden nur kurz darauf eingehen, wie ein Musikprogramm im allgemeinen auf-
gebaut ist und besprechen dann ein  Musikprogramm, mit dem Sie experimentieren
können.

DIE STRUKTUR EINES MUSIKPROGRAMMS

Der Klang eines Tones wird durch vier Eigenschaften bestimmt:

  * Tonhöhe
  * Lautstärke
  * Klangfarbe
  * Anschlag

Die  beiden letzten  Eigenschaften   bewirken, daß Sie überhaupt  verschiedene
Instrumente mit dem Gehör unterscheiden können.  Gerade diese wichtigen Eigen-
schaften werden Sie daher mit Ihrem Programm beeinflussen wollen.

Im C64-Modus wird zu diesem Zweck ein elektronischer  Baustein, der SID (Sound
Interface Device) benutzt. Im SID sind eine Reihe  von Speicherplätzen für die
Parameter enthalten, die das gewünschte Klangbild zusammensetzen.

Sie wissen schon,  daß im C64-Modus  drei Stimmen  gleichzeitig erzeugt werden
können. Sehen wir uns  zunächst die erste dieser  Stimmen an. Die Basisadresse
des SID wollen wir durch die Variable SI abkürzen:

SI = 54272

                                                                     [5-95]

Die  Tonhöhe wird physikalisch durch  die Frequenz bestimmt. Die Frequenz wird
im SID durch  einen  Parameter gespeichert, der   Werte zwischen  0 und  65535
annehmen kann.  Sie haben im vorherigen  Abschnitt gelernt, daß man  so großen
Zahlen nicht  in einer Speicherzelle abspeichern kann.   Wir müssen  daher den
Frequenzparameter in ein höherwertiges und ein niederwertiges Byte zerlegen.

Das  höherwertige  Byte wird  Hi-Byte  genannt und  das niederwertige Lo-Byte.
Diese beiden Bytes belegen die ersten beiden Register im SID.

FL = SI (Frequenz, Lo-Byte)
FH = SI + 1 (Frequenz, Hi-Byte)

Für die Lautstärke sind im SID 16 Stufen vorgesehen, von 0 (ausgeschaltet) bis
15 (volle Lautstärke). Der  entsprechende Parameter wird  im Register 24 abge-
speichert.

L = SI + 24 (Lautstärke)

Nun kommmt die Klanfarbe:

Sie  wird im wesentlichen durch die  Art der Wellen  bestimmt, die das betref-
fende Musikinstrument erzeugt.

Im C64-Modus sind vier Grundformen vorhanden:


  * Dreieck
  * Sägezahn
  * Rechteck
  * Rauschen

In den folgenden Programmierbeispielen  wrden Sie einige Beispiele lernen, wie
man diese Grundformen verändert und durch Filter beeinflussen kann.

Hier reichen uns  zunächst die Grundformen: Jede  von ihnen wird durch ein Bit
im Register 4 kontrolliert:

W = SI + 4 (Wellenform)
                                                                     [5-96] In
diesem  Register schreiben  Sie zur  Auswahl der   o.g. Grundformen einen  der
Parameter 17,33,65 und 129. Wählen Sie  die 65 (die Rechteckwelle), zusätzlich
müssen Sie noch einen Parameter zwischen 0 und 4095  für das sog. Tastverhält-
nis (das Verhältnis zwischen Ein und Aus Ihres Rechtecks) festlegen.

Beide Bytes dieses Parameters kommen in die Register 2 und 3:

TL = SI + 2 (Tastverhältnis Lo-Byte)
TH = SI + 3 (Tastverhältnis Hi-Byte)

Der Anschlag und der Verlauf  des Tones werden in den  Registen 5 und 6 einge-
stellt.   Dadurch wird  die im  Register  24 eingestellte  Lautstärke zunächst
ansteigen ,dann wieder etwas abschwellen.  Die nun erreichte Lautstärke bleibt
erhalten, solange Sie den Ton eingeschaltet lassen; dann klingt der Ton aus:

A = SI + 5 (Anschlag)
H = SI + 6 (Halten)

Jedes dieser Register ist in zwei Teile aufgespalten:

Der Parameter in vier höherwertigen Bits von  A regelt das Anklingen des Tons,
in dem vier niederwertigen Bits das Abschwellen.  Kleine Werte bedeuten, hart;
große Werte langsam, weich.

Dies gilt ebenfalls  für  niederwertigen Bits von  H,  die das Ausklingen  des
Tones  nach  seinem Abschalten  kontrollieren.   Die höheren  vier  Bits von H
bestimmen die Lautstärke, mit der der Ton gehalten wird.

Der  höchste Wert ergibt die   in Register 24  vorab eingestellte  Lautstärke,
kleinere Werte schwächen diese Lautstärke mehr oder weniger ab.

BEISPIELPROGRAMM

Als erstes müssen Sie sich  entscheiden,  welche Stimmen (Tongeneratoren)  Sie
benutzen wollen.

                                                                     [5-97]
Für jede dieser Stimmen müssen Sie  dann die vier oben erwähnten Einstellungen
(Lautstärke,  Wellenform usw.)  festlegen.    Sie können bis  zu drei  Stimmen
gleichzeitig verwenden, unser Beispiel benutzt jedoch nur die Stimme Nr. 1.

,-------------------------------------------------------------------------.
|  10 SI=54272 : FL=SI : FH=SI + 1 : W=SI+4 : A=SI+5 : H=SI+6 : L=SI+24   |
|  20 POKE L, 15                                                          |
|  30 POKE A, 16+9                                                        |
|  40 POKE H, 4*16+4                                                      |
|  50 POKE FH, 29 : POKE FL, 69                                           |
|  60 POKE W, 17                                                          |
|  70 FOR T=1 TO 500 : NEXT                                               |
|  80 POKE W, 0 : POKE A,0 : POKE H,0                                     |
`-------------------------------------------------------------------------'

In Zeile 10 werden die einzelnen Registeradressen definiert.
In Zeile 20 wird die volle Lautstärke eingestellt.
In Zeile 30 wird der Anschlag eingestellt.
In Zeile 40 wird das Halten und Ausklingen kontrolliert.
In Zeile 50 werden das Hi- und Lo-Byte der Frequenz, hier für den
            Kammerton A (andere Werte siehe Anhang F) eingestellt.
In Zeile 60 wird die Wellenform reguliert. Dieser POKE-Befehl muß immer als
            letztes eingestellt werden, da das niedrigste Bit in diesem
            Register den Tongenerator ein- bzw. ausschaltet.
In Zeile 70 wird die Schleife zur Einstellung der Tondauer eingestellt.
In Zeile 80 werden Wellenform- und Hüllkurveneinstellungen ausgeschaltet.

Nach dem Eingeben von RUN können  Sie die Note  hören, die mit diesem Programm
erzeugt wird.

MELODIEN IM C64-MODUS

Sie brauchen kein Musiker zu sein, um im  C64-Modus Melodien zu erzeugen. Hier
ist  ein Programmbeispiel, an dem gezeigt  wird, wie  man  so etwas macht. Wir
benutzen wieder nur eine Stimme von den dreien, die uns zur Verfügung stehen.

                                                                     [5-98]
Löschen Sie mit NEW das vorhergehende Program mund geben Sie folgendes ein:


,-------------------------------------------------------------------------.
|   10 REM TONLEITER                                                      |
|   20 SI = 54272 : FL=SI : FH=SI+1 : W=SI+4 : A=SI+5 : H=SI+6 : L=SI+24  |
|   30 POKE L, 15                                                         |
|   40 POKE A, 9                                                          |
|   50 READ X : READ Y                                                    |
|   60 IF Y= -1 THEN POKE W,0 : END                                       |
|   70 POKE FH, X: POKE FL,Y                                              |
|   80 POKE W,17                                                          |
|   90 FOR T=1 TO 50 : NEXT                                               |
|  100 POKE W,0                                                           |
|  110 FOR T=1 TO 50 : NEXT                                               |
|  120 GOTO 40                                                            |
|  130 DATA 17,103,19,137,21,237,23,59,26,20,29,69,32,219,34,207          |
|  140 DATA -1,-1                                                         |
`-------------------------------------------------------------------------'

Wenn Sie Töne erzeugen wollen, die einem Cembalo  ähneln, müssen Sie die Zeile
80 in folgender Weise abändern:

80 POKE W,33

Durch diesen POKE-Befehl wählen Sie einen Sägezahn als Wellenform. Dadurch er-
halten Sie oberwellenreichere Klänge, als es bei der bisher benutzten Dreieck-
wellenform der Fall war.

Aber die Wahl der Wellenform ist  nur eine der Möglichkeiten, den Klangcharak-
ter zu bestimmen. Durch eine spezielle Wahl  des Anschlagwertes können Sie aus
dem Cembalo ein Banjo machen. Dies geschieht mit dem nachstehenden POKE-Befehl
in Zeile 40.

40 POKE A,3

Sie  können also  wie mit  einem  echten  Synthesizer den Klang  verschiedener
Instrumente nachahmen. Wie  das gemacht  wird,  d.h.  in welcher  Weise Sie zu
diesem  Zweck   die  betreffenden  Registerinhalte  ändern, werden  wir  jetzt
besprechen.

                                                                     [5-99]

WICHTIGE KLANGEINSTELLUNGEN

1. Lautstärke

Die  Wahl  der  Lautstärke gilt für   alle drei  Tongeneratoren. Das  in Frage
kommende Register  hat  die Adresse 54296.  Sie  erhalten die max. Lautstärke,
wenn Sie in dieses Register einen Wert von 15 poken:

POKE L, 15 oder POKE 54296,0

Im allgemeinen stellen Sie die  Lautstärke zu Beginn eines Musikprogramms fest
ein. Sie können jedoch durch programmierte Änderung der Lautstärke interessan-
te Effekte erzielen.

2. Wellenform:

Wie  Sie im oberen Beispiel gesehen  haben, bestimmt die Wellenform sehr stark
den  Klangcharakter eines Tones. Sie  können für jede  Stimme im C64-Modus die
Wellenform getrennt einstellen. Dabei haben Sie die Wahl zwischen:


  * Dreieck
  * Sägezahn
  * Recheck
  * Rauschen

Eine Zusammenstellung der entsprechenden Adressen  und ihrer Inhalte, die  den
verschiedenen  Stimmen und  Wellenformen  entsprechen,  gibt  die nachstehende
Tabelle. Wenn Sie z.B.  für  die erste  Stimme  die Wellenform Dreieck  wählen
wollen, müssen Sie folgenden Befehl anwenden:

POKE W,17 oder POKE 54276, 17

Die erste Zahl (Adresse) steht also für das  Register. Die zweite Zahl (Inhalt
der Adresse oder desRegisters) steht für die jeweilige Wellenform.

                                                                    [5-100]
DIE EINSTELLUNG DER WELLENFORM


             Register                       Inhalt
   +-----------------------------------------------------------------+
   | STIMME | 1 |  2 |  3 | RAUSCHEN | RECHTECK | SÄGEZAHN | DREIECK |
   |--------+---+----+----+----------+----------+----------+---------|
   |        | 4 | 11 | 18 |   129    |    65    |    33    |    17   |
   +-----------------------------------------------------------------+

Wir haben diese Tabelle in Zeile 30 unseres Tonleiterprogramms angewendet. Mit
POKE  SI+4,17 haben wir  das Dreieck als Wellenform  gewählt, die wir dann zur
Änderung des Klangcharakters durch einen Sägezahn ersetzt haben, indem wir die
17 in eine 33 umgeändert haben.

Als nächstes wollen wir sehen, wir wir die Hüllkurve verändern können, die den
Lautstärkeverlauf  innerhalb eines Tones  bestimmt.  Beachten Sie, daß Sie nur
dann einen Ton  erhalten, wenn Sie, wie  oben beschrieben, auch Lautstärke und
Wellenform festlegen.

3. Hüllkurven-Einstellung:

Die Werte für Anschlag und Abschwellen, die wie die Wellenform für jede Stimme
getrennt gewählt werden  können, werden zusammen  durch einen  Zahlenwert dar-
gestellt.

Der Anschlagparameter gibt die Zeit an, die der Ton  bis zur maximalen (vorher
eingestellten) Lautstärke ansteigt.

Der Abschwellparameter ist ein  Maß dafür, wir  schnell die Lautstärke auf den
Haltepegel abfällt.  Wurde der Haltepegel 0  gewählt, so ergibt der Abschwell-
parameter die Abklingzeit bis zur  Lautstärke 0 und  bestimmt dadurch die Ton-
dauer.

Die  den  einzelnen Stimmen  zugeordneten Adressen  und  die den verschiedenen
Anschlageinstellungen entsprechenden  Werte können  der folgenden Tabelle ent-
nommen werden:

ANSCHLAG-EINSTELLUNGEN

             Register                        Inhalt
 +-----------------------------------------------------------------------+
 | STIMME | 1 |  2 |  3 |         ANSCHLAG          |    ABSCHWELLEN     |
 |--------+---+----+----+---------------------------+--------------------|
 |        | 5 | 12 | 19 | 15*16(weich)...0*16(hart) | 15(weich)...0(hart |
 +-----------------------------------------------------------------------+


                                                                    [5-101]
Wenn Sie lediglich eine Anschlagzeit wählen, z.B. durch

POKE 54277,64

so wird die Abschwellzeit automatisch auf 0 gesetzt.

POKE 54277,66

stellt den Anschlag auf einen mittleren Wert (64=4*16) und das Abschwellen auf
einen kleinen Wert (2). Der Wert 66 ergibt sich dann als  Summe von 64 + 2. Am
besten erkennen Sie den Zusammenhang, wenn Sie statt

POKE 54277,66

POKE 54277,4*16+2 schreiben.

Sie sind jetzt  an einem  Punkt  angelangt, wo  es  am  sinnvollsten ist,  das
Besprochene in einem Programm zusammenzufassen:

,-------------------------------------------------------------------------.
|   10 REM EXPERIMENTIERPROGRAMM                                          |
|   20 SI=54227: FL=SI : FH=SI+1 : TL=SI+2 : TH=SI+3 : W=SI+4 :           |
|      A=SI+5:H=SI+6:L=SI+24                                              |
|   30 PRINT "DRUECKE EINE TASTE"                                         |
|   40 GET Z$:IF Z$="" THEN 40                                            |
|   50 POKE L+15                                                          |
|   60 POKE A,1*16+5                                                      |
|   70 POKE H,0*16+0                                                      |
|   80 POKE TH,8:POKE TL,0                                                |
|   90 POKE FH,14:POKE FL,162                                             |
|  100 POKE W,65                                                          |
|  110 FOR T=1 TO 200:NEXT                                                |
|  120 POKE W=0                                                           |
|  130 GOTO 40                                                            |
`-------------------------------------------------------------------------'

Zeile 50 - stellt die Lautstärke ein.
Zeile 60 - bestimmt den Anschlag und das Abschwellen.
Zeile 70 - hier wird das Halten und Ausklingen eingestellt.
Zeile 80 - stellt das Tastverhältnis ein.
Zeile 90 - bestimmt die Frequenz.
Zeile 100 - der Generator und die Wellenform werden eingeschaltet.
Zeile 110 - Tondauer
Zeile 120 - der Generator wird ausgeschaltet.
Zeile 130 - springt nach Zeile 40 und wartet auf einen Tastendruck.

                                                                    [5-102]

Wir benutzen die  Stimme 1 zur Erzeugung eines   Tons mit kurzem  Anschlag und
kurzem Abschwellen nach Erreichen der Maximallautstärke (Zeile 60).

Was dabei herauskommt, klingt etwa wie ein  Ball, der in einer Blechtonne hin-
und herspringt. Um einen anderen Klang erzeugen, ändern wir diese Zeile.

Dazu stoppen wir das Programm und ändern die Zeile 60 wie folgt:

60 POKE A,11*16+14

Der Ton, den  wir mit dieser Einstellung   erhalten, hat etwa den Klang  einer
Oboe oder eines sonstigen Holzblasinstruments.

Experimentieren Sie  nun und  ändern  Wellenform und  Hüllkurve, um ein Gefühl
dafür zu bekommen, wie die verschiedenen Werte dieser Parameter den Toncharak-
ter verändern.

Mit der Halteeinstellung können Sie festlegen, welche  Lautstärke der Ton nach
dem Anschlagen beibehält. Die Dauer des Tones wird dabei mit einer FOR...NEXT-
Schleife geregelt.

Ähnlich wie beim vorigen Register  werden das Halten  und Ausklingen des  Tons
durch einen Zahlenwert festegelegt, der sich durch die Addition aus den Werten
ermitteln läßt, die in der folgenden Tabele aufgeführt sind.

HALTEN UND AUSKLINGEN

             Register                         Inhalt
+------------------------------------------------+------------------------+
| STIMME | 1 |  2 |  3 |         HALTEN          |       AUSKLINGEN       |
|--------+---+----+----+-------------------------+------------------------|
|        | 6 | 13 | 20 |15*16(laut)..0*16(stumm) | 15(langsam)..0(schnell)|
+-------------------------------------------------------------------------+

Ersetzen Sie  die Nullen in Zeile 70  durch irgendwelche Werte bis  maximal 15
und hören Sie, was dabei herauskommt.


4. Die Wahl der Stimmen und der Noten:

Wie Sie bereits erfahren haben, müssen Sie zur Erzeugung eines Tons zwei Werte
eingeben, die wir Hi-Byte und Lo-Byte der Frequenz genannt haben.


                                                                    [5-103]

Da den  Stimmen   unterschiedliche Adressen   zugeordnet  sind (s.    folgende
Tabelle), können  Sie  die drei  Stimmen im  C64-Modus  unabhängig voneinander
programmieren und auf diese Weise z.B. dreistimmige Musikstücke erstellen.

Adressen der  drei Tongeratoren und  POKE-Werte (Hi-Byte und Lo-Byte) der Töne
der 5. Oktave.

             Register           Inhalte für Noten der 5. Oktave
+-------------------------------------------------------------------------+
| Stimme  | 1   2   3 |  C  C#   D  D#   E   F  F#   G  G#   A  A#   H  C |
|---------+-----------+---------------------------------------------------|
| Hi-Byte | 1   8  15 | 35  37  39  41  44  46  49  52  55  58  62  66 70 |
| Lo-Byte | 0   7  14 |  3  24  77 163  29 188 132 117 148 226  98  24  6 |
+-------------------------------------------------------------------------+

Um den Ton C  mit der Stimme 1  zu erzeugen, müssen Sie  folgende POKE-Befehle
geben:

        POKE 55273,35:POKE 54272,3
oder
        POKE SI+1,35:POKE SI,3

Denselben Ton mit der 2. Stimme erhalten Sie durch:

        POKE 54280,35:POKE 54279,3
oder
        POKE SI+8,35:POKE SI+7,3


PROGRAMMIEREN EINES LIEDES IM C64-MODUS

Mit dem folgenden Programmbeispiel  kann  man Lieder komponieren und   wieder-
geben. Der Computer benutzt dazu die 1. Stimme. Beachten sie bitte, daß in der
Programmzezile 110 die  Adressen  der häufig verwendeten  Register numerischen
Variablen zugeordnet werden und dadurch im Programm bequemer angewendet werden
können.

Wenn z.B. die Wellenform gewählt werden soll, so  genügt es, im entsprechenden
POKE-Befehl  den Buchstaben  W statt der  Zahl  54276 einzusetzen.   Weiterhin
sollten Sie sich für die Verwendung in eigenen Programmen  merken, wie mit den
DATA-Zeilen gearbetet wird. Im vorliegenden Programm werden in den DATA-Zeilen
die drei Zahlen, die zur  Beschreibung eines Tons notwendig sind, hintereinan-
der abgespeichert.

                                                                    [5-104]

Es handelt sich hierbei um Hi-Byte und  Lo-Byte der Frequenz und die Tondauer.
Die  Tondauer wird  durch eine Schleife  bestimmt,  die von  1.   bis zu einem
bestimmten Wert läuft.  Dieser  Wert steht in  den  DATA-Zeilen jeweils an  3.
Stelle.

Dabei  entspricht  125 einer achtel  Note, 250  einer  viertel Note, 375 einem
punktierten Viertel, 500 einer halben und 1000 einer ganzen Note.

Je nach Tempoangabe oder musikalischem Geschmakck können diese Werte natürlich
nach oben oder nach unten abgeändert werden.

Schauen wir uns nun mal die Zeile 110 an: Die 17 und  die 103 sind Hi-Byte und
Lo-Byte für die Note "C".  Die Zahl 250 an der  dritten Stelle bewirkt, daß es
eine viertel Note wird.  Auch die zweite Note  ist ein Viertel, diesmal ist es
aber ein "E" usw.

Sie können in den Datazeilen aber auch selbstgewählte Werte eintragen, die Sie
mit Hilfe der Notentabelle im Anhang F ermitteln können. Dabei können Sie Ihre
Melodie so lang wählen,  wie  Speicherplatz im C64-Modus  verfügbar ist.   Sie
müssen nur dafür sorgen, daß die letzte Programmzeile den Ausdruck DATA-1,-1,0
enthält. Die Zeile 130 sorgt dafür, daß das Programm endet, wenn es bei dieser
Zeile angelangt ist.

,-------------------------------------------------------------------------.
|   10 REM BEISPIELLIED                                                   |
|   20 SI=54272 : FL=SI : FH=SI+1 : TL=SI+2 : TH=SI+3 : W=SI+4            |
|      A=SI+5:H=SI+6:L=SI+24                                              |
|   30 POKE L,15:POKE TH,13:POKE TL,15:POKE A,3*16+15: POKE H,9           |
|   40 READ X:READ Y:READ D                                               |
|   50 IF X= -1 THEN END                                                  |
|   60 POKE FH,X:POKE FL,Y                                                |
|   70 POKE W,65                                                          |
|   80 FOR T=1 TO D : NEXT                                                |
|   90 POKE W,0                                                           |
|  100 GOTO 40                                                            |
|  110 DATA 17,103,250,21,237,250,26,20,400,21,237,100,                   |
|      26,20,250,29,69,250                                                |
|  120 DATA 26,20,250,0,0,250,21,237,250,26,20,250,29,69,                 |
|      1000,26,20,250,0,0,250                                             |
|  130 DATA -1,-1,0                                                       |
`-------------------------------------------------------------------------'

                                                                    [5-105]
KLANGEFFEKTE

Im  Unterschied zur  Musik sollen  Klangeffekte Ereignisse, die  auf dem Bild-
schirm stattfinden, untermalen (Explosionen  eines Raumschiffs usw.) oder  sie
sollen  den Benutzer eines  Programms informieren  oder  warnen (z.B.,  daß er
gerade im Begriff ist, eine Diskette zu  löschen). Hier einige Vorschläge, die
zum Experimentieren anregen sollen:

  * Ändern Sie die Lautstärke während der Ton erklingt, so können Sie damit
    z.B. einen Echoeffekt erzielen.

  * Springen Sie schnell zwischen zwei Tönen hin und her, um ein Tremolo zu
    erzielen

  * Probieren Sie verschiedene Wellenformen aus.

  * Durch unterschiedliches Programmieren der drei Stimmen (z.B. den Ton in
    einer Stimme etwas länger anhalten als in der anderen) kann man über-
    raschende Effekte erzielen.

  * Benutzen Sie die Rechteckwelle und ändern Sie die Pulsbreite.

  * Experimentieren Sie mit dem Rauschgenerator zur Erzeugung von Explosions-
    geräuschen, Gewehrfeuer, Schritten usw.

  * Ändern Sie in schneller Folge die Frequenz über mehrere Oktaven.

                                                                    [5-106]

BEISPIELE FÜR KLANGEFFEKTE

Die hier besprochenen Programmbeispiele   können Sie indirekter oder  in abge-
änderter Form in eigene BASIC-Programme einbauen.   Sie sollen Sie zum Experi-
mentieren anregen  und  Ihnen zeigen, welche  Klangmöglichkeiten  im C64-Modus
stecken.

,-------------------------------------------------------------------------.
|  10 REM PUPPE                                                           |
|  20 SI=54272 : FL=SI : FH=SI+1 : TL=SI+2 : TH=SI+3 : W=SI+4             |
|     A=SI+5 : H=SI+6 : L=SI+24                                           |
|  30 POKE L,15 : POKE TH,15 : POKE TL,15 : POKE A,0*16+0 : POKE H,15*16  |
|  40 POKE W,65                                                           |
|  50 FOR X=250 TO 0 STEP -2:POKE FH,40:POKE FL,X:NEXT                    |
|  60 FOR X=150 TO 0 STEP -4:POKE FH,40:POKE FL,X:NEXT                    |
|  70 POKE W,0                                                            |
|                                                                         |
|  10 REM GEWEHRSCHUSS                                                    |
|  20 SI=54272 : FL=SI : FH=SI+1 : TL=SI+2 : TH=SI+3 : W=SI+4:            |
|     A=SI+5 : H=SI+6 : L=SI+24                                           |
|  30 FOR X=15 TO 0 STEP -1                                               |
|  40 POKE L,X:POKE A,15:POKE H,0:POKE FH,40:POKE TL,200 :                |
|     POKE W,129                                                          |
|  50 NEXT                                                                |
|  60 POKE W,0:POKE A,0                                                   |
|                                                                         |
|  10 REM MOTOREN                                                         |
|  20 SI=54272                                                            |
|  30 FOR K=0 TO 24:READ X:POKE SI+K,X:NEXT                               |
|  40 DATA 9,2,0,30,0,240                                                 |
|  50 DATA 12,2,0,4,0,0,192                                               |
|  60 DATA 16,2,0,6,0,0,64                                                |
|  70 DATA 0,30,243,31:REM FILTER                                         |
|  80 POKE SI+4,65:POKE SI+11,65:POKE SI+18,65                            |
`-------------------------------------------------------------------------'

6. Floppy-Disk-Betrieb mit BASIC

6.1 Formatierung von Disketten
6.2 Speicherung von Programmen
6.3 Verwendung von Jokerzeichen in Dateinamen
6.4 Laden von Programmen
6.5 Diskettenverzeichnisse
6.6 Öffnen und Schließen von Dateien
6.7 Schreib-/Lesezeiger in Relativdateien
6.8 Löschen von Diskettendateien
6.9 Weitere Verwaltungsfunktionen

                                                                      [6-1]
6. FLOPPY-DISK-BETRIEB MIT BASIC
================================

Der C128 erlaubt den Anschluß  von einem oder mehreren  Floppy-Disk-Laufwerken
zur Speicherung größerer Datenmengen. Einzelheiten zur Bedienung dieser Geräte
sind den Floppy-Disk-Handbüchern zu entnehmen.  In diesem Abschnitt wird viel-
mehr der Floppy-Disk-Betrieb im C64-  und C128-Modus unter Kontrolle des BASIC
2.0- bzw. BASIC 7.0-Interpreters beschrieben.

Bei der Beschreibung der folgenden Floppy-Disk-Befehle wird davon ausgegangen,
daß nur ein  Gerät mit einem   Laufwerk und der Geräteadresse  8 angeschlossen
ist.  Sind Doppellaufwerke oder Geräte  mit anderen Geräteadressen angeschlos-
sen, so  wird auf die Beschreibung  der  vollständigen Syntax der Floppy-Disk-
Befehle in Kapitel 4.6 verwiesen.

HINWEIS  Die Bezeichnungen 'File' und 'Datei' bedeuten grundsätzlich dasselbe.

6.1 FORMATIERUNG VON DISKETTEN
------------------------------

Disketten müssen vor dem ersten Gebrauch formatiert werden. Bei diesem Vorgang
schreibt das  Betriebssystem der Floppy-Disk  ein bestimmtes  Sektorformat auf
die Diskette, das als  Rahmen für die später  zu speichernden Daten dient. Zu-
sätzlich wird  das Disketteninhaltsverzeichnis, das   zu Beginn natürlich leer
ist, sowie  ein spezielles  Verzeichnis für freie  und belegte  Sektoren (BAM)
angelegt. Natürlich können auch  bereits formatierte Disketten  neu formatiert
werden. Es ist jedoch eines zu beachten:

  *  Bei der Formatierung einer Diskette werden die ggfs.  vorher auf dieser
     Diskette gespeicherten Daten zerstört.

FORMATIERUNG IM C128-MODUS

  *  Die  zu  formatierende  Diskette  wird  in  die  Floppy-Disk  eingelegt
     (Etikett nach oben und  Schreibschutzkerbe links) und das Laufwerk wird
     verriegelt.


                                                                      [6-2]

  *  Folgende Anweisung wird eingegeben:

     HEADER Name,IKennung,DLaufw

     wobei für 'Name' eine bis zu 16 Zeichen lange Zeichenkette eingekleidet
     in  Anführungzeichen  (")  und  für  'Kennung'  eine  2  Zeichen  lange
     Zeichenkette   eingegeben    wird   (siehe   dazu    Beschreibung   des
     HEADER-Befehls in Kapitel 4.6). Für 'Laufw' wird 0 oder 1 eingegeben.

  *  BASIC fordert vor der Ausführung der Formatierung mit der Anfrage

     ARE YOU SURE?

     vom  Anwender eine  Bestätigung.  Hier  muß 'Y'  oder  'YES' eingegeben
     werden.   Bei  jeder  anderen   Antwort  wird  die  Formatierung  nicht
     ausgeführt.

  *  Während der Formatierung verschwindet der Cursor.

  *  Nach  erfolgter Formatierung  meldet sich  BASIC mit  READY.  Jeglicher
     während der Formatierung von  DOS diagnostizierte Fehler wird durch die
     Meldung

     BAD DISK

     angezeigt.  Den  tatsächlich vom  DOS diagnostizierten Fehler  kann man
     sich durch den Befehl PRINT DS$ anzeigen lassen. In diesem Fall muß die
     Formatierung mit einer neuen Diskette wiederholt werden.

FORMATIERUNG IM C64-MODUS

  *  Die  zu  formatierende  Diskette  wird  in  die  Floppy-Disk  eingelegt
     (Etikett nach  oben und Schreibschutzkerbe links)  und die Laufwerkstür
     wird verriegelt.

  *  Folgende Anweisungen werden eingegeben:

     OPEN 15,8,15,"N0:Name,Kennung":CLOSE 15

     wobei  für Name  eine  bis zu  16  Zeichen lange  Zeichenkette und  für
     Kennung eine 2 Zeichen lange Zeichenkette eingegeben wird.

  *  BASIC  meldet  sich sofort  wieder  mit  READY.   Die Formatierung  war
     erfolgreich,  wenn  die  rote  oder  grüne  Aktivitätslampe  (LED)  der
     Floppydisk  erlischt.   Blinkt  sie,   so  hat  das  DOS  einen  Fehler
     diagnostiziert.

                                                                      [6-3]

  *  Für die Fehlerabfrage im  C64-Modus muß folgendes kleine BASIC-Programm
     geschrieben werden:

     10 OPEN 18,8,15:INPUT#15,FC,FM$,FS,FT
     20 PRINT FC;FM$FS;FT:CLOSE 15

6.2 SPEICHERUNG VON PROGRAMMEN
------------------------------

SPEICHERUNG IM C128-MODUS

  Im   C128-Modus  lassen   sich   sowohl  BASIC-   als   auch  in   anderen
  Speicherbereichen abgelegte Maschinensprache-Programme speichern.

  Bei BASIC-Programmen wird folgender Befehl eingegeben:

  DSAVE Name

  Für 'Name' wird eine bis zu 16 Zeichen lange Zeichenkette, eingekleidet in
  Anführungsstrichen ("), angegeben.

  Die  erfolgreiche   Speicherung  wird  angezeigt,  wenn   BASIC  sich  mit
  READY.  meldet  und  die  rote  oder  grüne  Aktivitätslampe  am  Laufwerk
  erlischt. Blinkt die Anzeige, so  hat DOS einen Fehler diagnostiziert, der
  mit PRINT DS$ angezeigt werden kann.

  Unmittelbar nach der Speicherung  kann das gespeicherte Programm byteweise
  mit  dem im  Hauptspeicher  befindlichen Programm  mit  Hilfe des  Befehls
  DVERIFY Name verglichen werden. Eventuelle Fehler werden angezeigt.

  Bei Maschinenspracheprogrammen, die in anderen Speicher- bereichen als dem
  BASIC-Programmspeicher abgelegt sind, wird folgender Befehl eingegeben.

  BSAVE Name ON BBank,PAdr1 TO PAdr2

  Für  'Name'   wird  eine   bis  zu  16   Zeichen  lange   Zeichenkette  in
  Anführungszeichen ("), für 'Bank' die Nummer der Speicherbank, aus der das
  Programm gespeichert werden soll (0, 1  oder 15) und für 'Adr1' und 'Adr2'
  Anfangs-  und   Endadresse  des   zu  speichernden  Programms   als  ganze
  Dezimalzahlen eingegeben.

                                                                      [6-4]
SPEICHERUNG IM C64-MODUS

  Im   C64-Modus   lassen   sich   nur   BASIC-Programme   auf   Floppy-Disk
  speichern. Dazu wird folgender Befehl eingegeben:

  SAVE"0:Name",8

  Für 'Name' wird eine bis zu 16 Zeichen lange Zeichenkette angegeben.

  Die  erfolgreiche   Speicherung  wird  angezeigt,  wenn   BASIC  sich  mit
  READY.  meldet  und  die  rote  oder  grüne  Aktivitätslampe  am  Laufwerk
  erlischt. Blinkt die Anzeige, so  hat das DOS einen Fehler diagnostiziert,
  der, wie in Kapitel 6.1 beschrieben, angezeigt werden kann.

  Unmittelbar nach der Speicherung  kann das gespeicherte Programm byteweise
  mit  dem im  Hauptspeicher  befindlichen Programm  mit  Hilfe des  Befehls
  VERIFY Name,8 verglichen werden. Eventuelle Fehler werden angezeigt.

6.3 VERWENDUNG VON JOKER-ZEICHEN IN DATEINAMEN
----------------------------------------------

Bei einer Reihe von  Floppy-Disk-Befehlen (OPEN, DOPEN, LOAD,  DLOAD, SCRATCH,
VERIFY,  DVERIFY, COPY) kann  der dort  erforderliche Dateiname  auch in abge-
kürzter Form angegeben   werden.  Dazu stehen  zwei sogenannte  Joker-Zeichen,
nämlich

  * und ?

zur Verfügung.

'*' kann nur am Ende  eines Teilnamens stehen und  bedeutet, daß alle weiteren
Zeichen des Namens irrelevant  sind, daß also der  Befehl auf die erste  Datei
bzw. alle weiteren  im Diskettenverzeichnis  wirkt,  deren Name mit dem  ange-
gebenen Teilnamen beginnt:

  DLOAD"ADR*"            Lädt   das  erste   Programm  aus   dem  Disketten-
                         verzeichnis,  dessen  Name   mit  den  Zeichen  ADR
                         beginnt.

  DLOAD"*"               Lädt das erste  Programm aus dem Diskettenverzeich-
                         nis.

                                                                      [6.5]
? steht für ein beliebiges Zeichen an dieser Stelle:

  DLOAD"DATE*"           Lädt   das  erste   Programm  aus   dem  Disketten-
                         verzeichnis,  dessen Name 5  Zeichen lang  ist, und
                         das mit DATE beginnt.

  DLOAD"PRO??.*"         Lädt   das  erste   Programm  aus   dem  Disketten-
                         verzeichnis,  dessen Name mit  PRO beginnt,  dann 2
                         beliebige  Zeichen und  auf der  6.  Position einen
                         Punkt enthält.


6.4 LADEN VON PROGRAMMEN
------------------------

LADEN IM C128-MODUS

  Im  C128-Modus  lassen  sich  sowohl  BASIC-  als  auch  Maschinensprache-
  Programme (auch in andere Speicherbereiche) laden.

  Bei BASIC-Programmen wird folgender Befehl eingegeben:

  DLOAD Name

  Für 'Name' wird eine bis zu 16 Zeichen lange Zeichenkette, eingekleidet in
  Anführungsstrichen ("), angegeben.

  Der  erfolgreiche   Ladevorgang  wird  angezeigt,  wenn   BASIC  sich  mit
  READY.  meldet  und  die  rote  oder  grüne  Aktivitätslampe  am  Laufwerk
  erlischt.  Blinkt die Anzeige, so hat das DOS einen Fehler diagnostiziert,
  der mit PRINT DS$ angezeigt werden kann.

  Bei  Maschinenspracheprogrammen, die  in andere  Speicherbereiche  als den
  BASIC-Programmspeicher  geladen  werden   sollen,  wird  folgender  Befehl
  eingegeben:

  BLOAD Name ON BBank,PAdr

  Für  'Name'   wird  eine   bis  zu  16   Zeichen  lange   Zeichenkette  in
  Anführungszeichen ("), für 'Bank' die  Nummer der Speicherbank, in die das
  Programm geladen  werden soll  (0 oder  1) und für  'Adr' die  Adresse als
  ganze  Dezimalzahl, ab der  geladen werden  soll, angegeben.   Der weitere
  Ablauf ist dann wie bei DLOAD beschrieben.

                                                                      [6-6]
LADEN IM C64-MODUS

  Auch im  C64-Modus lassen sich sowohl BASIC-Programme  als auch Maschinen-
  spracheprogramme laden.

  Bei Basic-Programmen wird folgender Befehl eingegeben:

  LOAD Name,8

  Für Name wird  eine bis zu 16 Zeichen  lange Zeichenkette, eingekleidet in
  Anführungsstrichen ("), angegeben.

  Der  erfolgreiche   Ladevorgang  wird  angezeigt,  wenn   BASIC  sich  mit
  READY.  meldet  und  die  rote  oder  grüne  Aktivitätslampe  am  Laufwerk
  erlischt.  Blinkt die Anzeige, so hat das DOS einen Fehler diagnostiziert,
  der, wie in Kapitel 6.1 beschrieben, angezeigt werden kann.

  Bei Maschinenspracheprogrammen wird folgender Befehl eingegeben:

  LOAD Name,8,1

  Hier muß  beachtet werden, daß das  Programm mit diesem Befehl  nur ab der
  Adresse  geladen  wird, ab  der  es  auch  ursprünglich gespeichert  wurde
  (z.B. mit Hilfe  eines speziellen Maschinensprache-Monitors).  Der weitere
  Ladevorgang läuft dann, wie oben bei LOAD beschrieben, ab.

6.5 DISKETTENVERZEICHNISSE
--------------------------

Ein Diskettenverzeichnis  ist eine Liste,  in der  alle  auf der Diskette  ge-
speicherten Programm- und Datendateien verzeichnet sind. Diese Liste kann sich
der Anwender jederzeit  auf dem Bildschirm  anzeigen lassen  oder auch  in den
Speicher laden. Ebensogut können Auszüge aus dem Verzeichnis gemacht werden.

FORMAT DES DISKETTENVERZEICHNISSES

  Das  DOS  liefert  bei   Abruf  das  Diskettenverzeichnis  in  einem  ganz
  bestimmten Format.  Der erste Eintrag enthält links die Laufwerksnummer (0
  oder  1), dann  den  bei der  Formatierung  angegebenen Diskettennamen  in
  Anführungszeichen,    dann   die    bei   der    Formatierung   angegebene
  Diskettenkennung (2  Zeichen) und schließlich die  Nummer der DOS-Version,
  unter der die Diskette formatiert wurde.

                                                                      [6-7]
  Die  folgenden  Einträge  sind  Dateieinträge.  Sie  enthalten  links  die
  Dateigröße  in  Sektoren  oder  Blöcken  (1  Sektor  enthält  maximal  254
  Datenbytes), dann den Dateinamen  in Anführungszeichen und schließlich den
  Dateityp. Das DOS unterscheidet 4 Dateitypen, nämlich:

    * PRG für Programmdateien;
    * SEQ für sequentielle Datendateien;
    * REL für relative Datendateien;
    * USR für anwenderspezifische Datendateien;

  Steht unmittelbar vor dem Dateityp ein Stern (*), so ist diese Datei nicht
  ordnungsgemäß geschlossen  und es  kann nicht auf  die Daten  dieser Datei
  zugegriffen werden.

+----------------------------------------------------------------------------+
|  ACHTUNG                                                                   |
|  Direktzugriffsdateien, die vom Anwender mit den Blockbefehlen bearbeitet  |
|  werden, werden vom DOS nicht automatisch im Diskettenverzeichnis einge-   |
|  tragen. Das Floppy-Disk-Handbuch enthält detaillierte Beschreibungen über |
|  die Behandlung von Direktzugriffs- und von Relativ-Dateien.               |
+----------------------------------------------------------------------------+

  Der  letzte Eintrag  im  Verzeichnis  enthält die  Anzahl  der noch  nicht
  belegten Sektoren oder Blöcke auf der Diskette.

  Ein typisches Diskettenverzeichnis sieht so aus:

,---------------------------------------------------------------------------.
|  0 "DISKETTE 1      " D1 2A                                                |
|   15  "ADRESSDRUCK"      PRG                                               |
|  122  "ADRESSEN"         SEQ                                               |
|   85  "FIBU"             PRG                                               |
|  290  "STAMMDAT"         REL                                               |
|  152 BLOCKS FREE.                                                          |
`---------------------------------------------------------------------------'

DISKETTENVERZEICHNIS ANZEIGEN IM C128-MODUS

  DIRECTORY              zeigt  das  gesamte  Diskettenverzeichnis  auf  dem
                         Bildschirm an.

  DIRECTORY"AD*"         zeigt  alle Dateieinträge  an, deren  Namen  mit AD
                         beginnen.

                                                                         [6-8]

  DIRECTORY"F*=P"        zeigt  alle Programmdateieinträge  an,  deren Namen
                         mit F beginnen.

  DIRECTORY"*=R"         zeigt alle Relativdateieinträge an.

  Enthält das Verzeichnis mehr Einträge, als auf einen Bildschirm passen, so
  kann die Anzeige mit Hilfe der Commodore-Taste verlangsamt oder mit der NO
  SCROLL-Taste angehalten werden.

DISKETTENVERZEICHNIS ANZEIGEN IM C64-MODUS

  Eim C64-Modus muß das Diskettenverzeichnis vor der Anzeige in den Speicher
  geladen werden. Ein ggfs.  vorher dort gespeichertes Programm wird dadurch
  überschrieben. Nach  dem Laden wird  das Verzeichnis wie ein  Programm mit
  dem Befehl LIST auf dem Bildschirm angezeigt.

  LOAD"$0",8             lädt   das  gesamte  Diskettenverzeichnis   in  den
                         Speicher.

  LOAD"$0:AD*",8         lädt  alle  Dateieinträge  in den  Speicher,  deren
                         Namen mit AD beginnen.

  LOAD"$0:F*=P",8        lädt  alle Programmdateieinträge  in  den Speicher,
                         deren Namen mit F beginnen.

  LOAD"$0:*=R",8         lädt alle Relativdateieinträge in den Speicher.

  Das geladene Verzeichnis wird dann  mit dem Befehl LIST auf dem Bildschirm
  dargestellt. Das Listen kann nicht angehalten, wohl aber durch Drücken der
  CTRL-Taste verlangsamt werden.

AUSDRUCK DES DISKETTENVERZEICHNISSES

  In  beiden  Betriebsmodi   kann  ein  Diskettenverzeichnis  mit  folgender
  Befehlsfolge  auf einem  angeschlossenen Drucker  mit der  Geräteadresse 4
  ausgedruckt werden.

  LOAD"$0",8
  OPEN4,4:CMD4:LIST
  PRINT#4:CLOSE4

                                                                      [6-9]

  Sollen nur Auszüge des Verzeichnisses  ausgedruckt werden, so ist die oben
  beim C64-Modus beschriebene Form des LOAD-Befehls zu verwenden.

6.6 ÖFFNEN UND SCHLIEßEN VON DATEIEN
------------------------------------

  Um Daten  in BASIC mit  der PRINT#-Anweisung (s.  dort in Kapitel  5.2) in
  eine  Datei   auf  Diskette   zu  schreiben  oder   mit  der   GET#-  oder
  INPUT#-Anweisung (s. dort in Kapitel  5.2) aus einer Datei auf Diskette zu
  lesen,  muß die  Datei zunächst  geöffnet und  nach dem  Bearbeiten wieder
  geschlossen werden. Dafür werden  im folgenden Beispiele, getrennt für die
  beiden Betriebsmodi, gegeben.

  DATEI ÖFFNEN IM C128-MODUS

  DOPEN#3,"Adressen"          Öffnet die sequentielle Eingabe-Datei ADRESSEN
                              (entweder   SEQ-  oder   USR-Typ)   unter  der
                              logischen Filenummer 3.

  DOPEN#2,"STAMMDAT,W"        Öffnet die sequentielle Ausgabe-Datei STAMMDAT
                              unter der logischen Filenummer 2.

  DOPEN#7,"BANK",L127         Öffnet   die  Relativ-Datei  BANK   mit  einer
                              Satzlänge  von 127  Bytes unter  der logischen
                              Filenummer 7.

  OPEN4,8,4,"0:PROG,P,R"      Öffnet  die Programm-Datei  PROG  als Eingabe-
                              Datei unter der logischen Filenummer 4.

  OPEN5,8,4,"0:GRAFIK,U,W"    Öffnet   die   Datei   GRAFIK  als   anwender-
                              spezifische,  sequentielle  Ausgabedatei unter
                              der logischen Filenummer 5.

                                                                        [6-10]
  APPEND#3,"NAMEN"            Öffnet  die  existierende, sequentielle  Datei
                              NAME (SEQ-  oder USR-Typ) unter  der logischen
                              Filenummer  3  und  positioniert den  Schreib-
                              zeiger  des  DOS   auf  das  Dateiende,  damit
                              weitere Daten angefügt werden können.

  OPEN3,8,4,"0:ADRESSEN,S,R"  Öffnet die sequentielle Eingabe-Datei ADRESSEN
                              unter der logischen Filenummer 3.

  OPEN2,8,5,"0:STAMMDAT,S,W"  Öffnet die sequentielle Ausgabe-Datei STAMMDAT
                              unter der logischen Filenummer 2.

  OPEN7,8,2,"0:BANK,L,"       Öffnet die Relativ-Datei  BANK mit einer Satz-
            +CHR$(127)        länge von 127  Bytes unter der logischen File-
                              nummer 7.

  OPEN4,8,4,"0:PROG,P,"       Öffnet  die Programm-Datei  PROG  als Eingabe-
                              Datei unter der logischen Filenummer 4.

  OPEN5,8,4,"0:GRAFIK,U,W"    Öffnet   die   Datei   GRAFIK  als   anwender-
                              spezifische,  sequentielle  Ausgabedatei unter
                              der logischen Filenummer 5.

  OPEN3,8,3,"0:NAMEN,A"       Öffnet  die  existierende, sequentielle  Datei
                              NAMEN (SEQ- oder  USR-Typ) unter der logischen
                              Filenummer  3  und  positioniert den  Schreib-
                              zeiger  des  DOS   auf  das  Dateiende,  damit
                              weitere Daten angefügt werden können.

                                                                     [6-11]

  Wird eine göffnete Datei in einem Programm nicht mehr benötigt, so muß sie
  vor  dem  Programmende  oder  einem  Diskettenwechsel  wieder  geschlossen
  werden.   Bei sequentiellen  Ausgabedateien (SEQ-  oder USR-Typ)  ist dies
  unerläßlich, da  sonst auf die gespeicherten Daten  nicht mehr zugegriffen
  werden kann.  Solche Dateien werden  im Verzeichnis durch einen  Stern (*)
  vor dem Dateityp gekenn- zeichnet.

DATEI SCHLIEßEN IM C128-MODUS

  DCLOSE#5                    Schließt die unter  der logischen Filenummer 5
                              geöffnete Datei beliebigen Typs.

  DCLOSE                      Schließt alle geöffneten Diskettendateien.

  CLOSE5                      Schließt die unter  der logischen Filenummer 5
                              geöffnete Datei beliebigen Typs.

  Einen Befehl, mit  dem man im C64-Modus alle  geöffneten Dateien schließen
  kann, gibt es im BASIC 2.0 nicht.

6.7 SCHREIB-/LESEZEIGER IN RELATIVDATEIEN POSITIONIEREN
-------------------------------------------------------

  Ehe auf einen logischen Datensatz in einer Relativdatei zugegriffen werden
  kann (mit PRINT# bzw.  GET#  oder INPUT#), muß der Schreib-/Lesezeiger des
  DOS für diese Datei auf den gewünschten Satz positioniert werden.

RELATIVDATEIZUGRIFF IM C128-MODUS

  RECORD#2,200                Der  Schreib-/Lesezeiger der Datei,  die unter
                              der  logischen  Filenummer  2 eröffnet  wurde,
                              wird auf den 200. Datensatz positioniert.

                                                                     [6-12]

  RECORD#2,200,50             Wie oben. Zusätzlich wird auf das 50. Byte des
                              200. Satzes positioniert.

  Während der Positionierung brennt  die rote oder grüne Aktivitätslampe der
  Floppy-Disk. Blinkt sie,  so hat das DOS einen  Fehler diagnostiziert, der
  mit der Anweisung PRINT DS$ angezeigt werden kann.

RELATIVDATEIZUGRIFF IM C64-MODUS

  Im C64-Modus erfolgt der Relativdateizugriff über einen speziellen Befehl,
  der über den Befehlskanal 15 der Floppy-Disk gesendet wird.

  Dieser Befehl hat die folgende allgemeine Form:

  "P"+CHR$(SA)+CHR$(SN)+CHR$(SH)+CHR$(BN)

          SA  ist  die  bei  der Dateieröffnung  angegebene  Sekundär-
              adresse (Kanalnummer), die noch um 96 erhöht werden muß.

          SN  ist  der niederwertige  Teil der  Satznummer S,  auf die
              positioniert werden soll. SN=S-INT(S/256)*256

          SN  ist  der höherwertige  Teil  der Satznummer  S, auf  die
              positioniert werden soll. SH=INT(S/256)

          BN  ist die Bytenummer innerhalb des gewünschten Satzes, auf
              die positioniert werden soll.

  Bei  den folgenden  Beispielen  wird  angenommen, daß  die  Datei mit  der
  folgenden Anweisung eröffnet wurde:

  OPEN 7,8,2,"0:BANK,L,"+CHR$(127):OPEN 15,8,15

  PRINT#15,"P"+CHR$(2+96)+    Der  Schreib-/Lesezeiger der Datei,  die unter
           CHR$(200)+CHR$(0)+ der  logischen  Filenummer  2 eröffnet  wurde,
           CHR$(1)            wird auf die  erste Position des Satzes Nummer
                              200 gestellt.

[SEITE 6-13]

  PRINT#15,"P"+CHR$(2+96)+    Der  Schreib-/Lesezeiger der Datei,  die unter
           CHR$(194)+CHR$(1)+ der  logischen  Filenummer  2 eröffnet  wurde,
           CHR$(50)           wird  auf die 50.  Position des  Satzes Nummer
                              450 gestellt.

  Während der Positionierung brennt  die rote oder grüne Aktivitätslampe der
  Floppy-Disk.  Blinkt sie, so hat  DOS einen Fehler diagnostiziert, der mit
  der in Kapitel 6.1 beschriebenen Anweisungsfolge angezeigt werden kann.

6.8 LÖSCHEN VON DISKETTENDATEIEN
--------------------------------

Jede  im Diskettenverzeichnis  aufgeführte  Datei kann  vom Anwender  gelöscht
werden.

DATEI LÖSCHEN IM C128-MODUS

  Es wird folgender Befehl eingegeben:

  SCRATCH Name

  Für 'Name' wird eine bis zu 16 Zeichen lange Zeichenkette, eingekleidet in
  Anführungsstrichen  (") angegeben,  Joker-Zeichen (s.   Kapitel  6.3) sind
  dabei zum Löschen mehrerer Dateien mit gleichen Namensteilen erlaubt.

  Ehe der Befehl  ausgeführt wird, fordert der Interpreter  vom Anwender mit
  der Anfrage

  ARE YOU SURE?

  eine Bestätigung.  Hier  muß 'Y' oder 'YES' eingegeben  werden.  Bei jeder
  anderen Antwort wird der Löschvorgang nicht ausgeführt.

  Während  der  Löschung brennt  die  rote  oder  grüne Aktivitätslampe  der
  Floppy-Disk. Das DOS meldet die erfolgreiche Löschung mit der Meldung

  01,FILES SCRATCHED,nn,00

  wobei für nn  die Anzahl der gelöschten Dateien  gesetzt wird.  Blinkt die
  Aktivitätslampe, so hat DOS  beim Löschen einen Fehler diagnostiziert, der
  mit der Anweisung PRINT DS$ angezeigt werden kann.

                                                                     [6-14]
DATEI LÖSCHEN IM C64-MODUS

  Es wird folgende Anweisungsfolge eingegeben:

  OPEN 15,8,15,"S0:Namen":CLOSE 15

  Für Namen wird eine bis zu  37 Byte lange Zeichenkette eingegeben, die den
  Namen oder  die Namen, durch  Komma getrennt, der zu  löschenden Datei(en)
  enthält. Joker-Zeichen  (s. Kapitel 6.3)  sind dabei zum  Löschen mehrerer
  Dateien mit gleichen Namensteilen erlaubt.

  Die Anzahl der tatsächlich gelöschten  Dateien kann mit der in Kapitel 6.1
  beschriebenen Fehlerabfrage angezeigt werden. Das gleiche gilt für Fehler,
  die das DOS  während des Löschvorganges diagnostiziert hat,  und die durch
  eine blinkende Aktivitätslampe am Laufwerk angezeigt werden.


6.9 WEITERE VERWALTUNGSFUNKTIONEN
---------------------------------

6.9.1 DISKETTENBELEGUNG PRÜFEN UND BEREINIGEN
---------------------------------------------

Nach einer längeren Betriebszeit kann  es vorkommen, daß eine häufig  benutzte
Diskette, bei der wiederholt Dateien gelöscht und neu geschrieben wurden, eine
Anzahl  von Sektoren enthält, die  nicht benutzt werden, obwohl sie eigentlich
als frei gekennzeichnet sein  müßten.  Um diese  Sektoren wieder  verfügbar zu
machen und alle Dateien, die nicht ordnungsgemäß geschlossen wurden (Stern vor
dem Dateityp  im Diskettenverzeichnis), zu   löschen, kann der  COLLECT-Befehl
verwendet werden.

Wird  der COLLECT-Befehl im C128-Modus  bei noch offenen Dateien verwendet, so
werden diese Dateien ordnungsgemäß geschlossen.

DISKETTE BEREINIGEN IM C128-MODUS

  Es wird folgender Befehl eingegeben:

  COLLECT

  Da nach Beendigung der  Operation das Verzeichnis über verfügbare Sektoren
  (BAM) neu geschrieben wird, darf  die betreffende Diskette nicht mit einem
  Schreibschutz versehen sein.

                                                                     [6-15]
DISKETTE BEREINIGEN IM C64-MODUS

  Es wird folgende Anweisungsfolge eingegeben:

  OPEN 15,8,15,"V0":CLOSE 15

6.9.2 DATEI KOPIEREN
--------------------

Eine Datei  kann innerhalb eines  Laufwerks in eine  andere Datei  mit anderem
Namen kopiert werden. Bei Verwendung von Doppellaufwerken kann die Datei unter
dem  selben Namen  auf die Diskette   im anderen Laufwerk   kopiert werden (s.
Floppy-Disk-Handbuch).

DATEI KOPIEREN IM C128-MODUS

  Es wird folgender Befehl eingegeben:

  COPY Name1 TO Name2

  Für  Name1 (Quelldatei)  und Name2  (Zieldatei) werden  bis zu  16 Zeichen
  lange Zeichenketten, eingekleidet in Anführungszeichen ("), angegeben.

  Während des Kopiervorganges brennt die rote oder grüne Aktivitätslampe der
  Floppy-Disk.   Blinkt sie,  so  hat  das DOS  beim  Kopieren einen  Fehler
  diagnostiziert, der mit der Anweisung PRINT DS$ angezeigt werden kann.

DATEI KOPIEREN IM C64-MODUS

  Es wird folgende Anweisungsfolge eingegeben:

  OPEN 15,8,15,"C0:Name2=0:Name1":CLOSE 15

  Für Name2  (Zieldatei) und Name1(Quelldatei) werden  Zeichenketten von bis
  zu  16  Zeichen  Länge  eingegeben.   Der Zieldateiname  wird  als  erster
  angegeben.  Eventuell von  DOS diagnostizierte  Fehler  beim Kopiervorgang
  können  mit  der  in  Kapitel 6.1  beschriebenen  Fehlerabfrage  angezeigt
  werden.

6.9.3 VERKETTUNG SEQUENTIELLER DATEIEN
--------------------------------------

Zwei sequentielle Dateien  können durch einen besonderen Kopierbefehl aneinan-
dergehängt werden.

                                                                     [6-16]
DATEIVERKETTUNG IM C128-MODUS

  Es wird folgender Befehl eingegeben:

  CONCAT Name1 TO Name2

  Für 'Name1' (Quelldatei) und 'Name2'  (Zieldatei) werden bis zu 16 Zeichen
  lange  Zeichenketten, eingekleidet  in  Anführungszeichen ("),  angegeben.
  Durch diesen Befehl wird an die existierende Datei Name2 die Datei 'Name1'
  angehängt.

  Während des Kopiervorganges brennt die rote oder grüne Aktivitätslampe der
  Floppy-Disk.  Blinkt   sie,  so  hat   DOS  beim  Kopieren   einen  Fehler
  diagnostiziert, der mit der Anweisung PRINT DS$ angezeigt werden kann.

DATEIVERKETTUNG IM C64-MODUS

  Es wird folgende Anweisungsfolge eingegeben:

  OPEN 15,8,15,"C0:Name3=0:Name1,0:Name2"

  Für 'Name3' (Zieldatei), 'Name1'  (Quelldatei 1) und 'Name2' (Quelldatei2)
  werden   bis  zu   16   Zeichen  lange   Zeichenketten  eingegeben.   Beim
  Kopiervorgang wird zunächst die Quelldatei  1 in die Zieldatei kopiert und
  anschließend  die Quelldatei  2 angefügt.   Für 'Name3'  und  'Name1' kann
  derselbe Dateiname  verwendet  werden.   In diesem  Fall  würde  die Datei
  'Name2'  an  das  Ende  der  Datei Name1  angehängt.   Eventuell  von  DOS
  diagnostizierte Fehler  beim Kopiervorgang können  mit der in  Kapitel 6.1
  beschriebenen Fehlerabfrage angezeigt werden.

6.9.4 DATEI UMBENENNEN
----------------------

Jeder Datei im Diskettenverzeichnis kann ein  neuer, noch nicht benutzter Name
zugewiesen werden.

DATEI UMBENENNEN IM C128-MODUS

  Es wird folgender Befehl eingegeben:

  RENAME Namealt TO Nameneu

  Für 'Nameneu' und 'Namealt' werden  bis zu 16 Zeichen lange Zeichenketten,
  eingekleidet in Anführungszeichen ("), angegeben.

                                                                     [6-17]

  Während  der Umbenennung brennt  die rote  oder grüne  Aktivitätslampe der
  Floppy-Disk.  Blinkt  sie,  so   hat  DOS  beim  Umbenennen  einen  Fehler
  diagnostiziert, der mit der Anweisung PRINT DS$ angezeigt werden kann.

DATEI UMBENENNEN IM C64-MODUS

  Es wird folgende Anweisungsfolge eingegeben:

  OPEN 15,8,15,"R0:Nameneu=Namealt":CLOSE 15

  Für 'Nameneu' und  'Namealt' werden bis zu 16  Zeichen lange Zeichenketten
  angegeben.  Der  neue  Name  wird  zuerst angegeben.   Eventuell  vom  DOS
  diagnostizierte  Fehler beim  Umbenennen  können mit  der  in Kapitel  6.1
  beschriebenen Fehlerabfrage angezeigt werden.

6.9.5 DISKETTE DUPLIZIEREN
--------------------------

Disketten können mit dem Duplizierbefehl nur kopiert werdcen, wenn ein Floppy-
Disk-Doppellaufwerk zur Verfügung steht.

In das eine  Laufwerk  wird die zu  duplizierende Diskette  und in das  andere
Laufwerk eine Leerdiskette eingelegt.

Um Datenverluste durch Verwechseln von Quell- und Ziellaufwerk beim Duplizier-
befehl zu  vermeiden, sollte  die Quelldiskette mit  einer Schreibschutzlasche
versehen werden.

DISKETTENDUPLIZIERUNG IM C128-MODUS

  Es wird folgender Befehl eingegeben:

  BACKUP DQuellaufwerk TO DZiellaufwerk

  Für Quellaufwerk und Ziellaufwerk werden 0  und 1 oder 1 und 0 eingegeben,
  je nachdem, in welchem Laufwerk welche Diskette eingelegt wurde.

  Da die  Zieldiskette vor dem  Kopiervorgang neu formatiert wird,  wird der
  Anwender mit der Anfrage

  ARE YOU SURE?

                                                                     [6-18]

  zur Bestätigung  aufgefordert.  Antwortet er mit  Y oder YES,  so wird der
  Dupliziervorgang gestartet, bei jeder anderen Antwort abgebrochen.

  Jeder beim  Dupliziervorgang vom DOS  diagnostizierte Fehler wird  mit der
  Bildschirmmeldung

  BAD DISK

  angezeigt.  Der tatsächliche  Fehler  kann dann  mit  PRINT DS$  angezeigt
  werden.

DISKETTE DUPLIZIEREN IM C64-MODUS

  Es wird folgende Anweisungsfolge eingegeben:

  OPEN 15,8,15,"DZiellaufw=DQuelllaufw":CLOSE 15

  Für Ziellaufw  und Quellaufw werden  0 und 1  oder 1 und 0  eingegeben, je
  nachdem,  in  welchem  Laufwerk   welche  Diskette  eingelegt  wurde.  Das
  Ziellaufwerk wird zuerst angegeben.

  Während des Dupliziervorganges brennt  die rote oder grüne Aktivitätslampe
  der Floppy-Disk. Blinkt  sie, so hat DOS einen  Fehler diagnostiziert, der
  mit der in Kapitel 6.1 beschriebenen Fehlerabfrage angezeigt werden kann.

ALLGEMEINE HINWEISE ZU DIESEM HANDBUCH

Das Bildsignal des  80-Zeichen-Modus ist nur  am RGBI-Ausgang vorhanden, nicht
am Video-  bzw. Fernsehausgang,  d.h.  bei Anschluß  eines Fernsehgerätes oder
eines Monitors  an der  Fernsehbuchse bzw.  an  der  Videobuchse kann   nur im
40-Zeichen-Modus gearbetet werden. Umgekehrt ist der 40-Zeichen-Modus nicht am
RGBI-Ausgang verfügbar.

Die  mitgelieferte   CP/M-Systemdiskette  ist   beidseitig   beschrieben.  Wir
empfehlen  Ihnen  von  jeder Seite  eine  Arbeitskopie   anzufertigen und  die
Originaldiskette an einem sicheren Ort aufzubewahren.

[SEITE 7-1]

7. CP/M-MODUS

7.1 EINLEITUNG

CP/M ist ein Produkt der Firma Digital Research.   Die beim Commodore 128 ver-
wendete CP/M Version ist

  CP/M Plus Version 3.0.

In diesem Handbuch wird  diese Version  als  CP/M 3.0  oder nur CP/M  bezeich-
net. Die Beschreibung bezieht sich hier auf  die Anwendung des CP/M beim C128.
Detailliertere  Auskunft finden Sie im  Handbuch für  CP/M-Plus, das zusammmen
mit dem  Utility-Programm  durch  die  Ihrer  Garantieinformation  anhängenden
Bestellkarte angefordert werden kann.

CP/M 3.0 ist weit ein weit verbreitetes Betriebssystem für Mikrocomputer. CP/M
3.0 steuert  und   verwaltet alle  Computerfunktionen:   Speicher,  Disketten-
laufwerke, Konsole (Bildschirm  und Tastatur), Drucker  und andere Peripherie-
geräte.  CP/M  3.0 verwaltet Diskettendateien und  ermöglicht das Kopieren von
Dateien in  den Speicher oder zu anderen  Peripheriegeräten wie z.B.  zu einem
Drucker.  CP/M 3.0   legt verschiedene Programme  im  Computerspeicher ab  und
führt sie in Abhängigkeit  von den Befehlen, die  über die Konsole  eingegeben
werden, aus.

CP/M  kann zum Erstellen  eigener Programme  oder  zum Ausführen einer breiten
Palette bereits vorhandener Programme verwendet werden.

7.1.1 VORAUSSETZUNGEN ZUM BETRIEB MIT CP/M 3.0

Die notwendige Mindestkonfiguration zum Arbeiten unter dem Betriebssystem CP/M
3.0 besteht aus einem Computer mit einem 8080-, 8085- oder Z80-Mikroprozessor,
einer Konsole (Tastatur  und  Bildschirm), einem Diskettenlaufwerk  und  einer
Systemdiskette.

Im   Commodore 128 ist  der  Z80-Mikroprozessor  bereits  fest  eingebaut; als
Konsole dienen die  volle  C128-Tastatur und  ein 80-Zeichen   Bildschirm; als
Diskettenstation kann das  neue schnelle Diskettenlaufwerk  Commodore 1571 wie
auch  das   Laufwerk 1541, dann   allerdings  nur mit  normaler Lese-/Schreib-
Geschwindigkeit  verwendet werden.  Dazu gehören noch  zwei Disketten eine mit
dem   eigentlichen     CP/M-Betriebssystem  und   einem   ausführlichen  HELP-
Dienstprogramm und eine mit vielen anderen Dienstprogrammen.

[SEITE 7-2]

7.1.2 VERWENDUNG EINES 40-ZEICHEN-BILDSCHIRMS

Bei der   Verwendung eines 40-Zeichen-Bildschirms  können nur  40  Zeichen pro
Zeile gleichzeitig  dargestellt werden.  Um  alle  80 Zeichen  nacheinander zu
sehen,  muß der Bildschirminhalt  horizontal verschoben werden.  Dazu wird die
CONTROL-Taste in Verbindung  mit  den entsprechenden Cursortasten  (links oder
rechts) verwendet.

7.1.3 VERWENDUNG DES DISKETTENLAUFWERKS 1541

Auch dieses Laufwerk kann mit CP/M verwendet  werden. Dabei erfolgt der Daten-
transfer zwischen  der Konsole und  Laufwerk wesentlich langsamer  als mit dem
Laufwerk Commodore 1571.

Das Diskettenlaufwerk 1541 kann, im  Gegensatz zum Diskettenlaufwerk 1571, die
Disketten nur einseitig bearbeiten.   Dateien auf mit 1571  beschriebenen Dis-
ketten können  nur  solange bearbeitet werden,   wie sie sich auf  der  ersten
Diskettenseite befinden.

Mit beiden  Laufwerken können auch Disketten,  die mit Commodore 64 und seinem
Z80-Modul angelegt sind, bearbeitet werden.

7.1.4 VERWENDUNG ANDERER DISKETTENFORMATE

Um Dateien von  anderen Computern  bearbeiten zu  können, ermöglicht das  neue
Laufwerk Commodore 1571 auch  die Verwendung von  Disketten, die mit folgenden
Formaten beschrieben sind:

  Epson QX10 Valdocs,
  Kaypro II und
  Osborne

unter dem Betriebssystem CP/M 80 und

  IBM PC bzw. Commodore PC10

unter dem Betriebssystem CP/M 86.

Eine Erweiterung um andere Formate ist mit entsprechenden Programmen jederzeit
möglich.

[SEITE 7-3]

Wird eine mit einem fremden  Format formatierte Diskette  in das Laufwerk 1571
eingelegt, erscheint  beim ersten Zugriff auf  diese Diskette ein Leuchtbalken
in der untersten Bildschirmzeile.   In diesem Leuchtbalken erscheint dann  die
Systembezeichnung  des Diskettenformats  oder,  wenn das  Format nicht identi-
fiziert werden kann, das Wort

                                'MISSING'.

Die  vom Laufwerk akzeptierten Disketten können   dann unter CP/M 3.0 beliebig
gelesen  und  beschrieben werden.   Damit  stehen  dem direkten  Programm- und
Datenaustausch mit anderen Systemen keine Hindernisse im Weg.

Nach der  Meldung  des Fremdformates,  muß entweder Return  zum einmaligen Zu-
griff, oder Control Return  zum dauernden Zugriff  gedrückt werden.  Sollte es
sich z.B.  um eine Diskette Kaypro II handeln, so muß nach der Meldung (Kaypro
II) mit der linken oberen Cursortaste Kaypro II angewählt werden.

Die Programmübernahme wird auch dadurch  erleichtert, daß die C128-Konsole die
Arbeitsweise des Terminals  ADM31 bzw. ADM3A  emuliert.  Die gleiche Emulation
finden wir z.B. bei KAYPRO II und IV.

7.2 STARTEN DES CP/M 3.0

7.2.1 LADEN DES CP/M 3.0

Unter dem Laden (boot) des  CP/M ist ein Kopieren  des Betriebssystems von der
CP/M-Systemdiskette in den Speicher des Computers zu verstehen.

Dies kann auf verschiedene Arten geschehen.  Bei ausgeschaltetem Computer kann
man die  CP/M-Systemdiskette in das  Diskettenlaufwerk  einlegen und dann  den
C128 einschalten. Das  CP/M-Betriebssystem wird automatisch geladen. Wenn sich
der  C128 im BASIC-Modus befindet, können  Sie den BASIC-Befehl BOOT zum Laden
des CP/M   verwenden  oder  die  RESET-Taste  drücken.  Dabei   muß  sich  die
CP/M-Systemdiskette im Laufwerk befinden.

.----------------------------------------------------------------------.
| Achtung:                                                             |
|                                                                      |
| Wenn Sie eine Diskette in das Laufwerk einlegen, vergewissern Sie    |
| sich vor dem Verriegeln des Laufwerks, ob die Diskette bis zum       |
| Anschlag eingeschoben ist!                                           |
`----------------------------------------------------------------------'

[SEITE 7-4]

Wenn Sie aus  dem C64- in den CP/M-Modus  wechseln möchten, müssen Sie  zuerst
den Computer ausschalten und dann das CP/M wie oben beschrieben laden.

Unter CP/M 3.0 steht auf dem Commodore  128 ein freier Benutzerspeicher (TPA -
Transient Program Area) von 59 KByte zur Verfügung.

7.2.2 DIE CP/M-STARTMELDUNG AUF DEM BILDSCHIRM

Nachdem  das  CP/M in  den  Speicher geladen  und gestartet  wurde,  erscheint
folgende Meldung auf dem Bildschirm:


        CP/M3.0 On the Commodore 128
                xx column display

        A>

Je nachdem,  welcher Bildschirm angewählt  ist, erscheint  anstelle von xx die
Zahl 40 oder 80.

Der wichtigste Teil dieser Meldung sind die zwei folgenden Zeichen:

A>

Das ist  die CP/M-System- bzw.  Bereitschaftsmeldung  (system  prompt).  Diese
Meldung  signalisiert die Bereitschaft von  CP/M zu einer Befehlsübernahme von
der Tastatur.   Die Meldung sagt  weiterhin aus, daß  das  Laufwerk A das sog.
aktuelle Laufwerk   ist.  Das bedeutet,  daß bis  zu einer  anderen Laufwerks-
eingabe  von der Tastatur alle  Diskettenoperationen auf dem Laufwerk A durch-
geführt werden.   Das Fehlen einer Nummernangabe  vor dem A bedeutet,  daß der
Benutzerbereich 0 (USER 0) der aktuelle Benutzerbereich ist.

Unter CP/M  wird ein Disketteneinzellaufwerk  als Laufwerk A  zugeordnet.  Das
entspricht  der Geräteadresse  8,  Laufwerk  0 im  C128-  und C64-Modus.   Die
maximale  Anzahl der  tatsächlich  angeschlossenen Diskettenlaufwerke  beträgt
vier.   Weiteren  Laufwerken  sind  die  Laufwerksbezeichnungen  B,  C  und  D
zugeordnet. Ein virtuelles Laufwerk, das auf dem Einzellaufwerk A ein weiteres
Laufwerk emuliert, erhielt die Bezeichnung E.

[SEITE 7-5]^

7.2.3 DIE CP/M BEFEHLSZEILE

CP/M  3.0 steuert  die Aktivitäten   des  Computers  in Abhängigkeit  von  den
Befehlen, die Sie über die Tastatur eingeben. Diese Befehle erscheinen auf dem
Bildschrim in einer Befehlszeile. Eine  CP/M Befehlszeile setzt sich aus einem
Befehlsschlüsselwort  und aus  optionellen  Befehlsargumenten  zusammen.   Das
Befehlsschlüsselwort  bezeichnet     entweder  einen  residenten   CP/M-Befehl
(z.B. TYPE,  DIR u.a.) oder ein ausführbares  Programm auf der  Diskette.  Das
Argument beinhaltet  zusätzliche  Informationen, z.B.   Dateiname  oder andere
Parameter. Nachfolgend ein Beispiel für eine Befehlszeile:

A>DIR TESTDATA

In diesem Beispiel ist DIR das Befehlsschlüsselwort und TESTDATA das Argument.
Um  die Befehlszeile  an CP/M   zu übergeben, muß  die  RETURN-Taste  gedrückt
werden.  In dieser Anleitung wird  das notwendige Drücken der RETURN-Taste mit
<CR> dargestellt.

Beim  Eingeben  eines  Zeichens auf der    Tastatur erscheint  dieses  Zeichen
gleichzeitig auch auf  dem Bildschirm.  Der Cursor  bewegt sich dabei  um eine
Stelle nachrechts. Wenn Sie sich vertippen, drücken Sie die INST/DEL-Taste. Um
ein   Controlzeichen  einzugeben,  muß die  CTRL-Taste  gedrückt  gehalten und
gleichzeitig die entsprechende andere Taste betätigt werden. Manchmal wird für
CONTROL auch die Abkürzung ^ (Pfeil nach oben), z.B. ^Z für CTRL-Z, verwendet.

Eine übersicht der Control-Zeichen  und deren Verwendung  ist im Abschnitt 7.5
abgedruckt.

Alle Eingaben in  der Befehlszeile können in   kleinen bzw. großen  Buchstaben
erfolgen.   CP/M  interpretiert   alle    Zeichen  in der   Befehlszeile   als
großgeschrieben.

Die  Eingabe in  die Befehlszeile  sollte unmittelbar  nach der Bereitschafts-
meldung erfolgen, obwohl CP/M 3.0 auch Leerstellen zwischen der Bereitschafts-
meldung und Befehlswort toleriert.

[SEITE 7-6]

7.2.4 DIE BEFEHLSARTEN

CP/M 3.0 unterscheidet zwei verschiedene Befehlsarten: interne bzw.  residente
(built-in commands) und  externe bzw. transiente  Befehle (Dienst- und  andere
Programme).

Residente Befehle  veranlassen die   Ausführung  von Programmen,  die  fest im
Speicher als Teil  des  CP/M verankert sind.   diese Befehle  können jederzeit
ausgeführt werden, da dazu keine Diskettendateien notwendig sind.

Transiente Programme sind als Programmdateien auf  Disketten gespeichert.  Sie
müssen zuerst  von der  Diskette geladen werden,  bevor  sie ausgeführt werden
können.  Diese  Programmdateien   sind durch die  Typbezeichnung  COM  gekenn-
zeichnet.

Bei den transienten Befehlen  wird   nur  das Befehlsschlüsselwort von    CP/M
interpretiert und die  entsprechende Datei   von  der Diskette geladen.    Die
Argumente werden durch CP/M nicht  überprüft, sondern direkt für die Programme
in einem Puffer abgelegt. Eine Befehlszeile darf nicht  länger als 128 Zeichen
sein.

7.2.5 VERARBEITUNG EINER BEFEHLSZEILE DURCH CP/M

Nehmen wir  den DIR-Befehl,  um zu sehen,  wie CP/M  eine Befehlszeile  inter-
pretiert.  DIR, das eine  Abkürzung für 'directory' darstellt, veranlaßt CP/M,
eine  Verzeichnis der Diskettendateien   auf dem  Bildschirm  anzuzeigen.  Der
Befehl  DIR  wird direkt  nach  der  Systemmeldung eingegeben  und  mit RETURN
abgeschlossen.

A>DIR<CR>

CP/M reagiert auf diesen  Befhl mit der Anzeige der  Namen aller Dateien,  die
auf der Diskette im Laufwerk A gespeichert  sind. Wenn sich beispielsweise die
CP/M-Systemdiskette im Laufwerk A  befindet, wird folgendes auf dem Bildschirm
angezeigt:

[SEITE 7-7]

        PIP     COM:ED  COM:CCP         COM:HELP        COM
        A:HELP  HLP:DIR COM:CPM+                        SYS

CP/M erkennt nur korrekt  eingegebene Befehlsschlüsselworte.  Wenn Sie bei der
Eingabe einen  Fehler machen  und RETURN  drücken, ohne  den Fehler  zu korri-
gieren,  wiederholt CP/M die Befehlszeile  und fügt  ein Fragezeichen an. Wird
z.B. fälschlich anstelle von DIR

A>DJR<CR>

eingegeben, reagiert CP/M wie folgt:

Auf der  Diskette im Laufwerk  A wird nach einer Datei  DJR.COM  gesucht.  Ist
diese Datei nicht vorhanden, wird auf dem Bildschirm

DJR?

angezeigt.

Dies bedeutet, daß der Befehl  DJR vom  CP/M nicht gefunden  werden kann.   Um
einen Tippfehler auszubessern, können Sie  die INST/DEL-Taste oder CTRL-H  zum
Löschen des letzten eingegebenen Zeichens verwenden.

CP/M  stellt eine   Reihe  von CTRL-Zeichen  zur  Verfügung,   die  Ihnen beim
Editieren der Befehlszeile helfen.

[SEITE 7-8]

Im  Abschnitt 7.6,  Tabelle 7.3,  ist eine Übersicht  dieser  CTRL-Zeichen und
deren Funktionen abgedruckt.

Der Befehl  DIR  akzeptiert einen  Dateinamen  als  Argument.  DIR mit   einem
Dateiname  als  Argument wird  dazu  verwendet,  um  zu  sehen,  ob sich  eine
bestimmte Datei auf der Diskette befindet.  Um z.B. festzustellen, ob sich die
Datei TESTDATA auf der Diskette befindet, wird eingegeben:

A>DIR TESTDATA<CR>

CP/M antwortet auf  diese Eingabe mit der  Anzeige des Dateinamens oder (falls
die Datei nicht auf der Diskette vorhanden ist) mit der Meldung:

No File

Zwischen dem Befehlswort und  dem  Argument muß  eine  Leerstelle  ausgelassen
werden. Wird  diese Leerstelle nicht eingegeben,  reagiert  das CP/M mit einer
Fehlermeldung:

A>DIRTESTDATA<CR>
DIRTESTDATA?

7.3 CP/M Dateien

Eine  der wichtigsten CP/M-Eigenschaften ist das  Verwalten und Bearbeiten von
Dateien auf Disketten. Dateien im  CP/M-Modus sind im  Prinzip das gleiche wie
im C128-  oder C64-Modus -  nämlich eine Datenmenge.   Allerdings werden diese
Dateien von CP/M anders  als in den  anderen Modi behandelt.  Dieser Abschnitt
macht Sie mit  zwei  Arten von Dateien  bekannt;  Sie werden  lernen,  wie man
Dateien  erstellt, benennt   und   bearbeitet und  welche Dateien    auf Ihren
CP/M-Disketten abgespeichert sind.

Wie bereits gesagt, eine  CP/M-Datei ist eine  Menge von Daten. Jede Datei muß
einen eindeutigen Namen  haben, damit sie  von  CP/M erkannt  wird.  Auch eine
Inhaltsverzeichnis (directory) ist auf jeder Diskette abgespeichert. In diesem
Inhaltsverzeichnis  sind   die Namen aller  Dateien   und  deren Lage  auf der
Diskette festgehalten.

[SEITE 7-9]

7.3.1 ZWEI ARTEN VON CP/M-DATEIEN:

Programmdateien und Datendateien.

In   einer Programmdatei   sind  ausführbare  Befehle abgespeichert, die   vom
Computer schrittweise abgearbetet  werden können.   Eine Datendatei beinhaltet
verschiedene Informationen, z.B. eine  Namens- oder ein Adressverzeichnis oder
einen  Text.  Die Datendateien können selbst  nicht ausgeführt sondern nur von
den Programmdateien verarbeitet werden.

7.3.2 ERSTELLEN EINER DATEI

Es gibt verschiedene Möglichkeiten, um  CP/M-Dateien zu erstellen.  Beispiels-
weise könnte  der CP/M-Texteditor  ED dazu  verwendet  werden, um  Dateien  zu
erstellen und zu  benennen.  Sie können auch eine  Datei  erstellen, indem Sie
eine bereits existierende Datei an eine andere Stelle kpieren; dabei kann auch
der Name der Datei geändert  werden.  Unter  CP/M  kann dazu das Programm  PIP
verwendet werden.  Auch andere Programme,  z.B.  MAC, der CP/M  3.0-Assembler,
erzeugen Ausgabedateien, und   diese  können wiederum als Eingabedateien   für
andere Programme verwendet werden.

Die ED- und PIP-Befehle sind,  zusammen mit anderen CP/M-Befehlen, ausführlich
im Teil 7.9 aufgeführt.

7.3.3 DIE DATEIBEZEICHNUNG

CP/M erkennt jede  Datei  an ihrer  eindeutigen  Bezeichnung.  Für die  Datei-
bezeichnung werden folgende Teile verwendet:

        - die Laufwerksbezeichnung
        - der Dateiname
        - die Typbezeichnung
        - das Paßwort

Unbedingt  erforderlich  ist   die   Angabe  des   Dateinamens;   alle anderen
Bestandteile   der   Dateibezeichnung können, müssen    aber  nicht  unbedingt
angegeben werden.

[SEITE 7-10]

7.3.4 DIE LAUFWERKSBEZEICHNUNG

Die  Laufwerksbezeichnung  besteht  aus   einem Buchstaben   (A-E) mit   einem
nachfolgenden Doppelpunkt.   Jedem  CP/M-Diskettenlaufwerk ist  ein  Buchstabe
zugeordnet.  Wenn sie  die Laufwerksbezeichnung als Teil der  Dateibezeichnung
angeben, sucht CP/M auf diesem Laufwerk nach der angegebenen Datei.

Wenn Sie z.B.:

A>B:TESTDATA<CR>

eingeben,   wird  auf   dem  Diskettenlaufwerk  B    nach  der Datei  TESTDATA
gesucht. Ohne Angabe der Laufwerksbezeichnung  wird auf dem aktuellen Laufwerk
(in der Regel A) nach der Datei gesucht.

7.3.5 DER DATEINAME

Ein Dateiname kann  bis zu 8 Zeichen lang  sein. Eine Dateibezeichnung kann im
einfachsten Fall nur aus einem Dateinamen bestehen.


Der Dateiname sollte  so gewählt werden,  daß man aus  ihm auf den Inhalt  der
Datei schließen kann. Wenn Sie Beispielsweise ein Kundenverzeichnis erstellen,
können Sie als Namen dieser Datei

KUNDEN

wählen, so daß Sie schon an dem Dateinamen den Inhalt der Datei erkennen.

7.3.6 DIE TYPBEZEICHNUNG

Um Dateien,  die ähnliche  Strukturen  aufweisen,  auch bei  unterschiedlichen
Dateinamen zusammenfassen zu  können, läßt sich wahlweise eine  Typbezeichnung
an den Dateinamen  anhängen.  Diese Typbezeichnung kann bis  zu 3 Zeichen lang
sein und wird vom eigentlichen Dateinamen mit einem Punkt (.) abgetrennt. Auch
bei der  Wahl dieser Typbezeichnung sollte  die Bezeichnung in einem Zusammen-
hang mit der Art der Datei stehen.

[SEITE 7-11]

Unser Kundennamensverzeichnis   könnte beispielsweise  diese  Bezeichnung  be-
kommen:

KUNDEN.NAM

Bei  der Anzeige von Dateibezeichnungen  durch CP/M werden kurze Dateiname mit
Leerzeichen  auf  acht  Stellen aufgefüllt,  so daß  ein  Vergleich  der  Typ-
bezeichnungen schnell erfolgen kann.

Die  Programmdateien, die von  CP/M in  den  Speicher  geladen und  ausgeführt
werden, sind immer durch die Typbezeichnung COM gekennzeichnet.

7.3.7 DAS PAßWORT

Bei  CP/M  3.0   auf dem  Commodore   128  kann  ein  Paßwort   als  Teil  der
Dateibezeichnung  definiert werden.  Das  Paßwort kann bis  zu 8 Zeichen lang
sein und  wird  bei der Eingabe mit  einem  Semikolon von der  vorangestellten
Dateibezeichnung getrennt:

KUNDEN.NAM;LISTE

Das Paßwort  kann wahlweise eingegeben werden.   Allerdings muß dieses Paßwort
als  Teil der Dateibezeichnung immer eingegeben  werden,  wenn der Zugriff auf
eine Datei mit einem Paßwort geschützt ist.

Beispiel einer vollständigen Dateibezeichnung:

A:DOKUMENT.GES;EDGAR

7.3.8 DATEISPEZIFIKATION 'dateispez'

Als 'dateispez'  (Dateispezifikation)  wird jede  zulässige  Kombination der 4
Teile der Dateibezeichnung    abgekürzt.    Alle Teile mit  ihren    passenden
Trennzeichen getrennt werden.

Zulässige Kombinationen für CP/M-Dateibezeichnungen sind:

        Dateiname
        Laufwerksbezeichnung:Dateiname
        Dateiname.Typbezeichnung
        Laufwerksbezeichnung:Dateiname.Typbezeichnung
        Dateiname;Paßwort
        Laufwerksbezeichnung:Dateiname;Paßwort
        Dateiname.Typbezeichnung;Paßwort
        Laufwerksbezeichnung:Dateiname.Typbez;Paßwort

[SEITE 7-12]^

7.3.9 BENUTZERBEREICH (USER)

CP/M kann die  Dateien auch einem Benutzerbereich (User  0-15) zuordnen.   Mit
den Benutzerbereichsnummern  (User-Nummern) können Dateien  in 16 verschiedene
Bereiche eingeteilt  werden.  Die  Benutzerbereichsnummer  wird der Datei  bei
deren Erstellung zugeordnet.

Die   Benutzerbereichsnummer   wird  immer     der   CP/M-Bereitschaftsmeldung
vorangestellt  (mit Ausnahme der   Nummer 0).  Der  Benutzerbereich 0  ist der
voreingestellte Bereich, seine Nummer  wird in der  Bereitschaftsmeldung nicht
angezeigt.  Nachfolgend einige Beispiele  für die Anzeige der Benutzerbereiche
und deren Bedeutung:

4A>     Benutzerbereich 4, Laufwerk A
A>      Benutzerbereich 0, Laufwerk A
2B>     Benutzerbereich 2, Laufwerk B

Zum Ändern des aktuellen Benutzerbereichs   kann der interne Befehl USER  ver-
wendet werden.

A>USER 3<CR>
3A>

Sie können auch gleichzeitig  den  Benutzerbereich und das aktuelle   Laufwerk
ändern, indem Sie beides gleichzeitig eingeben:

A>3B:<CR>
3B>

Die  meisten  Befehle haben  nur  auf die Dateien  Zugriff,  die dem aktuellen
Benutzerbereich  zugeordnet sind.   Allerdings  kann  man aus  allen Benutzer-
bereichen auf die Dateien zugreifen, die dem  Benutzerbereich 0 zugeordnet und
mit dem SYS-Attribut gekennzeichnet sind.

[SEITE 7-13]

7.3.10 PLATZHALTER BEIM ZUGRIFF AUF MEHRERE DATEIEN

Jeder interne   oder  transiente CP/M-Befehl kann   sich auf  mehrere  Dateien
beziehen, wenn im  Dateinamen  oder der Typbezeichnung  besondere Platzhalter-
zeichen verwendet werden.

Ein Platzhalter ist ein Zeichen, das  anstelle aller andere zulässigen Zeichen
verwendet  werden kann. CP/M verwendet den  Stern (*) und das Fragezeichen (?)
als Platzhalter.  Wird z.B. das Fragezeichen (?)  als drittes Zeichen in einem
Dateiname  eingesetzt wird von  CP/M an dieser  Stelle jedes beliebige Zeichen
akzeptiert. Ein * veranlaßt CP/M, den  Dateinamen oder die Typbezeichnung von
der  Stelle,  an der  er eingesetzt   wird, mit   ?   aufzufüllen.   mit einer
Dateibezeichnung,  die  Platzhalter  beinhaltet, kann  CP/M  entsprechend  den
Vorgaben auf mehrere Dateien zugreifen. Wenn z.B. folgendes eingegeben wird:

?????TAX.LIB

ordnet CP/M  alle Dateien,   die im  Dateiname  auf  TAX  enden und  die  Typ-
bezeichnung  LIB haben, dieser Dateibezeichnung  zu.  Anstelle der ersten fünf
Zeichen können beliebige Zeichen stehen.

7.3.11 RESERVIERTE ZEICHEN

Die Zeichen, die  in der folgenden  Tabelle 7.1  aufgeführt sind,  haben unter
CP/M  eine besondere  Bedeutung   und    dürfen  nicht  als  Bestandteil   der
Dateibezeichnung verwendet werden.

[SEITE 7-14]

Tabelle 7.1     CP/M 3.0 Reservierte Zeichen

Zeichen   |   Bedeutung
----------+-----------------------------------------------------------
<=,!|>[]  |
TAB CR    |   Befehlszeile - Trennzeichen
LEERST.   |
:         |   Laufwerksbezeichnung - Trennzeichen
.         |   Typbezeichnung - Trennzeichen
;         |   Paßwort - Trennzeichen  oder Kommentar  - Trennzeichen
          |   am Anfang der Befehlszeile
*?        |   Platzhalter
[]        |   Befehlsargumente - Trennzeichen für globale und lokale
          |   Optionen
()        |   Trennzeichen  für  mehrfache  Angaben  innerhalb   von
          |   eckigen Klammern
/$        |   Weitere Trennzeichen in der Befehlszeile
<>&!|\+-  |   Weitere Trennzeichen


7.3.12 RESERVIERTE TYPBEZEICHNUNGEN

Unter CP/M  3.0 sind  mehrere Dateitypen  bestimmten  Programmen bereits  fest
zugeordnet.  In der nachfolgenden Tabelle  7.2 werden sie aufgelistet und kurz
beschrieben.


Tabelle 7.2     CP/M 3.0 Reservierte Typbezeichnungen


  Typ   |   Bedeutung
--------+--------------------------------------
  ASM   |   Quelldaten für Assembler ASM
  BAS   |   BASIC Programm
  COM   |   Ausführbare Programmdatei
  HEX   |   Ausgabedatei von MAC (für HEXCOM)
  HLP   |   HELP-Datei
  $$$   |   Zwischendatei (temporär)
  PRN   |   Printdatei von MAX oder RMAC
  REL   |   Ausgabedatei von RMAC (für LINK)
  SUB   |   Befehlsliste für SUBMIT
  SYM   |   Symboldatei von MAC, RMAC oder LINK

[SEITE 7-15]

7.4 KOPIEREN DER CP/M-DISKETTEN UND -DATEIEN

Kopien  (backups) der CP/M-Disketten können   mit  einem oder zwei  Disketten-
laufwerken angefertigt werden.  Die Diskette auf  welche übertragen wird, kann
neue oder bereits   benutzte  Diskette sein.    Diese  Diskette muß   vor  dem
eigentlichen Kopiervorgang  bereits formatiert sein.   Dazu muß ein geeignetes
Formatierungsprogramm verwendet  werden.  Auf  der  Diskette  mit den  Dienst-
programmen befindet sich hierzu das  Programm FORMAT.COM.  Mit diesem Programm
wird  auch   der CP/M-Systembootsektor   auf    die neu  formatierte  Diskette
übertragen.

Nach dem FORMAT-Aufruf erscheint auf dem Bildschirm die Meldung:


        C128 FORMAT PROGRAM

        Drive A is 1571         ; bzw. 1541

        Please select disk type to format
        C128 double sided       ; nicht mit 1541
        C128 single sided
        C64 single sided        ; Z80-Modul-Format

[SEITE 7-16]

Mit den Cursortasten wir ein inverser Zeiger  in die Zeile mit der gewünschten
Formatbezeichnung bewegt und die RETURN-Taste gedrückt. Dann erscheint:

        Insert Diskette TO BE FORMATTED in Drive A
        type $ when ready, any other key to abort

[SEITE 7-17]

Nach dem Einlegen der zu formatierenden Diskette in Laufwerk A muß die $-Taste
gedrückt werden. Es erscheint:

        ...formatting diskette in drive a
        ...writing directory sectors
        ...writing boot sector

        Do you want to format another disk?

Beim Eingeben von N wird mit der Meldung

...exiting format program

das FORMAT-Programm beendet.

Alle anderen  Dateien, auch die  Systemdateien CPM+.SYS und CCP.COM können mit
dem Dienstprogramm PIP kopiert werden.

7.4.1 KOPIEREN MIT EINEM DISKETTENLAUFWERK

Disketteninhalte können von einer auf  eine andere Diskette auch mit nur einem
Diskettenlaufwerk  (1541   oder  1571)   übertragen  werden.  Dazu   wird  das
Dienstprogramm PIP verwendet.  Das Format für die PIP-Befehlseingaben kann mit
dem HELP-Befehl:

A>HELP PIP<CR>

auf dem Bildschirm angezeigt werden. Als Quellaufwerk  wird das Laufwerk A und
als Ziellaufwerk E  eingegeben.  Das Laufwerk E ist  ein virtuelles Laufwerk -
das bedeutet,  daß dieses Laufwerk nicht als ein  Teil der Hardware existiert.
Während des Kopierens werden Sie aufgefordet, die Quelldiskette herauszunehmen
und eine  Zieldiskette einzulegen. Diese  Aufforderung wird je  nach Länge der
kopierten Dateien mehrmals wiederholt.

[SEITE 7-18]^

Wird  mit dem PIP eine ganze  Diskette  kopiert, so  muß  beachtet werden, daß
Files,  die eine andere Extension  als COM haben, auf jeden  Fall die Option O
für Objektcode bekommen müssen: PIP b:=a*.*äoü (ä,ü bei deutschem Zeichensatz,
statt rechteckiger Klammer).

7.4.2 KOPIEREN MIT ZWEI DISKETTENLAUFWERKEN

Mit zwei Laufwerken kann das Kopieren bequemer und schneller als mit nur einem
Laufwerk  durchgeführt werden.  Die Laufwerke haben  in der Regel die Bezeich-
nungen A und B.

Um die CP/M-Systemdateien zu kopieren, wird das PIP-Programm aufgerufen:

A>PIP<CR>
CP/M3 PIP VERSION 3.0
*

Jetzt wird z.B. eingegeben:

*b:=c*.*

und während des Kopierens erscheint nacheinander:

COPYING-
CPM+.SYS
CCP.COM
*

Anschließend können noch andere Dateien  übertragen oder das PIP-Programm  mit
CTRL-C beendet werden.

[SEITE 7-19]

7.5 STEUERN DER EIN- UND AUSGABE

7.5.1 STEUERN DER KONSOLENAUSGABE

Die Anzeige von  Informationen auf dem Bildschirm  erfolgt oft so schnell, daß
nicht mitgelesen  werden kann.  Um   dem System mitzuteilen,  daß die  Ausgabe
angehalten werden soll, drücken Sie die CTRL-Taste  und gleichzeitig die Taste
S.  Das CTRL-S-Zeichen bewirkt   ein Anhalten der  Ausgabe.   Die Ausgabe wird
fortgesetzt, indem CTRL-Q gedrückt wird.  Auch das Drücken der NO SCROLL-Taste
hält  die Ausgabe  an.  In der   untersten Zeile  (25)  erscheint invers  eine
PAUSE-Anzeige. Bei wiederholtem Drücken  der NO SCROLL-Taste wird  die Ausgabe
wieder fortgesetzt. Wird während  der Pause eine  andere Taste als CTRL-Q oder
NO SCROLL betätigt, ertönt eine Piepton.

Einige CP/M-Programme (z.B.  DIR oder TYPE) verwenden automatische seitenweise
Ausgabe  (paging)  auf  der Konsole.   Das   bedeutet, daß bei einer  längeren
Ausgabe, als  eine Bildschirminhalt  fassen  kann, die Ausgabe   bei gefülltem
Bildschirm selbständig angehalten wird.  Wenn dies  geschieht erscheint in der
untersten Zeile die Aufforderung:

Press RETURN to countinue

Erst dann wird  die  Ausgabe wieder  fortgesetzt.  Diese Option  kann  mit dem
SETDEF-Befehl ein- oder ausgeschaltet werden.

7.5.2 STEUERN DER AUSGABE AUF DEM DRUCKER

Mit einem  CTRL-Zeichen  kann die  Konsolenausgabe   auch parallel  auf  einem
Drucker geleitet werden  (printer echo). Um die  gleichzeitige Ausgabe auf den
Drucker zu starten, wird CTRL-P eingegeben. Dabei ertönt ein Piepton.

Beendet   wird die Druckerausgabe  durch    erneuerte Eingabe von CTRL-P.  Bei
eingeschalteter Druckerausgabe  wird  jedes  Zeichen, das auf   dem Bildschirm
erscheint, auch  auf dem Drucker  ausgedruckt. Bei  nichtbereitem Drucker wird
auch  die Bildschirmausgabe solange blockiert,  bis der  Drucker wieder bereit
wird.

Zum Erstellen einer  Liste der Dateien, die  sich auf einer Diskette befinden,
kann der Befehl DIR  mit  nachfolgender Eingabe von  CTRL-P (vor  dem  RETURN)
verwendet werden.

[SEITE 7-20]

Auch bei der Druckerausgabe können die Zeichen CTRL-S, CTRL-Q und die Taste NO
SCROLL verwendet  werden,  um  die Ausgabe zu   steuern. Soll  ein Teil  nicht
mitgedruckt werden, wird die  Ausgabe mit CTRL-S gestopppt, die Durckerausgabe
mit  CTRL-P abgeschaltet  und die  Bildschirmausgabe  mit CTRL-Q  fortgesetzt.
Dabei können die Zeichen CTRL-P, CTRL-S und CTRL-Q beliebig kombiniert werden.

7.5.3 ZEILENEDITIERUNG AUF DER KONSOLE

Wie bereits  erwähnt,  können Sie  einfach Tippfehler  mit den Tasten INST/DEL
bzw. CTRL-H korrigieren. CP/M stellt außerdem noch andere Editierfunktionen in
Form   von  CTRL-Zeichen zur    Verfügung.  Mit  diesen   CTRL-Zeichen  können
CP/M-Befehlszeilen oder Eingabezeilen anderer Programme editiert werden.

7.5.4 CTRL-ZEICHEN ZUM EDITIEREN

Bei  der Verwendung  von CTRL-Zeichen, die   in  Tabelle 7.3 aufgeführt  sind,
können Sie den Cursor nach   links und rechts  zum  Einfügen oder Löschen  von
Zeichen in der Mitte  der editerten Zeile bewegen.   Das bedeutet, daß Sie die
Zeichen,  die rechts von  der korrigierten Stelle  stehen, nicht neu eintippen
müssen.

Im folgenden Beispiel wird gezeigt, wie eine falsche Eingabe von PIP korrigert
werden kann:

A>POP A:=B:*.*<CR>      (PIP falsch eingegeben)
?POP
A>POP A:=B:*.*          (CTRL-W wiederholt die Befehlszeile)
A>POP A:=B:*.*          (CTRL-B bewegt den Cursor an den Zeilenanfang
A>P1I0P A:=B:*.*        (CTRL-F bewegt den Cursor nach rechts)
A>PP A:=B:*.*           (CTRL-G löscht Fehler)
A>PI1P0 A:=B:*.*        (das I wird eingegeben)

Nach der Korrektur kann die RETURN-Taste gedrückt werden, auch wenn der Cursor
noch in  der Mitte der Zeile plaziert  ist.  Der RETURN-Befehl veranlaßt nicht
nur die Ausführung der Befehlszeile, sondern speichert die Zeile auch in einem
Puffer, so daß sie mit CTRL-W wieder aufgerufen werden kann.

[SEITE 7-21]

Wenn Sie ein Zeichen in die Mitte der Befehlszeile einfügen, bewegen sich alle
Zeichen rechts vom Cursor weiter  nach rechts.  Wird die  Zeile länger als die
Bildschirmbreite, verschwinden die Zeichen auf der rechten Bildschirmseite aus
dem Bild. Diese Zeichen sind aber nicht gelöscht. Sie werden wieder angezeigt,
wenn Sie Zeichen  in der Zeile  löschen oder  CTRL-E drücken, sobald  sich der
Cursor in der Mitte befindet. Mit CTRL-E werden alle Zeichen rechts vom Cursor
in die nächste Bildschirmzeile bewegt.


Tabelle 7.3             CP/M 3.0: Editier- und Steuer-CTRL-Zeichen

Zeichen         |       Bedeutung
----------------+-----------------------------------------------------
                |
CTRL-A          |       Bewegt den Cursor eine Stelle nach links.
                |
CTRL-B          |       Bewegt  den Cursor an  den Anfang der Befehls-
                |       zeile, ohne in   der Zeile   eine  Veränderung
                |       hervorzurufen.  Wenn   sich   der  Cursors  am
                |       Anfang der Zeile befindet,  wird er mit CTRL-B
                |       auf das Zeilenende bewegt, usw.
                |
CTRL-C          |       Unterbricht  den  Programmablauf und setzt die
                |       Laufwerksparameter zurück.
                |
CTRL-E          |       Bewirkt einen Zeilenvorschub, ohne den  Befehl
                |       an CP/M  zu übergeben.   Bewegt den  Cursor an
                |       den   Anfang der   nächsten  Zeile,  ohne  die
                |       bisherigen Eingaben zu löschen.
                |
CTRL-F          |       Bewegt den Cursor um eine Stelle nach rechts.
                |
CTRL-G          |       Löscht das  Zeichen   unter dem  Cursor.   Der
                |       Cursor  wird dabei  nicht  bewegt. Die Zeichen
                |       rechts vom Cursor  werden um eine Stelle  nach
                |       links bewegt.
                |
CTRL-H          |       Löscht das Zeichen links vom Cursor und bewegt
                |       den   Cursor um eine  Stelle  nach links.  Die
                |       Zeichen  rechts  vom  Cursor werden   um  eine
                |       Stelle nach links verschoben.

[SEITE 7-22]

Zeichen         |       Bedeutung
----------------+-----------------------------------------------------
                |
CTRL-I          |       Bewegt  den Cursor zur nächsten TAB-Marke. Die
                |       TAB-Marken sind  automatisch   auf jede  achte
                |       Stelle gesetzt.   Hat die gleiche Funktion wie
                |       die RETURN-Taste oder CTRL-M.
                |
CTRL-J          |       übergibt  die Befehlszeile  an CP/M und  setzt
                |       den    Cursor   an  den   Anfang  der nächsten
                |       Zeile.  Hat  die  gleiche  Funktion   wie  die
                |       RETURN-Taste oder CTRL-M.
                |
CTRL-K          |       Löscht alle Zeichen rechts vom Cursor.
                |
                |
CTRL-M          |       übergibt die Befehlszeile  an  CP/M  und setzt
                |       den  Cursor an den  Anfang der nächsten Zeile.
                |       Hat die gleiche  Funktion wie die RETURN-Taste
                |       oder CTRL-J.
                |
CTRL-P          |       Schaltet  parallel  zur Bildschirmausgabe auch
                |       die Druckerausgabe ein.
                |
CTRL-Q          |       Die Bildschirmausgabe wird fortgesetzt.
                |
CTRL-R          |       Wiederholt  die Befehlszeile bis zum Cursor in
                |       der nächsten  Zeile.   An  der  Cursorposition
                |       erscheint  ein  #-Zeichen, und der Cursor wird
                |       um eine  Zeile in derselben Spalte  nach unten
                |       bewegt.
                |
                |
CTRL-S          |       Die    Bildschirmausgabe wird  so  lange ange-
                |       halten, bis CTRL-Q eingegeben wird.
                |
CTRL-U          |       Löscht alle Zeichen in der Befehlszeile, setzt
                |       ein  #-Zeichen   an   der Cursor-Position  und
                |       bewegt den Cursor in   die nächste Zeile.  Mit
                |       CTRL-W  können alle  Zeichen,  die links neben
                |       dem Cursor in der alten Zeile gestanden haben,
                |       in der neuen Zeile wiederholt werden.

[SEITE 7-23]

Zeichen         |       Bedeutung
----------------+-------------------------------------------------------
                |
CTRL-W          |       Wiederholt die letzte   ausgeführte   Befehls-
                |       zeile,  ohne sie an   CP/M zu übergeben.   Der
                |       Cursor muß dabei  am  Anfang  der Befehlszeile
                |       stehen, sonst  wird  CTRL-W nicht  ausgeführt.
                |       Wiederholt wird die letzte mit CTRL-J, CTRL-M,
                |       CTRL-U oder RETURN abgeschlossene Zeile.  Wenn
                |       sich  in   der   Befehlszeile bereits  Zeichen
                |       befinden, wird mit CTRL-W der Cursor lediglich
                |       an das Ende  der Zeile bewegt.   Mit <CR> wird
                |       die wiederholte Zeile an CP/M übergeben.
                |
CTRL-X          |       Löscht   alle  Zeichen  links  vom  Cursor und
                |       bewegt  den   Cursor   an   den    Anfang  der
                |       Zeile. Alle Zeichen  rechts vom Cursor  werden
                |       ab Zeilenanfang kopiert.
                |
CTRL-Z          |       Dateiendezeichen.

[SEITE 7-24]

7.6 ARBEITEN UNTER CP/M

7.6.1 UMLEITUNG VON EINGABEN UND AUSGABEN

Der Befehl  PUT ermöglicht  es, die  Ausgabe auf den  Bildschirm oder  auf den
Drucker in eine Diskettendatei umzuleiten. Der GET-Befehl wird dazu verwendet,
die Konsoleneingabe  für CP/M oder ein  Programm anstelle von der Koknsole aus
einer Diskettendatei vorzunehmen.  Die  nachfolgenden Beispiele  zeigen einige
der Möglichkeiten, die sich hinter GET und PUT verbergen.

PUT wird verwendet, um die Ausgabe  von der Konsole  in eine Diskettendatei so
zmzuleiten, also ob es die Konsole wäre. Mit PUT kann z.B. eine Diskettendatei
erstellt werden, in der   das Inhaltsverzeichnis der Diskette  so  gespeichert
wird, wie es sonst auf dem Bildschirm ausgegeben wird.

A>PUT CONSOLE OUTPUT TO FILE DIR.PRN<CR>
PUTTING CONSOLE OUTPUT TO FILE DIR:PRN

A>DIR<CR>
A>NAME     TEX:FRONT    TEX:FRONT    BAK:ONE     TEX
A>FOUR     TEX:ONE      BAK:LINEDIT  TEX:EXAMP1  TXT
A>TWO      TEX:THREE    BAK:EXAMP2               TXT

A>TYPE DIR.PRN<CR>
A>NAME     TEX:FRONT    TEX:FRONT    BAK:ONE     TEX
A>FOUR     TEX:ONE      TEX:LINEDIT  TEX:EXAMP1  TXT
A>TWO      TEX:THREE    BAK:EXAMP2   TXT

Der GET-Befehl ermöglicht  die Verarbeitung von  Daten, die normalerweise über
die Tastatur eingegeben werden, aus einer Diskettendatei. Wird diese Datei von
CP/M gelesen, muß sie aus normalen CP/M-Befehlszeilen zusammengesetzt sein.

[SEITE 7-25]

Wenn die Diskettendatei  einem Programm als Eingabe  dienen soll, muß sie sich
aus  den vom jeweiligen Programm   lesbaren Befehlen und Daten zusammensetzen.
Die Eingabedatei  darf    sowohl   CP/M-Befehle als  auch     Programmeingaben
beinhalten.

7.6.2 ZUORDNUNG LOGISCHER EINHEITEN

Die minimale Commodore-128-CP/M 3.0-Hardware-Konfiguration besteht aus Rechner
mit Tastatur, Bildschirm  und einem Diskettenlaufwerk.  Sie können auch andere
Einheiten an ihr System anschliessen, z.B.  einen Drucker oder ein Modem.  Die
Zuordnung der logischen und physikalischen Einheiten zu den Einheitennamen ist
aus der Tabelle 7.4 ersichtlich. Sie zeigt gleichzeitig auch die Zuordnung der
physikalischen zu den logischen Einheiten beim Commodore 128 an.

Mit dem DEVICE-Befehl  kann die Zuordnung   geändert werden. AUXIN  und AUXOUT
können beispielsweise einer  seriellen Schnittstelle (6551) zugeordnet werden,
an die ein Modem angeschlossen werden kann.

Tabelle 7.4             CP/M 3.0: Logische Einheiten

Logischer Name  |  Einheiten        |  Physikalische Zuordnung
der Einheit     |  Typ              |  der Einheit
----------------+-------------------+---------------------------------
                |                   |
  CONIN:        |  Konsoleneingabe  |  KEYS (Tastatur)
                |                   |
  CONOUT:       |  Konsolenausgabe  |  80COL oder 40COL (Bildschirm)
                |                   |
  AUXIN:        |  Externe Eingabe  |         -
                |                   |
  AUXOUT:       |  Externe Ausgabe  |         -
                |                   |
  LST:          |  List Ausgabe     |  PTR1 oder PTR2 (Drucker)

[SEITE 7-26]

Bei  CP/M auf dem C128  ist eine physikalische  Einheit 6551 vorhanden.  Diese
Einheit emuliert ein  ACIA-IC  und kann  als serielle Schnittstelle  verwendet
werden.

Durch  entsprechende  Zuordnung mit dem  DEVICE-Befehl  kann diese Einheit als
Modem- oder Druckeranschluß dienen.

7.6.3 SUCHEN VON PROGRAMMDATEIEN

Wenn ein nicht-residenter Befehl eingegeben wird, sucht CP/M auf dem aktuellen
oder angegebenen Laufwerk  nach einer Datei  mit diesem Namen und dem Dateityp
COM. Hierbei  wird  zuerst im aktuellen Benutzerbereich   gesucht  und dann im
Benutzerbereich 0 nach einer gleichnamigen Datei  mit dem SYS-Attribut. Sobald
die entsprechende Programmdatei  gefunden worden ist,  wird der Inhalt  dieser
Datei in  den Speicher (TPA) geladen und  das Programm ausgeführt. Nach Ablauf
des Programms meldet   sich CP/M  wieder   mit der   Bereitschaftsmeldung  und
erwartet die Eingabe eines weiteren Befehls.  Wurde die angegebene Datei nicht
gefunden, wiederholt CP/M die Befehlszeile mit einem  angehängten ? und wartet
ebenfalls auf die nächste Befehlseingabe.

7.6.4 AUSFÜHREN VON MEHRFACHBEFEHLEN

In den bisherigen Beispielen hat CP/M immer nur einen Befehl ausgeführt.  CP/M
kann aber auch eine Befehlsfolge abarbeiten. Die Befehlsfolge kann entweder in
der Befehlszeile eingegeben oder als Diskettendatei mit der Typbezeichnung SUB
auf   einer diskette  abgespeichert  werden.  Die  in einer SUB-Diskettendatei
abgespeicherte Befehlsfolge kann mit dem SUBMIT-Befehl abgearbeitet werden.

7.6.5 UNTERBRECHEN DES PROGRAMMABLAUFS

Das Zeichen  CTRL-C kann zum Unterbrechen des   Programmablaufs oder zum Rück-
setzen oder Diskettenlaufwerke verwendet werden.

Viele Programme lassen sich in ihrem Ablauf mit  der Eingabe von CTRL-C unter-
brechen.  Nur  wenn versucht wird,  einen  Programmablauf während  der  Daten-
ausgabe auf den Bildschirm zu unterbrechen, muß  zuerst die Ausgabe mit CTRL-S
angehalten und erst dann CTRL-C eingegeben werden.

[SEITE 7-27]

7.6.6 HELP-PROGRAMM

Mit dem transienten  Befehl HELP kann man  aus  einer Hilfsdatei Informationen
über die meisten CP/M-Befehle,  deren  Eingaben und  deren Bedienung auf   den
Bildschirm bringen. Um das Programm aufzurufen, genügt es,

HELP<CR>

einzugeben.  So können auch  die  HELP-Taste drücken und anschließend   RETURN
betätigen.

Auf dem Bildschirm erscheint ein Verzeichnis der abrufbaren Informationen:

        Topics available.

        COMMANDS  CNTRCHARS COPYSYS   DATE      DEVICE    DIR
        DUMP      ED        ERASE     FILESPEC  GENCOM    GET
        PATCH     PIP(COPY) PUT       RENAME    RMAC      SAVE
        SET       SETDEF    SHOW      SID       SUBMIT    TYPE
        USER      XREF

Um beispielsweise Informationen zum Programm PIP zu bekommen, geben Sie ein:

HELP>PIP<CR>

[SEITE 7-28]

Folgendes wird angezeigt:

        PIP (COPY)

        Syntax:
                        DESTINATION=SOURCE

        PIP d: {Gn}|filespec{[Gn]} = filespec{[o]},...| d:{[o]}

        Explanation:

        The file copy program PIP copies files, combines files, and
        transfers files between disks, printers, consoles, or other
        devices attached to your computer. The first filespec is the
        destination. The second filespec is the source. Use two or
        more source filespecs separated by commas to combine two or
        more files into one file. [o] is any combination of the avai-
        lable options. The ;Gn? option in the destination filespec
        tells PIP to copy your file to that user number.

        PIP with no command tail displays an * prompt and awaits your
        series of commands, entered and processed one line at a time.
        The source or destination can be any CP/M 3.0 logical device.

Mit  HELP  kann  man schnell benötigte  Informationen  über  die internen  und
transienten CP/M-Befehle  abrufen.    Wenn Sie Informationen   gezielt abrufen
wollen, können  Sie den  Programmnamen in  der Befehlszeile  eingeben, und die
benötigte Information wird sofort angezeigt.

A>HELP PIP<CR>
A>HELP DIRSYS<CR>

Sie können mit   dem HELP-Befehl  auch die CP/M-Befehlsbeschreibungen   durch-
blättern, um ihre Kenntnisse über CP/M aufzufrischen und zu vertiefen.

7.7 ERWEITERUNGEN DES CP/M 3.0 BEIM COMMODORE 128

Beim   CP/M  3.0  auf  dem  Commodore  128  sind    dem Betriebssystem  einige
Erweiterungen zugefügt,   die  sonst in   CP/M  nicht  enthalten  sind.  Diese
Erweiterungen werden hier im folgenden beschrieben.

[SEITE 7-29]

7.7.1 TASTATURERWEITERUNGEN

Jeder  Taste kann  ein anderer Code  bzw.  andere  Bedeutung als  ursprünglich
zugeordnet werden. Hiervon sind jedoch folgende Tasten ausgenommen:

        Linke SHIFT-    Taste
        Rechte SHIFT-   Taste
        COMMODORE-      Taste

        CONTROL-        Taste
        RESTORE-        Taste
        40/80-          Taste
        ASCII/DIN-      Taste

Um die  Belegung  einer Taste zu   definieren, gibt  es  bei CP/M  zusätzliche
Tastaturfunktionen. Um   diese  Funktionen aufzurufen, müssen   mehrere Tasten
gleichzeitig gedrückt werden - zuerst die CTRL- und die rechte SHIFT-Taste und
dann nach Bedarf eine der folgenden Tasten:

Taste                   Bedeutung

CURSOR nach LINKS       Tastenbelegung definieren

CURSOR nach RECHTS      Funktionstasten mit String belegen

ALT                     Tasten-Modus umschalten

7.7.2 TASTENBELEGUNG DEFINIEREN

Der beim Tastendruck   erzeugte  Zeichencode  kann vom   Benutzer  umdefiniert
werden. Jeder  Taste sind,  je   nach dem, welche  Umschalttaste  gleichzeitig
gedrückt wird,  vier  mögliche  Definitionen zugeordnet:  normal, Alpha-Shift,
Shift und Control.

[SEITE 7-30]

Normal-Modus:           Taste wird nur allein gedrückt.

Alpha-Shift-Modus:      Die   Zuordnung  der Tastenbelegung  in diesem
                        Modus wird mit  der  Commodore-Taste (C=) ein-
                        und   ausgeschaltet.      Danach erscheint ein
                        inverses Feld   in  der untersten  Bildschirm-
                        zeile.   Die erste  Taste, die  jetzt gedrückt
                        wird, ist   die   zu definierende Taste.   Die
                        bisherige Zuordnung  wird als eine Hex-Zahl in
                        dem inversen  Feld angezeigt.  Durch   Eingabe
                        einer  anderen Hex-Zahl   kann  der  Taste die
                        dieser Zahl entsprechende Zuordnung zugewiesen
                        werden.  Nachfolgend eine übersicht der mögli-
                        chen Tastenzuordnungen:

  Code         |  Bedeutung
---------------+---------------------------------------------
  00H          |  Null (keine Auswirkung)
  01H bis 7FH  |  Normaler ASCII-Code
  80H bis 9FH  |  Zugewiesene Strings
  A0H bis AFH  |  80-Zeichen-Bildschirm: Zeichenfarbe
  B0H bis BFH  |  80-Zeichen-Bildschirm: Hintergrundfarbe
  C0H bis CFH  |  40-Zeichen-Bildschirm: Zeichenfarbe
  D0H bis DFH  |  40-Zeichen-Bildschirm: Hintergrundfarbe
  E0H bis EFH  |  40-Zeichen-Bildschirm: Rahmenfarbe
  F0H \        |  Disk-Status-Anzeige ein- oder ausschalten
  F1H  \       |  Pause ein- oder ausschalten
  F2H   >      |  Nicht definiert
  F3H  /       |
  F4H /        |  40-Zeichen-Bildschirm: horizontal rollen
  F5H bis FFH  |  Nicht definiert


[SEITE 7-31]

7.7.3 TASTENBELEGUNG MIT STRINGS DEFINIEREN

Diese  Funktion ermöglicht es, einer  einzigen  Tasten nicht  nur ein Zeichen,
sondern  auch  eine   Zeichenfolge    (String) zuzuordnen.   Die   eingegebene
Zeichenfolge wird in  einem langen inversen Feld  in der untersten Bildschirm-
zeile angezeigt.

Jede gedrückte Taste wird mit ihrer Bedeutung in den String übernommen.  Damit
können  auch CTRL- und andere Steuerungszeichen   in den String mit eingegeben
werden.  Um den Cursor innerhalb  der eingegebenen Zeichenfolge zu bewegen und
in der Zeile  zu editieren, kann wie folgt  verfahren werden:  Zuerst sind die
CTRL- und die rechte SHIFT-Taste gedrückt zu halten und dann gleichzeitig eine
der folgenden Tasten zu betätigen:


  Taste            |  Bedeutung
-------------------+--------------------------------
  RETURN           |  String-Definition beenden
  + (obere Reihe)  |  Leerstelle einfügen
  - (obere Reihe)  |  Zeichen unter Cursor löschen
  CRSR links       |  Cursor nach links
  CRSR rechts      |  Cursor nach rechts

7.7.4 ALT-MODUS

Der  ALT-Modus kann entweder ein-  oder ausgeschaltet  werden.  Nach dem CP/M-
Start ist  er  ausgeschaltet.   Dieser Modus  ermöglicht  die  Aussendung  von
8-Bit-Zeichen.

[SEITE 7-32]

7.7.5 DER CP/M-BILDSCHIRM

Der CP/M-Bildschirm emuliert ein ADM31-Terminal.  In der  Tabelle 7.5 sind die
Bildschirmsteuerfunktionen,  die auch den  Funktionen des älteren  ADM 3A ent-
sprechen,    aufgeführt.    Diese  Funktion   sind    eine   Untermenge    der
ADM31-Funktionen.  Die weiteren ADM31-Funktionen sind  in den Tabellen 7.6 und
7.7 aufgeführt.


Tabelle 7.5             CP/M 3.0: Bildschirmsteuerfunktionen
                        (ADM 3A entsprechend)


  Funktion      |  Bedeutung
----------------+--------------------------------------------------
                |
  CTRL-G        |  Klingelzeichen
                |
  CTRL-H        |  Cursor nach links
                |
  CTRL-J        |  Cursor nach unten
                |
  CTRL-K        |  Cursor nach oben
                |
  CTRL-L        |  Cursor nach rechts
                |
  CTRL-M        |  Cursor an den Zeilenanfang setzen.
                |
  CTRL-Z        |  Cursor Home und Bildschirm löschen
                |
  ESC = RC      |  Cursor an die  Position RC  setzen. R bestimmt
                |  die Zeile (Leerzeichen bis Ziffer 8) und C die
                |  Spalte  (Leerzeile  bis Buchstabe  O) in Bezug
                |  auf die linke obere Ecke des Bildschirms.

[SEITE 7-33]

Tabelle 7.6             CPM 3.0: Bildschirmsteuerfunktionen
                        (ADM31 entsprechend)


  Funktion      |  Bedeutung
----------------+--------------------------------------------------
                |
  ESC T oder t  |  Löschen bis Zeilenende
                |
  ESC Y oder y  |  Löschen bis Bildschirmende
                |
  ESC : oder *  |  Cursor Home und Bildschirm löschen
                |  (auch die Statuszeile)
                |
  ESC Q         |  Zeichen einfügen
                |
  ESC W         |  Zeichen löschen
                |
  ESC E         |  Zeile einfügen
                |
  ESC R         |  Zeile löschen
                |
  ESC ESC ESC   |  setzt   die  Bildschirmfarbe  fest.  Die Farb-
  Farbe #       |  nummern  liegen  zwischen 0  und  15 und haben
                |  folgende Bedeutungen:
                |
  20H bis 2FH   |  Zeichenfarbe
                |
  30H bis 3FH   |  Hintergrundfarbe
                |
  40H bis 4FH   |  Rahmenfarbe (nur bei 40 Zeichen)

[SEITE 7-34] *** CP/M-Modus **************************************************

Tabelle 7.7             CP/M 3.0: Bildschirmsteuerfunktionen
                        für einen 80-Zeichen-Bildschirm
                        (ADM31 entsprechend)

  Funktion      |  Bedeutung
----------------+--------------------------------------------------
                |
  ESC >         |  Halbe Intensität
                |
  ESC <         |  Volle Intensität
                |
  ESC G4        |  Inverse Darstellung ein
                |
  ESC G3        |  Unterstreichen   einschalten   (keine   ADM31-
                |  Funktion)
                |
  ESC G2        |  Blinken einschalten
                |
  ESC G1        |  Alternativen  Zeichensatz    anwählen   (Keine
                |  ADM31- Funktion)
                |
  ESC G0        |  Alle ESC-G-Attribute ausschalten


7.8 CP/M 3.0 - Befehlsübersicht


7.8.1 Struktur der CP/M-Befehle


Format:       A> Befehlsschlüsselwort < Argument > < CR >

Zweck:        Eine   CP/M-Befehlszeile   wird   aus   einem   Befehls-
              schlüsselwort  und einem frei  wählbaren Befehlsargument
              zusammengesetzt  und   durch  Drücken  der  RETURN-Taste
              (carriage    return   <CR>,    deutsch:   Wagenrücklauf)
              abgeschlossen   und   damit   zur  Ausführung   an   das
              CP/M-Betriebssystem     abgesendet.      Ein    Befehls-
              schlüsselwort  ist entweder  ein  residenter CP/M-Befehl
              (s.  Tabelle 7.8) oder der Name einer Programmdatei, die
              geladen und  ausgeführt werden soll.   Das frei wählbare
              Befehlsargument  kann  aus  einer Laufwerksangabe, einer
              oder  mehreren Dateiangaben  und  einigen Optionen  oder
              Parametern bestehen.

[SEITE 7-35] *** CP/M-Modus **************************************************

7.8.2 CP/M-BEFEHLSARTEN

CP/M  unterscheidet  zwei  Arten von  Befehlen,  die  sog. residenten  und die
transienten Befehle:

Residente (built-in) Befehle:   Interne Befehle, die im CP/M-Betriebs-
                                sytem implementiert und immer abrufbar
                                sind.

Transiente (externe) Befehle:   Programme, die  von der Diskette nach-
                                geladen werden.

CP/M  kennt sechs  interne  und  über  zwanzig   transiente Befehle, die   zum
Standardlieferumfang von  Digital  Research gehören.  Weitere Dienstprogramme,
die unter CP/M lauffähig sind, können mitverwendet werden. Sie können auch mit
Hilfe der bereitstehenden CP/M-Dienstprogramm eigene Programme erstellen.

.----------------------------------------------------------------------.
| Achtung:                                                             |
|                                                                      |
| Die Befehle LINK, MAC, RMAC, HEXCOM, SID, XREF, die in diesem        |
| Handbuch beschrieben sind, befinden sich nicht auf der               |
| mitgelieferten Utility-Diskette.                                     |
`----------------------------------------------------------------------'


7.8.3 RESIDENTE BEFEHLE

Tabelle 7.8             CP/M 3.0: Residente Befehle


Befehl          |       Bedeutung
----------------+---------------------------------------------------
                |
DIR             |       Zeigt  alle Dateinamen im  Disketteninhalts-
                |       verzeichnis  mit Ausnahme  der mit dem  SYS-
                |       Attribut markierten Dateien an.
                |
DIRSYS          |       Zeigt die Namen  der  Dateien, die  mit SYS-
                |       Attribut gekennzeichnet sind, an.
                |
ERASE           |       Löscht  den angegebenen   Dateiname aus  dem
                |       Disketteninhaltsverzeichnis und kennzeichnet
                |       den belegten Platz wieder als frei.
                |
RENAME          |       Ändert den Dateinamen.
                |
TYPE            |       Zeigt  den  Inhalt von  Textdateien  auf dem
                |       Bildschirm an.
                |
USER            |       Wechselt  zwischen  verschiedenen  Benutzer-
                |       bereichen.

[SEITE 7-36] *** CP/M-Modus **************************************************

7.8.4 TRANSIENTE (EXTERNE) BEFEHLE

Diese Befehle  sind in der nachfolgenden  Tabelle 7.9 aufgelistet. Beim Aufruf
dieser Befehle lädt CP/M die entsprechenden Programmdatei  von der Diskette in
den  Speicher und stellt   alle weiteren  Eingaben  von  der Befehlszeile  dem
aufgerufenen Programm in einem Puffer zur Verfügung.

Auch einige der  internen Befhle existieren in  einer erweiterten Form nur als
transiente Befehle.

Wir finden hier die Befehle DIR, ERASE, RENAME und TYPE.

Wenn versucht wird, diese Befehle  ohne Eingabe einer Dateispezifikation  oder
mit einem erweiterten Argument einzugeben,  ohne die entsprechende Diskette im
aktuellen Laufwerk zu haben, meldet das System

BEFEHL.COM required

als Zeichen, daß zum Ausführen diesen Befehls die entsprechende Diskettendatei
erforderlich ist und auf der Diskette nicht gefunden werden konnte.

Das Wort BEFEHL steht hier für das entsprechende Befehlswort.

Beispiel:               A>RENAME
                        RENAME COM required

                        erscheint, wenn sich im Laufwerk A keine
                        Diskette mit der Datei RENAME.COM befindet.


Tabelle 7.9             CP/M 3.0: Transiente Dienstprogramme


Befehl          |       Bedeutung
----------------+---------------------------------------------------
                |
COPYSYS         |       Erzeugt eine neue bootfähige Diskette.
                |
DATE            |       Setzt oder zeigt Datum und Zeit an.
                |
DEVICE          |       Ordnet logische  CP/M-Einheiten   einer oder
                |       mehreren physikalischen Einheiten zu, ändert
                |       Baudrate  und   Übertragungsprotokoll   oder
                |       setzt die Bildschirmgröße neu.

[SEITE 7-37] *** CP/M-Modus **************************************************

Tabelle 7.9             CP/M 3.0: Transiente Dienstprogramme
                        (Fortsetzung)


Befehl          |       Bedeutung
----------------+---------------------------------------------------
                |
DIR [o]         |       Zeigt  das   Disketteninhaltsverzeichnis und
                |       die Dateiattribute an.
                |
DUMP            |       Zeigt  den Inhalt  einer Datei im ASCII- und
                |       Hexadezimalformat an.
                |
ED              |       Erstellt und modifiziert Textdateien.
                |
ERASE           |       Wird zum  Löschen von Dateien mit dem Platz-
                |       haltern * und ? verwendet.
                |
FORMAT          |       Formatiert Disketten und erzeugt einen Boot-
                |       Sektor.
                |
GET             |       Die  Eingabe erfolgt vorübergehend aus einer
                |       Diskettendatei anstelle von der Tastatur.
                |
HELP            |       Erklärt die CP/M-Befehle und deren Anwendung
                |
HEXCOM          |       Erzeugt aus einer MAC-Ausgabedatei ein lauf-
                |       fähiges Programm.
                |
INITDIR         |       Initialisiert das  Disketteninhaltsverzeich-
                |       nis für die  Aufnahme von  Zeit- und Datums-
                |       markierungen.
                |
LIB             |       Bearbeitet   Bibliotheksdateien  der    Typ-
                |       bezeichnung LIB.
                |
LINK            |       Bindet REL-Programmmodule   zu   lauffähigen
                |       Programmen zusammen.
                |
MAC             |       Übersetzt Assembler-Quelldateien  in Maschi-
                |       nencode.
                |
PATCH           |       Modifiziert CP/M-Systemdateien.
                |
PIP             |       Kopiert und kombiniert Dateien.
                |
PUT             |       Leitet vorübergehend die   Konsolen-    oder
                |       Druckerausgabe in eine Diskettendatei um.

[SEITE 7-38] *** CP/M-Modus **************************************************

Tabelle 7.9             CP/M 3.0: Transiente Dienstprogramme
                        (Fortsetzung)

Befehl          |       Bedeutung
----------------+-------------------------------------------------------
                |
RENAME          |       Ändert den  Namen einer  Diskettendatei, in
                |       Verbindung mit den  Platzhalterzeichen auch
                |       mehrerer Dateien gleichzeitig.
                |
RMAC            |       Übersetzt   Assembler-Quelldateien in   ver-
                |       schiebbare Programmodule.
                |
SAVE            |       Kopiert  Speicherinhalte in eine  Disketten-
                |       datei.
                |
SET             |       Setzt    Dateioptionen,    Disketten-Labels,
                |       Dateiattribute, Datums- und Zeitmarkierungen
                |       und den Paßwort-Schutz.
                |
SETDEF          |       Setzt Systemoptionen,  auch   Laufwerkssuch-
                |       verkettung.
                |
SHOW            |       Zeigt Disketten  und  Laufwerkseigenschaften
                |       an.
                |
SID             |       Testet  Programme  und  ermöglicht das  Auf-
                |       finden von Programmablauffehlern.
                |
SUBMIT          |       Führt automatisch mehrere Befehle aus.
                |
TYPE            |       Gibt den Inhalt einer oder mehrerer (bei der
                |       Verwendung von * und  ?) Textdateien auf dem
                |       Bildschirm  (und Drucker,  wenn   angewählt)
                |       aus.
                |
XREF            |       Erstellt Referenztabellen der Variablen  von
                |       Assemblerprogramen.

[SEITE 7-39] *** CP/M-Modus **************************************************

7.9 CP/M 3.0 - BEFEHLSBESCHREIBUNGEN

In  den   Befehlsbeschreibungen  in  dieser Bedienungsanleitung  wird folgende
Syntax, wie in der Tabelle 7.10 aufgeführt, verwendet:



Tabelle 7.10            CP/M 3.0: Beschreibungssyntax



Zeichen         |       Bedeutung
----------------+-------------------------------------------------------
                |
{ }             |       Geschweifte  Klammern  schließen frei  wähl-
                |       bare Befehlsteile ein.
                |
|               |       Senkrechter    Strich   trennt   alternative
                |       Befehlsteile  in einer  Befehlszeile vonein-
                |       ander.
                |
<CR>            |       steht   für   die   RETURN-Taste   (carriage
                |       return).
                |
^               |       steht für die CONTROL-Taste.
                |
                |
n               |       ersetzt eine Zahl.
                |
s               |       ersetzt eine Zeichenkette.
                |
o               |       ersetzt eine Option oder Liste von Optionen.
                |
[ ]             |       Eckige Klammern schließen eine Optionsliste
                |       ein.
                |
( )             |       Runde  Klammern schließen einen  Bereich von
                |       Optionen innerhalb einer Optionsliste ein.
                |
RW              |       Schreib/Lese-Attribut,  d.h.   kein Schreib-
                |       schutz (Read-Write), das Gegenteil von RO.
                |
RO              |       Schreibschutzattribut  (Read-Only),  das Ge-
                |       genteil von RW.
                |
SYS             |       Systemattribut, das Gegenteil von DIR.
                |
DIR             |       Directoryattribut (Disketteninhaltsverzeich-
                |       nis), das Gegenteil von SYS.


[SEITE 7-40] *** CP/M-Modus **************************************************

Tabelle 7.10            CP/M 3.0: Beschreibungssyntax
                        (Fortsetzung)


Zeichen         |       Bedeutung
----------------+-------------------------------------------------------
                |
...             |       Das vorstehende Element  kann so oft wieder-
                |       holt werden, wie es gewünscht wird.
                |
*               |       Jokerzeichen: Dieser Platzhalter ersetzt den
                |       ganzen oder einen Teil eines Dateinamen bzw.
                |       einer Typbezeichnung.
                |
?               |       Jokerzeichen: Dieser Platzhalter ersetzt ein
                |       beliebiges  einzelnes Zeichen an  der Stelle
                |       in   einem  Dateinamen   bzw.    einer  Typ-
                |       bezeichnung, an der es steht.


[SEITE 7-41] *** CP/M-Modus **************************************************

COPYSYS-Befehl

Format:       COPYSYS

Zweck:        Der COPYSYS-Befehl  kopiert das Betriebssystem  CP/M 3.0
              von einer CP/M-Systemdiskette  auf eine andere Diskette.
              Die  neue   Diskette  muß  im  selben   Format  wie  die
              Originaldiskette sein.

Beispiel:     A>COPYSYS

Dieser Befehl  hat  keine  Wirkung, bei  Aufruf  wird lediglich  eine  Meldung
ausgegeben, daß beim C128 eine Diskette mit diesem Befehl nicht kopiert werden
kann.

Verfahrensweise:

Neue Diskette formatieren (mit dem Programm FORMAT).

Kopieren mit 2 Laufwerken:

PIP B:=A:*.*AVOÜ (Ä und Ü  bei deutschem Zeichensatz anstelle der rechteckigen
Klammern).

Bei Verwendung eines Laufwerkes wird das virtuelle Laufwerk E benutzt.

[SEITE 7-42] *** CP/M-Modus **************************************************

DATE-Befehl


Format:       DATE {CONTINOUS}
              DATE {Zeitangabe}
              DATE SET

Zweck:        Mit dem DATE-Befehl können Datum und Tageszeit angezeigt
              und gesetzt werden.


Beispiele:    A>DATE

              zeigt das aktuelle Datum und die Uhrzeit an.

              A>DATE C

              zeigt Datum und Uhrzeit fortlaufend an.

              A>DATE 05/26/85 11:30:00

              setzt Datum und Uhrzeit.

              A>DATE SET

              setzt Datum und Uhrzeit im Dialog-Modus.


[SEITE 7-43] *** CP/M-Modus **************************************************

DEVICE-Befehl

Format:       DEVICE [NAMES | VALUES | pd | ld]
              DEVICE ld = pd {o} {,pd {o},...}
              DEVICE ld = NULL
              DEVICE pd {o}
              DEVICE CONSOLE [PAGE | COLUMNS = Spalten
                              | LINES = Zeilen]

          pd  bedeutet  phsyikalisches  Gerät  (physical device),  da-
              runter  ist  der aktuelle  Gerätename  einer vom  System
              selektierten Geräteeinheit zu verstehen.

          ld  bedeutet logisches Gerät  (logical device), darunter ist
              ein   symbolischer  Gerätename   für  eine   Gruppe  von
              Einheiten, die alle vom System bedient werden können, zu
              verstehen.

Zweck:        Der  DEVICE-Befehl  zeigt  die  aktuelle  Zuweisung  der
              logischen Geräte und  der physikalischen Gerätenamen an.
              Außerdem  können  mit DEVICE  die  logischen Geräte  den
              Peripheriegeräten des Rechners zugeordnet werden.

              DEVICE  legt  auch  das  Übertragungsprotokoll  und  die
              Geschwindigkeit  fest  und   zeigt  die  aktuelle  Bild-
              schirmgröße an oder legt sie fest.

[SEITE 7-44] *** CP/M-Modus **************************************************

Optionen:

Option          |       Funktion
----------------+-------------------------------------------------------
                |
XON             |       legt    ein   XON/XOFF-Übertragungsprotokoll
                |       fest.
                |
NOXON           |       bedeutet,  daß kein  XON/XOFF-Protokoll ver-
                |       wendet wird.   Der Rechner sendet unabhängig
                |       davon, ob das  Empfangsgerät bereit ist oder
                |       nicht, Daten an das Gerät.
                |
Baudrate        |       Die   Baudrate   legt  die   Übertragungsge-
                |       schwindigkeit  des Gerätes  fest.   Das CP/M
                |       kann folgende Baudraten verwenden:
                |
                |         50      75     110     134
                |        150     300     600    1200
                |       1800    2400    3600    4800
                |       7200    9600   19200
                |
Beispiele       |       A>DEVICE<CR>

.-----------------------------------------------------------------------.
| Physical Devices:                                                     |
| I=Input,O=Output,S=Serial,X=Xon-Xoff                                  |
| KEYS    NONE    I       80COL   NONE    0       40COL   NONE    0     |
| PRT1    NONE    O       PRT2    NONE    0       6551    19200   IOSX  |
|                                                                       |
| Current Assignments:                                                  |
| CONIN:  =KEYS                                                         |
| CONOUT: =80COL                                                        |
| AUXIN:  =Null Device                                                  |
| AUXOUT: =Null Device                                                  |
| LST:    =PRT1                                                         |
|                                                                       |
| Enter new assigment or hit RETURN                                     |
`-----------------------------------------------------------------------'

                        Diese   Ausgabe   zeigt  die   existierenden
                        physikalischen  Geräte   und  die  aktuellen
                        Zuweisungen der logischen Geräte des Systems
                        an. Nach der Anforderung können Sie entweder
                        eine neue Zuweisung eingeben oder mit RETURN
                        die   angezeigten   bisherigen   Zuordnungen
                        übernehmen.

[SEITE 7-45] *** CP/M-Modus **************************************************

                        A>DEVICE NAMES<CR>


Physical Devices:
I=Input,O=Output,S=Serial,X=Xon-Xoff
KEYS    NONE    I       80COL   NONE    O       40COL   NONE    O
PRT1    NONE    O       PRT2    NONE    O       6551    19200   IOSX

                        listet  die physikalischen Geräte  mit einer
                        Kurzfassung der Geräteeigenschaften auf.

                        A>DEVICE VALUES<CR>

                        Current Assignments:
                        CONIN:  =KEYS
                        CONOUT: =80COL
                        AUXIN:  =Null Device
                        AUXOUT: =Null Device
                        LST:    =PRT1

                        zeigt   die    aktuellen   Zuweisungen   der
                        logischen Geräte an.

                        A>DEVICE CON<CR>
                        CONIN:  =KEYS
                        CONOUT: =80COL

                        zeigt die Zuordnungen der Konsole an.

                        A>DEVICE CONOUT:=80COL, PRT1<CR>

                        weist den  Systemkonsolenausgang CONOUT: dem
                        80-Zeichen-Bildschirm  und dem  Drucker PRT1
                        zu.

                        A>DEVICE AUXIN:=6551[XON,300]<CR>

                        weist dem  logischen Hilfseingang AUXIN: das
                        physikalische Gerät  6551 (serielle Schnitt-
                        stelle)   zu,  das   ein  XON/XOFF-Protokoll
                        benutzt, und  setzt die übertragungsrate der
                        Schnittstelle auf 300 Baud.

                        A>DEVICE LST:=NULL<CR>

                        unterbricht  die LIST-Ausgabe  des logischen
                        Geräts LST:.

[SEITE 7-46] *** CP/M-Modus **************************************************

                        A>DEVICE 6551[NOXON,3001<CR>

                        schaltet  das  XON/-XOFF-Protokoll  für  das
                        physikalische Gerät  6551 (serielle Schnitt-
                        stelle)  aus und setzt  die übertragungsrate
                        auf 300 Baud.

                        A>DEVICE CON:[PAGE]<CR>

                        Console width set to 25 columns
                        Console page set to 24 lines

                        zeigt   für   die   Konsole   die   aktuelle
                        Seitenbreite in  Spalten und die Seitenlänge
                        in Zeilen an.

                        A>DEVICE CON:[COLUMNS=40,LINES=16]<CR>

                        setzt die Bildschirmgröße auf 40 Spalten und
                        16 Zeilen.


[SEITE 7-47] *** CP/M-Modus **************************************************

DIR-Befehl


Der DIR-Befehl zeigt das  Disketteninhaltsverzeichnis (directory) an, d.h. die
Dateinamen der bezeichneten Diskette und ggf. deren Eigenschaften.

Der DIR-Befehl hat drei verschiedene Ausführungsformen.

        DIR
        DIRS
        DIR mit Optionen

DIR und DIRS  sind residente, d.h. ins Betriebssystem  integrierte (built in),
Dienstprogramme.   DIR  mit  Optionen  ist ein  transientes,  d.h.   externes,
Dienstprogramm, das  erst von  einer Diskette in  den Speicher  geladen werden
muß.


[SEITE 7-48] *** CP/M-Modus **************************************************

Residenter DIR-Befehl


Format:       DIR {d:}
              DIR {dateispez}

              DIRS {d:}
              DIRS {dateispez}


Zweck:        Die residenten  Befehle DIR  und DIRS zeigen  die Datei-
              namen an, die im Disketteninhaltsverzeichnis eingetragen
              sind.   DIR  gibt   nur  die  Dateinamen  des  aktuellen
              Benutzerbereichs  aus,  die  das DIR-Attribut  besitzen,
              d.h.   Dateien mit dem  Systemattribut SYS  werden nicht
              angezeigt.  DIR akzeptiert die  Jokerzeichen * und ?  in
              einem Dateinamen.


Beispiele:    A>DIR<CR>

              zeigt alle Dateien des  Benutzerbereichs 0 im Laufwerk A
              an, die das DIR-Attribut besitzen.

              A>DIR B:<CR>

              zeigt alle Dateien des  Benutzerbereichs 0 im Laufwerk B
              an.

              2A>DIR C:ZIPPY.DAT<CR>

              zeigt  den  Dateinamen ZIPPY.DAT  an,  falls sich  diese
              Datei im Benutzerbereich 2  auf der Diskette im Laufwerk
              C befindet.

              4A>DIR *.BAS<CR>

              zeigt  alle DIR-Dateien des  Dateityps BAS  im Benutzer-
              bereich 4 von Laufwrek A an.

              3B>DIR X*.C?D<CR>

              zeigt  alle  Dateien  des  Benutzerbereichs  3  auf  der
              Diskette  im Laufwerk  B  an, deren  Dateinamen mit  dem
              Buchstaben  X beginnen  und  deren dreistelliger  Datei-
              typname als  erstes Zeichen C und als  letztes Zeichen D
              enthält.

[SEITE 7-49]^ *** CP/M-Modus *************************************************

              A>DIRS<CR>

              zeigt  alle  Dateien   mit  dem  Systemattribut  SYS  im
              Benutzerbereich 0 auf der Diskette im Laufwerk A an.

              A>DIRS *.COM<CR>

              zeigt alle SYS-Dateien des  Typs COM auf der Diskette im
              Laufwerk   A  im   Benutzerbereich  0   an.    Auf  eine
              Befehlsdatei   COM  des   Benutzerbereichs  0   mit  dem
              Systemattribut  SYS   kann  im  Suchketten-Modus  (siehe
              SETDEF) aus jedem Benutzerbereich zugegriffen werden.


[SEITE 7-50] *** CP/M-Modus **************************************************

Externer DIR-Befehl mit Optionen


Format:       DIR {d:} [o]
              DIR {dateispez} {dateispez}...[o]


Zweck:        Der externe DIR-Befehl  mit Optionen ist eine erweiterte
              Version der residenten DIR-Befehls und zeigt die Dateien
              in  besonderer Form an.  DIR kann  eine Datei  von einem
              oder   allen  Laufwerken  und   aus  einem   oder  allen
              Benutzerbereichen  suchen.  Die  möglichen  DIR-Optionen
              sind in Tabelle 7.11 aufgeführt.

Tabelle 7.11            CP/M 3.0: DIR-Optionen


Option          |       Funktion
------------------------------------------------------------------------
                |
ATT             |       zeigt die Dateiattribute an.
                |
DATE            |       zeigt die Datums- und Zeiteintraege der Dateien
                |       an.
                |
DIR             |       zeigt nur die Dateien mit DIR-Attribut an.
                |
DRIVE = ALL     |       zeigt die Dateien aller angeschlossenen
                |       Laufwerke an.
                |
DRIVE=          |       zeigt die Dateien der bezeichneten Laufwerke an.
(A,B,C,...,P)   |
                |
DRIVE=d         |       zeigt die Dateien des Laufwerks d an.
                |
EXCLUDE         |       zeigt die Dateien an, die nicht in der
                |       Befehlszeile angegeben wurden.
                |
FF              |       sendet eine Seitenvorschubszeichen (form feed)
                |       an den Drucker, wenn der Drucker mit CTRL-P
                |       aktiviert wurde.
                |

[SEITE 7-51] *** CP/M-Modus **************************************************

Tabelle 7.11            CP/M 3.0: DIR-Optionen
                        (Fortsetzung)


Option          |       Funktion
------------------------------------------------------------------------
                |
FULL            |       zeigt den Namen, die Größe, die Anzahl der
                |       128-Byte-Records und die Attribute der Dateien
                |       an. Wenn eine Direcotry-Marke vorhanden ist,
                |       zeigt DIR den Paßwort-Schutzmodus und die
                |       Zeiteinträge an. Wenn keine Directory-Marke
                |       vorhanden ist, zeigt DIR zwei Dateieinträge
                |       pro Zeile an, indem die Spalten für das Paßwort
                |       und die Zeiteinträge ausgelassen werden. Die
                |       Anzeige wird alphabetisch sortiert. In der SET-
                |       Anweisung findet man eine Beschreibung über die
                |       Dateiattribute, die Directory-Marken, die
                |       Paßworte und den Schutz-Modus.
                |
LENGTH=n        |       vereinbart eine Druckerausgabe von n Zeilen pro
                |       Seite. Die Kopfzeile der Directory wird auf
                |       jeder Seite wiederholt und in n nicht
                |       mitgezählt. n ist eine Zahl zwischen 5 und
                |       65535.
                |
MESSAGE         |       zeigt die Laufwerksnamen und die
                |       Benutzerbereiche an, die DIR gerade durchsucht.
                |
NOPAGE          |       schaltet die seitenweise Ausgabe aus.
                |
NOSORT          |       zeigt die Dateien in der Reihenfolge an, in der
                |       sie auf der Diskette stehen.
                |
RO              |       zeigt nur die Dateien mit Schreibschutzattribut
                |       (Read-Only) an.
                |
RW              |       zeigt nur die Dateien ohne Schreibschutzattribut
                |       (Read-Write) an.
                |
SIZE            |       zeigt die Namen und die Größe der Dateien in
                |       KBytes (1024 Bytes) an.
                |
SYS             |       zeigt nur die Dateien mit SYS-Attribut an.
                |
USER=ALL        |       zeigt alle Dateien aller Benutzerbereiche im
                |       aktuellen oder bezeichneten Laufwerk an.


[SEITE 7-52] *** CP/M-Modus **************************************************

Tabelle 7.11            CP/M 3.0: DIR-Optionen
                        (Fortsetzung)

Option          |       Funktion
------------------------------------------------------------------------
                |
USER=n          |       zeigt nur die Dateien des Benutzerbereichs n an.
                |
USER=           |       zeigt die Dateien der bezeichneten
(0,1,2,...,15)  |       Benutzerbereiche an. Es können auch mehrere
                |       Bereiche angegeben werden.


Beispiele:              A>DIR C: [FULL]<CR>

                        zeigt alle Eigenschaften aller Dateien des
                        Benutzerbereichs 0 im Laufwerk C an.


                        A>DIR C: [DATE]<CR>

                        gibt die Dateien im Laufwerk C mit ihren
                        Zeiteinträgen aus.


                        A>DIR D: [RW,SYS]<CR>

                        zeigt alle Dateien des Benutzerbereichs 0 im
                        Laufwerk D ohne Schreibschutz, aber mit dem
                        System-Attribut SYS an.


                        3A>DIR [USER=ALL,DRIVE=ALL]<CR>


                        zeigt alle Dateien aller Benutzerbereiche (0-15)
                        von allen Laufwerken an.


                        6B>DIR [EXCLUDE] *.DAT<CR>


                        gibt alle Dateien des Benutzerbereichs 6 von
                        Laufwerk B aus, die nicht vom Dateityp DAT sind.


                        3B>DIR [SIZE] *.PLI *.COM *.ASM<CR>


                        zeigt alle Dateien des Benutzerbereichs 3 von
                        Laufwerk B mit den Dateitypen PLI, COM und ASM
                        an.

[SEITE 7-53] *** CP/M-Modus **************************************************

                        A>DIR [DRIVE=ALL,USER=ALL] TESTFILE.BOB<CR>

                        zeigt dann den Dateinamen TESTFILE.BOB an, wenn
                        er in einem Laufwerk und in einem Benutzerbereich
                        zu finden ist.


                        A>DIR [SIZE,RW] D:<CR>


                        gibt alle Dateien ohne Schreibschutz im Laufwerk
                        D mit ihren Dateigrößen aus. Hierbei hat D:
                        dieselbe Wirkung wie D:*.* .


[SEITE 7-54] *** CP/M-Modus **************************************************

DUMP-Befehl


Format:       DUMP dateispez

Zweck:        Der DUMP-Befehl  zeigt den  Inhalt einer Datei  im Hexa-
              dezimal- und ASCII-Format an.

Beispiel:     A>DUMP DUMP.COM
              CP/M 3 DUMP-Version 3.0
              0000: C3 DB 03 00 00 00 00 00 ........
              0008: 00 00 00 00 00 00 00 00 ........
              0010: 44 55 4D 50 20 56 45 52 DUMP VER
              0018: 53 49 4F 4E 20 33 2E 30 SION 3.0

[SEITE 7-55] *** CP/M-Modus **************************************************

ED-Befehl

Format:       ED quell-dateispez {ziel-dateispez}

Zweck:        ED   ist   ein   zeilenorientierter  Texteditor.    Alle
              Editierfunktionen   werden  in   einem  Puffer   im  RAM
              durchgeführt. Der  Text muß aus einer  Quelldatei in den
              Puffer geladen  und nach dem Beenden  der Bearbeitung in
              die  Quelldatei  oder  eine Zieldatei  zurückgeschrieben
              werden.  ED löscht die Originalquelldatei nicht, sondern
              beläßt sie als sogenannte Sicherungs- bzw.  Backup-Datei
              mit dem  Dateitpy BAK auf  der Diskette.  Um  eine Datei
              umzuadressieren    bzw.   umzubenennnen,    müssen   das
              Ziellaufwerk d  und die Zieldatei  angegeben werden.  In
              Tabelle 7.12 sind die ED-Befehle aufgeführt.


Tabelle 7.12            CP/M 3.0: ED-Befehle


Befehl          |       Funktion
------------------------------------------------------------------------
                |
nA              |       Lädt n Zeilen aus der Quelldatei in den
                |       ED-Puffer
                |
OA              |       Lädt soviele Zeilen, bis die Hälfte des Puffers
                |       gefüllt ist.
                |
#A              |       Lädt soviele Zeilen, bis der Puffer gefüllt oder
                |       das Dateiende erreicht ist.
                |
B,-B            |       Positioniert den Cursor CP (Zeicherzeiger -
                |       character pointer) an den Anfang (B) oder das
                |       Ende (-B) des Puffers.
                |
nC,-nC          |       Positioniert den Cursor CP um n Zeichen vorwärts
                |       (C) oder n Zeichen rückwärts (-C).
                |
nD,-nD          |       Löscht n Zeichen vor (-D) oder hinter (D) der
                |       Cursorposition CP.
                |
E               |       Beendet die Editierung, speichert die neue Datei
                |       auf der Diskette ab und springt zurück in CP/M.


[SEITE 7-56] *** CP/M-Modus **************************************************

Tabelle 7.12            CP/M 3.0: ED-Befehle
                        (Fortsetzung)


Befehl          |       Funktion
------------------------------------------------------------------------
                |
Fs{^Z}          |      Sucht die angegebene Zeichenkette (String) s im
                |       gesamtem Textpuffer.
                |
H               |       Beendet die Editierung, speichert die neue
                |       Datei, ruft die neue Datei als neue Quelldatei
                |       auf und setzt mit dieser die Editierung fort.
                |
I<CR>           |       Aufrufen des Einfügemodus für eine neue
                |       Textzeile nach der Cursorposition CP.
                |
ls{^Z}          |      Fügt die angegebene Zeichenkette (string) s an
                |       der aktuellen Cursorposition beginnend ein und
                |       positioniert den Cursor CP hinter das letzte
                |       Zeichen der Zeichenkette s.
                |
Js1^Zs2^Zs3{^Z} |
                |       Nebeneinanderstellen von Zeichenketten, indem
                |       die erste Zeichenkette gesucht wird, die zweite
                |       Zeichekette an die erste angefügt wird und alle
                |       Zeichen bis zur dritten Zeichenkette gelöscht
                |       werden.
                |
nK, -nK         |       Löscht die folgenden (nK) bzw. die vorstehenden
                |       (-nK) n Zeilen von der Cursorposition aus.
                |
nL, -nL, 0L     |       Positioniert den Cursor um n Zeilen vorwärts
                |       (nL) oder rückwärts (-nL). Mit 0L wird der
                |       Cursor an den Beginn der aktuellen Zeile
                |       gesetzt.
                |
nMcommand       |       Führt die Befehle 'command' n-mal aus.
                |
n,-n            |       Positioniert den Cursor um n Zeilen vorwärts (n)
                |       oder rückwärts (-n) und zeigt diese Zeile an.
                |
n:              |       Positioniert den Cursor an den Beginn der Zeile
                |       n.
                |
:ncommand       |       Führt den Befehl 'command' bis zur Zeile n aus.



[SEITE 7-57] *** CP/M-Modus **************************************************

Tabelle 7.12            CP/M 3.0: ED-Befehle
                        (Fortsetzung)

Befehl          |       Funktion
------------------------------------------------------------------------
                |
Ns{^Z}          |      Sucht die angegebene Zeichenfolge (string) s im
                |       Textpuffer.
                |
O               |       Rücksprung in die Originaldatei.
                |
nP, -nP         |       Positioniert den Cursor 23 Zeilen
                |       (Bildschirmseitenlänge) weiter und listet diese
                |       Zeilen auf dem Bildschirm auf.
                |
Q               |       Verlassen der neuen Datei ohne Speicherung und
                |       Rücksprung ins CP/M-Betriebssystem.
                |
R{^Z}           |       Einlesen der Datei X$$$$$$$.LIB in den
                |       Textpuffer.
                |
Rdateispez{^Z}  |       Einlesen der Datei 'dateispez' in den
                |       Textpuffer.
                |
Ss1^Zs2{^Z}     |       Ersetzen der Zeichekette s1 durch s2
                |
nT, -nT, 0T     |       Listet n Zeilen auf.
                |
U, -U           |       Wandelt alle folgenden Kleinbuchstaben nach der
                |       Eingabe von U in Großbuchstaben um. Diese
                |       Umwandlung wird mit -U beendet.
                |
V, -V           |       Schaltet die Anzeige von Zeilennummern im
                |       Textpuffer mit der Eingabe von V ein. Diese
                |       Anzeige wird mit -V ausgeschaltet.
                |
0V              |       Zeigt die verfügbare und die gesamte Größe des
                |       Textpuffers in Bytes (dezimal) an.
                |
nW              |       Schreibt n Zeilen in die entsprechende
                |       übergangsdatei mit der Typenkennung $$$.
                |
0W              |       Schreibt soviele Zeilen in die übergangsdatei,
                |       bis der Puffer halb voll ist.

[SEITE 7-58] *** CP/M-Modus **************************************************

Tabelle 7.12            CP/M 3.0: ED-Befehle
                        (Fortsetzung)


Befehl          |       Funktion
------------------------------------------------------------------------
                |
nX{^Z}          |       Kopiert die folgenden n Zeilen in die Datei
                |       X$$$$$$$.LIB.
                |
nXdateispez{^Z} |       Kopiert die folgenden n Zeilen in die Datei
                |       {dateispez}. Wenn der X-Befehl schon vorher
                |       verwendet wurde, werden diese Zeilen daran
                |       angefügt.
                |
0X{^Z}          |       Löscht die Datei X$$$$$$$.LIB .
                |
0Xdateispez{^Z} |       Löscht die Datei 'dateispez'.
                |
nZ              |       Unterbricht die laufende ED-Operation um n
                |       Sekunden.


* Anmerkung:            Der Cursor CP (Zeichenzeiger, Cursorposition)
                        zeigt auf das aktuelle Zeichen im Textpuffer.
                        Mit {^Z}  trennt  man verschiedene ED-Befehle
                        in derselben Zeile voneinander.

Beispiele:              A>ED TEST.DAT
                        A>ED TEST.DAT B:
                        >ED TEST.DAT TEST2.DAT
                        A>ED TEST.DAT B:TEST2.DAT

[SEITE 7-59] *** CP/M-Modus **************************************************

ERASE-Befehl


Format:       ERASE {dateispez} {[CONFIRM]}

Zweck:        Der  ERASE-Befehl löscht eine  oder mehrere  Dateien aus
              dem    Disketteninhaltsverzeichnis   (directory).    Die
              Platzhalter  *  und  ?   können verwendet  werden.   Das
              Disketteninhaltsverzeichnis und der Speicherplatz werden
              auf diese Weise für  eine spätere Benutzung durch andere
              Datien freigegeben.

              ERASE kann mit ERA abgekürzt werden.

Option:       [CONFIRM]

              Diese Option  bewirkt, daß  vor dem Löschen  einer Datei
              das  CP/M-System   eine  Bestätigung  bzw.   Quittierung
              verlangt. CONFIRM kann mit C abgekürzt werden.

Beispiele:    A>ERASE X.PAS<CR>

              löscht die Datei X.PAS von der Diskette im Laufwerk A.

              A>ERA *.PRN [CONFIRM]<CR>
              Confirm (Y/N)?Y

              Alle  Dateien des Typs  PRN werden  von der  Diskette im
              Laufwerk A gelöscht.

              A>ERA A:MY*.* [CONFIRM]<CR>

              Vor dem Löschen der Dateien auf der Diskette im Laufwerk
              A,  deren   Name  mit   MY  anfangen,  wird   mit  einem
              Fragezeichen eine Quittierung angefordert.

[SEITE 7-60] *** CP/M-Modus **************************************************

GENCOM-Befehl


Format:       GENCOM {COM-dateispez} {RSX-dateispez}...
                     {[LOADER | NULL | SCB = (o,n)]}

Zweck:        Der GENCOM-Befehl  erzeugt eine spezielle  COM-Datei mit
              angehängten RSX-Dateien. Der GENCOM-Befehl kann auch aus
              einer  mit  GENCOM  erzeugten wieder  die  ursprüngliche
              COM-Datei ohne den am  Anfang stehenden 'Header' und den
              RSX-Dateien erzeugen. GENCOM kann auch Header-Records an
              eine COM-Datei anfügen.



Tabelle 7.13 CP/M 3.0: GENCOM-Optionen



Option          |       Funktion
------------------------------------------------------------------------
                |
LOADER          |       fügt eine 256-Byte Header-Record hinzu und setzt
                |       ein Loader-Flag
                |
NULL            |       zeigt an, daß nur RSX-Dateien angegeben werden,
                |       GENCOM erzeugt eine leere COM-Datei für die RSX-
                |       Dateien. Als Name der erzeugten COM-Datei wird
                |       der Dateiname der ersten RSX-Dateibezeichnung
                |       verwendet.
                |
                |
SCB = (o,)      |       setzt den System-Control-Block des Programms aus
                |       den angegebenen Hexadezimalzahlen (o,n)



Beispiele:              A>GENCOM MYPROG PROG1 PROG2


                        erzeugt eine neue COM-Datei MYPROG.COM mit den
                        angefügten RSX-Dateien PROG1 und PROG2.


                        A>GENCOM PROG1 PROG2[NULL]


                        erzeugt eine COM-Datei PROG1.COM mit den
                        RSX-Dateien PROG1 und PROG2.


[SEITE 7-61] *** CP/M-Modus **************************************************


                        A>GENCOM MYPROG


                        GENCOM lädt MYPROG, entfernt den Header, löscht
                        alle angefügten RSX-Dateien und lädt es wieder
                        im originalen COM-Format zurück.


                        A>GENCOM MYPROG PROG1 PROG2


                        GENCOM untersucht die schon mit GENCOM erzeugten
Datei MYPROG.COM danach, ob PROG1,RSX und PROG2.RSX schon als
RSX-Dateien angefügt wurden. Wenn eine von beiden schon angefügt wurde,
ersetzt GENCOM diese durch die neue RSX-Datei, andernfalls fügt GENCOM
die bezeichnete RSX-Datei an die COM-Datei an.



[SEITE 7-62] *** CP/M-Modus **************************************************


GET-Befehl

Format:       GET {CONSOLE INPUT FROM} FROM} FILE dateispez
              ^[ECHO ^ NO ECHO ^ SYSTEM]}

              GET {CONSOLE INPUT FROM} CONSOLE

Zweck:        Der GET-Befehl steuert  das Betriebssystem in der Weise,
              daß  die Konsoleneingabe  für  den nächsten  Sytembefehl
              oder  für ein  über die  Konsole  eingegebenes Benutzer-
              programm von einer Datei erfolgen kann.

              Die Konsoleneingabe  wird von einer  Datei genommen, bis
              das Progamm endet. Wenn  die Datei abgearbeitet ist, ehe
              die Programmeingabe beendet wurde, erwartet das Programm
              eine  nachfolgende Eingabe über  die Konsole.   Wenn das
              Programm endet,  ehe alle Eingaben  abegearbetet wurden,
              springt das Sytem zur Konsoleneingabe zurück.

              Mit der SYSTEM-Option geht  das Sytem für eine Konsolen-
              eingabe  sofort auf  die bezeichnete  Datei.   Das Sytem
              verlangt   eine  Konsoleneingabe,  wenn   das  Dateiende
              erreicht wurde.   Mit dem Befehl GET  CONSOLE INPUT FROM
              CONSOLE als Befehlszeile in der Eingabedatei springt das
              System für eine Konsoleneingabe zurück zur Konsole.

[SEITE 7-63] *** CP/M-Modus **************************************************

Tabelle 7.14            CP/M 3.0: GET-Option



Option          |       Bedeutung
------------------------------------------------------------------------
                |
ECHO            |       bedeutet, daß eine Eingabe auf der Konsole
                |       angezeigt wird. Dies ist eine voreingestellte
                |       Option.
                |
NO ECHO         |       bedeutet, daß die Dateieingabe nicht auf der
                |       Konsole angezeigt wird. Die Programmausgabe und
                |       die Sytemberetischaftsmeldungen werden nicht von
                |       dieser Option berührt und deshalb auf der
                |       Konsole angezeigt.
                |
                |       SYSTEM bedeutet, daß alle Systemeingaben sofort
                |       aus der in der Befehlszeile angegebenen
                |       Diskettendatei gelesen werden. GET nimmt die
                |       System- und Programmeingabe aus der Datei, bis
                |       die Datei abgearbeitet wurde oder bis ein
                |       GET-Konsolenbefehl aus der Datei gelesen wird.


Beispiele:              A>GET FILE XINPUT
                        A>MYPROG


                        übermittelt dem System, das GET-Dienstprogramm
                        zu aktivieren. Da SYSTEM nicht angegeben wurde,
                        liest das System die nächste Eingabezeile von
                        der Konsole und führt MYPROG aus. Wenn das
                        Programm MYPROG eine Konsoleneingabe fordert,
                        wird diese von der Datei XINPUT genommen. Wenn
                        MYPROG endet, springt das System für eine
                        Konsoleneingabe zurück zur Konsole.


                        A>GET FILE ABCD [SYSTEM]


                        steuert das System so, daß eine nachfolgende
                        Konsoleneingabe aus der Datei ABCD gelesen wird,
                        weil die SYSTEM-Option im Befehl enthalten ist.
                        Das System springt für eine Konsoleneingabe
                        zurück zur Konsole, wenn das Ende der Datei ABCD
                        erreicht wird.  Alternativ kann  ABCD das System
                        zurück zur Konsole steuern, wenn ABCD einen Befehl
                        GET CONSOLE erhält.



[SEITE 7-64] *** CP/M-Modus **************************************************


                        A>GET CONSOLE


                        teilt dem System mit, eine Konsoleneingabe von
                        der Konsole zu holen. Dieser Befehl kann in einer
                        Datei benutzt werden, die vorher in einem Befehl
                        GET FILE benannt wurde, und die bereits vom System
                        für eine Konsoleneingabe gelesen wird. Der Befehl
                        wird benutzt, um die Konsoleneingabe zurück zur
                        Konsole zu legen, ehe das Dateiende erreicht wird.



[SEITE 7-65] *** CP/M-Modus **************************************************


HELP-Befehl


FORMAT:       HELP {topic}{subtopic1...subtopic8}{[NOPAGE | LIST]}

Zweck:        Das HELP-Programm zeigt  eine Liste von CP/M-Befehlen an
              und liefert auf Abruf Informationen darüber.

              HELP topic informiert über diesen Begriff.

              HELP topic subtopic informiert über diesen Unterbegriff.

              Ein oder zwei Buchstaben genügen zur Identifizierung der
              Begriffe. Wird  nur HELP eingegeben,  erscheint der Text
              HELP>  mit  einer   Liste  von  Unterbegriffen  auf  dem
              Bildschirm. Die Eingabe eines

              - Fragezeichens ? gibt die Liste der Hauptbegriffe aus.

              - Punktes  und Unterbegriffnamens gibt  den Unterbegriff
                aus.

              - Punktes wiederholt die letzte Ausgabe.


              Das Drücken der RETURN-Taste bewirkt einen Rücksprung in
              CP/M-Betriebssytem.

              Die  Option [NOPAGE] schaltet  die seintenweise  (mit 24
              Zeilen) Ausgabe aus.

              Das Drücken  einer beliebigen Taste  beendet die Anzeige
              und zeigt wieder den Text HELP> an.

Beispiele:    A>HELP
              A>HELP DATE
              A>HELP DIR OPTIONS
              HELP>.OPTIONS
              HELP>SET
              HELP>SET PASSWORD
              HELP>.PASSWORD
              HELP>.
              HELP><CR>


[SEITE 7-66] *** CP/M-Modus **************************************************


Verfügbare Begriffe und Bezeichnungen:


COMMANDS        CNTRLCHARS      COPYSYS DATE     DEVICE         DIR
DUMP            ED              ERASE   FILESPEC GENCOM         GET
HELP            HEXCOM          INITDIR LIB      LINK           MAC
PATCH           PIP (COPY)      PUT     RENAME   RMAC           SAVE
SET             SETDEF          SHOW    SID      SUBMIT         TYPE
USER            XREF



[SEITE 7-67] *** CP/M-Modus **************************************************


HEXCOM-Befehl


Format:       HEXCOM filename


Zweck:        Der  HEXCOM-Befehl  erzeugt  aus  einer  HEX-Datei  eine
              direkt  lauffähige Befehlsdatei  vom Dateityp  COM.  Der
              Name des transformierten  Programms ist derselbe wie der
              eingegebenen  Datei,   die  Typbezeichnung  jedoch  COM.
              HEXCOM verlangt immer eine Eingabe mit dem Dateityp HEX.


Beispiel:     A>HEXCOM B:PROGRAM

              erzeugt  eine Befehlsdatei  PROGRAM.COM  aus der  einge-
              gebenen HEX-Datei PROGRAM.HEX.

[SEITE 7-68] *** CP/M-Modus **************************************************

INITDIR-Befehl

Format:       INITDIR {d:}

Zweck:        Der   INITDIR-Befehl   bereitet  ein   Disketteninhalts-
              verzeichnis für Datums-  und Zeiteinträge zu den Dateien
              auf  der   Diskette  vor.   Ist   die  Diskette  bereits
              initialisiert, so  kann man mit  INITDIR sämtliche Zeit-
              und  Datumseinträge  löschen   und  den  Bereich  wieder
              freigeben.



Beispiele:    A>INITDIR
              ERROR: Unrecognized drive.
              Drive: x

              Enter Drive: a

              INITDIR WILL ACTIVATE TIME STAMPS FOR SPECIFIED
              DRIVE
              Do you want to re-format the directory on drive:
              A>(Y/N)?Y

              INITDIR   aktiviert  den  Zeit-Datums-Bereich   auf  der
              Diskette im bezeichneten Laufwerks.


[SEITE 7-69] *** CP/M-Modus **************************************************


LIB-Befehl

Format:       LIB dateispez {[I : M : P : D]}

              LIB dateispez {[I : M : P]} = dateispez
              {modifier} {,dateispez {modifier}...}

Zweck:        Man  benutzt  das  LIB-Dienstprogramm,  um  Bibliotheks-
              dateien  zu  erzeugen  und  um  Objektmodule  bei  einer
              vorhandenen  Bibliotheksdatei  anzufügen,  zu  ersetzen,
              auszulesen,  zu  löschen  oder  auch Kenntnis  über  den
              Inhalt einer Bibliotheksdatei zu erhalten.

              Mit LIB  erzeugt und pflegt  man Bibliotheksdateien, die
              Objektmodule   im  Microsoft-REL-Dateiformat  enthalten.
              Diese   Module    werden   vom   Digital-Research-Makro-
              Assembler RMAC oder von einigen Compilern erzeugt.

              Man kann den  LINK-Befehl verwenden, um Objektmodule aus
              einer  Bibliotheksdatei  mit  anderen  Objektmodulen  zu
              verbinden.     LINK    wählt    selbsttätig   aus    der
              Bibliotheksdatei  nur jene  Module aus,  die von  den zu
              linkenden  Modulen benötigt  werden,  und bildet  daraus
              eine ablaufähige Datei mit dem Dateityp COM.


[SEITE 7-70] *** CP/M-Modus **************************************************


Tabelle 7.15            CP/M 3.0: LIB-Optionen


Option          |       Bedeutung
------------------------------------------------------------------------
                |
I               |       Die INDEX-Option erzeugt eine indizierte
                |       Bibliotheksdatei vom Typ IRL. LINK sucht zuerst
                |       nach nicht indizierten.
                |
M               |       Die MODUL-Option zeigt die Modulnamen an.
                |
P               |       Die PUBLICS-Option zeigt die Modulnamen und die
                |       global verwendeten Variablen der neuen
                |       Bibliotheksdatei an.
                |
D               |       Die DUMP-Option zeigt den Inhalt des
                |       Objektmoduls im ASCII-Format an.


Modifier:

Man verwendet einen Modifier in  der Befehlszeile, um mit LIB Module
in einer Bibliotheksdatei zu  löschen, zu ersetzen oder auszuwählen.
Spitze Klammern <..> schließen die zu löschenden oder zu ersetzenden
Module ein.   Runde Klammern (..) schließen  die ausgewählten Module
ein.


Tabelle 7.16            CP/M 3.0: LIB-Modifier


Funktion        |       Modifier
------------------------------------------------------------------------
                |
Löschen         |       < module = >
                |
Ersetzen        |       < module = dateiname.REL >
                |
                |       Wenn Modulname und Dateiname gleich sind, kann
                |       folgende Kurzform verwendet werden:
                |
                |
                |       < dateiname >
                |
Auswählen       |       ( modERST-modLETZT,mod1,mod2,...,modN)


[SEITE 7-71] *** CP/M-Modus **************************************************


Beispiele:              A>LIB TEST4[P]


                        zeigt alle Module und globalen Variablen von
                        TEST.4.REL an.


                        A>LIB TEST5[P]=FILE1,FILE2


                        erzeugt TEST5.REL auf FILE1.REL und FILE2.REL
                        und zeigt alle Module und globalen Variablen von
                        TEST5.REL an.


                        A>LIB TEST=TEST1(MOD1,MOD4),TEST2(C1-C4,C6)


                        erzeugt eine Bibliotheksdatei TEST.REL aus den
                        Modulen zweier Quelldateien. TEST1.REL liefert
                        MOD1 und MOD4.LIB wählt weiterhin aus TEST2 die
                        Module C1 und C4 sowie alle dazwischen liegenden
                        Module und das Modul C6 aus.


                        A>LIB FILE2=FILE3<MODA=>


                        erzeugt FILE2.REL aus FILE3.REL, jedoch ohne
                        MODA, das ein Modul in FILE3.REL ist.


                        A>LIB FILE6=FILE5<MODA=FILEB.REL>


                        erzeugt FILE6.REL aus FILE5.REL, wobei MODA
                        durch FILEB.REL ersetzt wird.


                        A>LIB FILE6=FILE5<NAME>


                        Modul NAME befindet sich in FILE5.REL. Wenn LIB
                        die Datei FILE6.REL aus FILE5.REL erzeugt, wird
                        das Module NAME durch die namensgleiche Datei
                        NAME.REL ersetzt.


                        A>LIB FILE1[I]=B:FILE2
                        (PLOTS,FIND,SEARCH-DISPLAY)


                        erzeugt FILE1.IRL auf dem Laufwerk A aus den
                        ausgewählten Modulen PLOTS, FIND und SEARCH bis
                        DISPLAY, alle aus FILE2.REL auf dem Laufwerk B.



[SEITE 7-72] *** CP/M-Modus **************************************************


LINK-Befehl

Format:       LINK d:{dateispez,{[o]} = } dateispez{[o]} {,..}

Zweck:        LINK verbindet verschiebbare Objektmodule, die z.B.  von
              RMAC  und  PL/I-80   erzeugt  werden,  zu  einer  direkt
              ausführbaren  COM-Datei.   Verschiebbare Dateien  können
              externe Refenzmodule und  globale Variable enthalten und
              Bezug  auf  Module  in Bibliotheksdatien  nehmen.   LINK
              untersucht   die   Bibliotheksdateien   und   fügt   die
              Referenzmodule  in die  ausgegebene  Datei ein.   Nähere
              Informationen über LINK  sind im entsprechenden Handbuch
              (Programmer's Utilities Guide) zu finden.

Option:       Eine  LINK-Option schaltet die  Paramenter ein,  die den
              Ablauf    beeinflussen.    LINK-Optionen    folgen   den
              Dateibezeichnungen  'dateispez' und sind  in rechteckige
              Klammern  eingeschlossen. Mehrere Optionen  werden durch
              Kommata getrennt.



Tabelle 7.17            CP/M 3.0: LINK-Optionen


Option          |       Bedeutung
------------------------------------------------------------------------
                |
A               |       Zusätzlicher Speicher.
                |       Der Linker reduziert den Pufferbereich und
                |       schreibt Zwischendaten auf die Diskette.
                |
B               |       Erstellen eines BIOS im gebankten CP/M-System:
                |       1. Anfügen eines DATA-Abschnitts an die
                |       Page-Grenze.
                |       2. Ablegen der Länge von Kodeteilen im Header.
                |       3. Vorgaben für den Dateityp SPR.
                |
Dhhhh           |       DATA-Anfang
                |       Die Anfangsadresse für den COMMON- und
                |       DATA-Speicherbereich wird festgelegt.


[SEITE 7-73] *** CP/M-Modus **************************************************


Tabelle 7.17            CP/M 3.0: LINK-Optionen
                        (Fortsetzung)



Option          |       Bedeutung
-------------------------------------------------------------------------
                |
Gn              |       Startadresse (go).
                |       Die Startadresse für das Programm wird auf das
                |       Label n gelegt.
                |
Lhhhh           |       Laden.
                |       Die vorgegebene Ladeadresse eines Moduls kann
                |       statt auf 0100H (Voreinstellung) auf den Wert
                |       hhhh gelegt werden.
                |
NL              |       Kein Listing.
                |       Die Symboltabelle wird nicht auf der Konsole
                |       ausgegeben.
                |
NR              |       Kein Record.
                |       Es wird keine Datei mit Symboltabelle erzeugt.
                |
OC              |       Ausgabe einer COM-Datei.
                |       Die Objektdatei ist vom Dateityp COM.
                |       Dies ist der Normalfall.
                |
OP              |       Ausgabe einer PRL-Datei.
                |       Die verschiebbare Objektdatei (für einen Ablauf
                |       unter MP/M in verschiebbaren Modulen) ist vom
                |       Typ PRL.
                |
OR              |       Ausgabe einer RSP-Datei für MP/M
                |
OS              |       Ausgabe einer SPR-Datei für MP/M
                |
Phhhh           |       Programmbasisadresse.
                |       Die Basisadresse für den Programmkode kann statt
                |       auf 0100H (Voreinstellung) auf den Wert hhhh
                |       gelegt werden.



[SEITE 7-74] *** CP/M-Modus **************************************************


Tabelle 7.17            CP/M 3.0: LINK-Option
                        (Fortsetzung)


Option          |       Bedeutung
------------------------------------------------------------------------
                |
Q               |       Die Symbole mit einem Fragezeichen als erstes
                |       Zeichen werden mit in die Symboltabelle
                |       aufgenommen.
                |
S               |       Suchen.
                |       Es werden nur die notwendigen Teile der
                |       vorstehenden Datei geladen. Die S-Option wird bei
                |       Bibliotheksdateien verwendet.
                |
$Cd             |       Die Konsolenausgabe wird
                |       für d = X zur Konsole geleitet,
                |       für d = Y zum Drucker geleitet oder
                |       für d = Z unterdrückt.
                |       Die Voreinstellung ist X.
                |
$Id             |       Die Zwischendateien werden in Laufwerk d (A - E)
                |       gesucht. Die Vorgabe ist das aktuelle Laufwerk.
                |
$Od             |       Die Objektdatei wird auf das Laufwerk d (A - E)
                |       geschrieben. Für d = Z wird die Ausgabe
                |       unterdrückt. Die Voreinstellung ist das Laufwerk,
                |       in dem die erste Datei des LINK-Befehls steht.
                |
$Sd             |       Die Symboldatei wird auf das Laufwerk d (A - E)
                |       geschrieben. Für d = Y geht die Ausgabe zum
                |       Drucker, und für d = Z wird sie unterdrückt.
                |
Beispiele       |       A>LINK B:MYFILE[NR]
                |
                |       LINK auf Laufwerk A verwendet als Eingabedatei
                |       MYFILE.REL auf Laufwerk B und erzeugt die
                |       ausführbare Programmdatei MYFILE.COM auf Laufwerk
                |       B. Die NR-Option bedeutet, daß keine Datei mit
                |       Symboltabelle erzeugt wird.




[SEITE 7-75] *** CP/M-Modus **************************************************

                |       A>LINK M1,M2,M3
                |
                |       LINK verbindet die einzelnen kimpilierten
                |       Dateien M1, M2 und M3, berechnet ihre externen
                |       Referenzmodule und erzeugt die ausführbare
                |       Programmdatei M1.COM.
                |
                |       A>LINK M=M1,M2,M3
                |
                |       LINK verbindet die einzelnen kompilierten Dateien M1,
                |       M2 und M3 und erzeugt die ausührbare Programmdatei
                |       M.COM
                |
                |       A>LINK MYFILE,FILES<S>
                |
                |       Die S-Option bewirkt, daß LINK die Datei FILES
                |       als eine Bibliotheksdatei sucht. LINK verbindet
                |       MYFILE.REL mit den Referenzunterprogrammen aus
                |       FILE5.REL auf dem aktuellen Laufwerk A und
                |       erzeugt MYFILE.COM auf Laufwerk A.



[SEITE 7-76] *** CP/M-Modus **************************************************


MAC-Befehl

Format:       MAC FILENAME {$OPTIONEN}

Zweck:        Der  CP/M 3.0 Macro-Assembler  MAC liest  Anweisungen in
              Assemblersprache  aus einer  Eingabedatei  vom Typ  ASM,
              assembliert   diese   Anweisungen   und  erstellt   drei
              Ausgabeateien   mit   dem   Eingabeateinamen   und   den
              Typbezeichnungen HEX, PRN und SYM.

              FILENAME.HEX   enthält    den   Objectcode   im   INTEL-
              Hexadezimal-Format.

              FILENAME.PRN enthält  das kommentierte Quell-Listing das
              entweder  ausgedruckt  oder  auf der  Konsole  angezeigt
              werden kann.

              FILENAME.SYM  enthält  die  sortierte Tabelle  der  im
              Programm definierten Symbole.

Optionen:     Mit  den  optionellen  Angabe  können  die  Eingabe  und
              Ausgabelaufwerke  oder -einheiten  bestimmt  werden. Die
              möglichen Optionen  sind in  den Tabellen 7.18  und 7.19
              aufgeführt.



[SEITE 7-77] *** CP/M-Modus **************************************************

Tabelle 7.18            CP/M 3.0: MAC-Input-Output-Optionen


Option          |       Bedeutung
------------------------------------------------------------------------
                |
A               |       Quell-Laufwerk für die ASM-Datei (A-E).
                |
H               |       Ziellaufwerk für die HEX-Datei (A-E, Z).
                |
L               |       Quell-Laufwerk für die LIB-Dateien, die mit dem
                |       MACLIB Statement aufgerufen werden (A-E).
                |
P               |       Zieleinheit für die PRN-Datei
                |
S               |       Zieleinheit für die SYM-Datei (A-O, X, P, Z).


A-E sind  die möglichen   Laufwerke  (sofern vorhanden),   X leitet die   ent-
sprechende Ausgabe auf die  Konsole, P auf den  Drucker und Z  unterdrückt die
Ausgabe.


Tabelle 7.19            CP/M 3.0: MAC-Ausgabemodifikation


Modif.          |       Bedeutung
------------------------------------------------------------------------
                |
+L              |       Input-Zeilen, die von Makrobibliotheksdateien
                |       LIB gelesen werden, auflistet.
                |
-L              |       Auflistung der Input-Zeilen, die von
                |       Makrobibliotheksdateien LIB gelesen werden,
                |       unterbinden (Voreinstellung)
                |
+M              |       Alle Makrozeilen, die beim Assemblieren erzeugt
                |       werden, auflisten.
                |
-M              |       Die Auflistung der Makrozeilen, die beim
                |       Assemblieren erzeugt werden, unterbinden.


[SEITE 7-78] *** CP/M-Modus **************************************************


Tabelle 7.19            CP/M 3.0: Modifikation der Ausgabedateien
                        (Fortsetzung)


Modif.          |       Bedeutung
------------------------------------------------------------------------
                |
*M              |       Makroerweiterungen nur im HEX-Format auflisten.
                |
+Q              |       Alle LOCAL-Symbole in der Symboltabelle
                |       auflisten.
                |
-Q              |       Die Auflistung aller LOCAL-Symbole in der
                |       Symboltabelle unterbinden.
                |
+S              |       Symboldatei an die PRN-Datei anhängen.
                |
-S              |       Die Erzeugung der Symboldatei unterbinden.
                |
+1              |       Erzeugen eines Pass-1-Listings für 'macro
                |       debugging' in der PRN Datei.
                |
-1              |       Pass-1-Listing unterdrücken (Voreinst.)


Beispiele:              A>MAC SAMPLE


                        Der Makroassembler MAC wird vom Laufwerk A
                        aufgerufen und bearbeitet eine Datei SAMPLE.ASM,
                        die auch auf der Diskette im Laufwerk A sein muß.
                        Die Ausgabedateien SAMPLE.OBJ, SAMPLE.PRN und
                        SAMPLE.SYM werden auch im Laufwerk A abgelegt.


                        A>MAC SAMPLE $PB AA HB SX


                        In diesem Beispiel folgt dem MAC-Aufruf und dem
                        Quelldateinamen eine optionelle Parameterliste.
                        Die PRN-Datei wird auf das Laufwerk B geleitet, die
                        ASM-Datei vom Laufwerk A gelesen, die HEX-Datei
                        wird auf Laufwerk B abgelegt und die Symboltabelle
                        wird auf der Konsole gelistet. Als Trennzeichen
                        zwischen einzelnen Paramtern werden Leerstellen
                        benutzt.


[SEITE 7-79] *** CP/M-Modus **************************************************


PATCH-Befehl

Format:       PATCH FILENAME {Typ} {n}

Zweck:        Der PATCH-Befehl  zeigt auf dem  Bildschirm die Nummer
              des  bereits durchgeführten  'Patches'  an oder  führt
              ihn, falls noch nicht geschehen, aus.

              PATCH kann  nur auf CP/M  3.0-Systemdateien angewendet
              werden. Die zulässigen  Typbezeichnungen sind COM, PRL
              oder  SPR. Ohne Angabe  der Typbezecihnung  sucht CP/M
              nach einem COM-Dateinamen.

              Die Patch-Nummer darf nur zwischen 1 und 32 liegen.

Beispiel:     A>PATCH SHOW 2

              Die  Datei   SHOW.COM  wird  mit  dem   Patch  Nr.   2
              bearbeitet.   Auf der  Konsole  wird folgende  Meldung
              ausgegeben:

              Do you want to indicate that Patch #2 has been
              installed for SHOW.COM?Y

              Wird der Patch  erfolgreich durchgeführt, wird auf der
              Konsole angezeigt:

              Patch Installed

              Wird   der  Patch   nicht   erfolgreich  durchgeführt,
              erscheint folgende Meldung auf der Konsole:

              Patch not Installed

              Eine  der nachfolgend  aufgeführten  möglichen Fehler-
              meldungen wird ausgeben:

              * ERROR: Patch requires CP/M 3.
              * ERROR: Invalid filetype typ.
              * ERROR: Serial Number mismatch.
              * ERROR: Invalid patch number n.

[SEITE 7-80] *** CP/M-Modus **************************************************

PIP-Befehl

Format:       ZIEL = QUELLE

              PIP |d:{dateispez} {[Gn]}=dateispez{[o]} {,..}|

              ZIEL-Angabe = d: {[o]}

              PIP



Zweck:        Das   Dateikopierprogramm  PIP  kann   Dateien  zwischen
              Disketten,  Druckern,  Konsolen  oder anderen  logischen
              Einheiten  kopieren, kombinieren  oder  übertragen. Wenn
              als  Quelldateiname  mehrere  mit Komma  getrennt  Namen
              aufgeführt   werden,  werden   diese  Dateien   in  eine
              Zieldatei zusammenkopiert {[o]} ist eine Kombination der
              verfügbaren Optionen.  Die {[Gn]}-Option bestimmt, unter
              welcher  Benutzerbereichsnummer  die Zieldatei  abgelegt
              wird.   Wird  nur   der  Befehl   PIP   ohne  zusütliche
              Spezifikation angegeben,  wird ein *  als Prompt-Zeichen
              angezeigt und die Eingabe einer Befehlszeile erwartet.

              Als  ZIEL  oder  QUELLE  kann jede  sinnvolle  CP/M  3.0
              logische Einheit angegeben werden.

              Wenn  nur ein Einzellaufwerk  zur Verfügung  steht, wird
              als  Ziel-Laufwerk das  virtuelle Laufwerk  E angegeben.
              Während des Kopierens erscheinen dann Aufforderungen zum
              Wechseln der Quell- und Zieldisketten.

Beispiele:    Eine Datei von einer auf eine andere Diskette kopieren:


              A>PIP b:=a:draft.txt
              A>PIP b:draft.txt=a:
              B3>PIP myfile.dat=A:[G9]
              A9>POP B:[G3]=myfile.dat

              Eine Datei kopieren und umbenennen:

              A5>PIP newdraft.txt=olddraft.txt
              C8>PIP b:newdraft.txt=a:olddraft.txt

[SEITE 7-81] *** CP/M-Modus **************************************************

              Mehrere   Dateien   auf   einmal  nacheinander   einzeln
              kopieren:

              A>PIP b:=draft.*
              C>PIP b:=*.txt[G5]
              C>PIP a:=*.com<wr>
              B>PIP a:<g3>=c:*.*

              Mehrere Dateien zusammenkopieren:

              A>PIP b:new.dat=file1.dat,file2.dat

              Kopieren, Umbenennen und Zuordnen im Benutzerbereich 1:

              A>PIP newdraft.txt<g1>=olddraft.txt

              Kopieren und Umbenennen aus dem Benutzerbereich 1:

              A>PIP newdraft.txt=olddraft.txt[g1]

              A>PIP b:funfile.sue=con:
              A>PIP lst:=con:
              A>PIP lst:=b:draft.txt[t8]
              A>PIP prn:=b:draft.txt


Tabelle 7.20            CP/M 3.0: PIP-Optionen


Option          |       Bedeutung
------------------------------------------------------------------------
                |
A               |       Archiv. Nur die Dateien kopieren, die seit dem
                |       letzten Kopieren verändert wurden.
                |
C               |       Confirm. Wenn mehrere Dateien auf einmal
                |       kopiert werden, wird jedesmal eine Bestätigung
                |       verlangt.
                |
Dn              |       Ausblenden aller Zeichen nach der n-ten Stelle
                |       in einer Zeile, z.B. Begrenzen der Zeilenlänge
                |       bei der Druckerausgabe auf die druckbare
                |       Zeilenlänge.


[SEITE 7-82] *** CP/M-Modus **************************************************


Tabelle 7.20            CP/M 3.0: PIP-Optionen
                        (Fortsetzung)

Option          |       Bedeutung
------------------------------------------------------------------------
                |
E               |       Echo. Alle Zeichen werden während der
                |       Übertragung auch auf der Konsole angezeigt.
                |
F               |       Filter (form feeds). Alle Seitenvorschubszeichen
                |       (ASCII-Wert 0CH oder CTRL-L) werden beim Kopieren
                |       entfernt.
                |
Gn              |       Kopieren in oder aus dem Benutzerbereich n.
                |
H               |       Überprüfen der Dateien auf korrekte
                |       INTEL-Hex-Formate bei der Übertragung von
                |       HEX-Dateien. Fehler werden auf der Konsole
                |       angezeigt.
                |
I               |       :00-Records im INTEL-Hex-Format werden
                |       ignoriert. Mit der I-Option wird automatisch
                |       auch die H-Option aktiviert.
                |
L               |       Großgeschriebene (A-Z) werden in
                |       kleingeschriebene Zeichen (a-z) umgewandelt. Alle
                |       anderen Zeichen bleiben unverändert.
                |
N               |       Zeilennummer an den Anfang jeder Zeile setzen.
                |       Die Nummern beginnen mit 1 und werden von Zeile zu
                |       Zeile um 1 erhöht. Nach der Nummer folgt ein
                |       Doppelpunkt.
                |
O               |       Kopieren von Objektdateien. Das Dateiendzeichen
                |       CTRL-Z (^Z) wird wie ein normales
                |       Zeichen übertragen und beendet die Übertragung
                |       nicht.
                |
Pn              |       Seitenlänge setzen. Nach n Zeilen wird ein
                |       ASCII-Wert 0CH (Seitenvorschub) eingefügt.
                |
Qs^Z            |       Beenden des Kopierens nach dem String s.
                |
R               |       Kopieren von Systemdateien mit dem Attribut SYS.
                |


[SEITE 7-83] *** CP/M-Modus **************************************************


Tabelle 7.20            CP/M: PIP-Optionen
                        (Fortsetzung)


Option          |       Bedeutung
------------------------------------------------------------------------
                |
Ss^Z            |       Die Datei wird erst ab String s kopiert.
                |
Tn              |       TAB-Zeichen (ASCII-Wert 09H) werden durch n
                |       Leerzeichen ersetzt.
                |
U               |       Kleingeschriebene (a-z) werden in
                |       großgeschriebene Zeichen (A-Z) umgewandelt. Alle
                |       anderen Zeichen bleiben unverändert.
                |
V               |       Verify. Kopierte Daten werden auf Korrektheit
                |       überprüft (nur beim Kopieren auf Disketten
                |       möglich).
                |
W               |       Eine existierende Nur-Lese-Datei mit dem
                |       RO-Attribut (Read Only) wird beim Kopieren auf der
                |       Zieldiskette überschrieben.


[SEITE 7-84] *** CP/M-Modus **************************************************


PUT-Befehl

Format:       PUT CONSOLE {OUTPUT TO} dateispez {OPTION}
              PUT PRINTER {OUTPUT TO} dateispez {OPTION}
              PUT CONSOLE {OUTPUT TO} CONSOLE
              PUT PRINTER {OUTPUT TO} PRINTER

Zweck:        Mit  dem  PUT-Befehl wird  die  Konsolen- oder  Drucker-
              ausgabe   in  eine  Diskettendatei   umgeleitet.   Diese
              Umleitung beginnt  mit dem nächsten  eingegebenen Befehl
              und wird mit einem entsprechenden PUT-Befehl beendet.

              PUT  mit  der  SYSTEM-Option leitet  alle  nachfolgenden
              Konsolen- oder  Druckerausgabe in die  angegebene Datei.
              Diese Option  wird beendet  mit der Eingabe  PUT CONSOLE
              oder PUT PRINTER.

Optionen:     Folgende Optionen sind möglich:

              [{ECHO / NO ECHO}{FILTER / NO FILTER?}{SYSTEM}]


[SEITE 7-85] *** CP/M-Modus **************************************************


Tabelle 7.21            CP/M 3.0: PUT-Optionen


Option          |       Bedeutung
------------------------------------------------------------------------
                |
ECHO            |       Die Ausgabe wird gleichzeitig auf der Konsole
                |       angzeigt (Voreinstellung).
                |
NO ECHO         |       Die Ausgabe auf der Konsole wird unterdrückt.
                |
FILTER          |       CTRL-Zeichen werden in druckbare Zeichen
                |       umgewandelt. Beispielsweise wird das ESC-Zeichen
                |       als ^[ wiedergegeben.
                |
NO FILTER       |       CTRL-Zeichen werden nicht umgewandelt
                |       (Voreinstellung).
                |
SYSTEM          |       Die SYSTEM- und PROGRAMM-Ausgaben werden in die
                |       angegebene Datei geschrieben, bis ein PUT-CONSOLE-
                |       oder PUT-PRINTER-Befehl die Ausgabe wieder
                |       zurückleitet.

Beispiele:              A>PUT CONSOLE OUTPUT TO FILE XOUT [ECHO]

                        Leitet Konsolenausgabe in eine Datei XOUT. Die
                        Ausgabe wird auf der Konsole wiederholt.

                        A>PUT PRINTER OUTPUT TO FILE XOUT
                        A>TESTPROG

                        Leitet die Druckerausgabe des Programms TESTPROG
                        in eine Datei XOUT. Die Ausgabe wird auf dem
                        Drucker nicht wiederholt.



[SEITE 7-86] *** CP/M-Modus **************************************************


                        A>PUT PRINTER OUTPUT TO FILE XOUT2
                        [ECHO,SYSTEM]

                        Leitet alle Druckerausgaben in die Datei XOUT2
                        und wiederholt sie auf dem Bildschirm (mit
                        ECHO-Option). Diese Umleitung ist so lange wirksam,
                        bis der Befehl PUT PRINTER TO PRINTER eingegeben
                        wird.

                        A>PUT CONSOLE OUTPUT TO CONSOLE

                        Leitet die Ausgabe wieder auf die Konsole.

                        A>PUT PRINTER OUTPUT TO PRINTER

                        Leitet die Druckerausgabe wieder auf den
                        Drucker.


[SEITE 7-87] *** CP/M-Modus **************************************************

RENAME-Befehl


Format:       RENAME {DATEINAME-NEU=DATEINAME-ALT}

Zweck:        RENAME  ermöglicht das Umbenennen  von Diskettendateien.
              Mehrere  Namen können  gleichzeitig  bei Verwendung  der
              Zeichen *  oder ? geändert werden. Der  Befehl kann auch
              mit REN abgekürzt werden.


Beispiele:    A>RENAME NEWFILE.BAS=OLDFILE.BAS

              Die Datei OLDFILE.BAS wird in NEWFILE.BAS umbenannt.

              A>RENAME

              Es erscheinen folgende System-Abfragen:

              Enter New Name: Y.PRN
              Enter Old Name: X.PRN
              Y      .PRN=X          .PRN
              A>

              B>REN A:PRINTS.NEW=PRINCE.NEW

              Die Datei  PRINCE.NEW im  Laufwerk A wird  in PRINTS.NEW
              umbenannt.

              A>RENAME S*.TEX=A*.TEX

              Alle  Dateien, auf  die die  Abkürzung  A*.TEX zutrifft,
              werden in S*.TEX umbenannt.

              A>REN B:NEWLIST=B:OLDLIST

              Die  Datei  OLDLIST  wird  in  NEWLIST  umbenannt.   Die
              Laufwerksbezeichnung  muß nur  einmal  angegeben werden.
              Die   nachfolgenden  Befehlszeilen  haben   die  gleiche
              Auswirkung:

              A>REN B:NEWLIST=OLDLIST

              oder

              A>REN NEWLIST=B:OLDLIST


[SEITE 7-88] *** CP/M-Modus **************************************************


RMAC-Befehl

Format:       RMAC dateispez { $Rd / $Sd / $Pd }

Zweck:        Der Assembler RMAC  erzeugt einen verschiebbaren Kode in
              einer REL-Datei, der mit  einem Linker in eine COM-Datei
              umgewandelt werden kann.

Optionen:     Die  Optionen  bestimmen   die  Zuordnung  der  Ausgabe-
              dateien  zu den  Ausgabeeinheiten.   Der Buchstabe  wird
              dabei durch die korrekte Bezeichnung ersetzt.


Tabelle 7.22            CP/M 3.0: RMAC-Optionen



Option          |       Bedeutung
------------------------------------------------------------------------
                |
Rd              |       Einheit für die REL-Datei (A-E,Z)
                |
Sd              |       Einheit für die SYM-Datei (A-E,X,P,Z)
                |
Pd              |       Einheit für die PRN-Datei (A-E,X,P)


Hierbei bedeutet:


A-E                     Laufwerke A bis E
X                       Konsole als Ausgabeeinheit
P                       Drucker als Ausgabeeinheit
Z                       unterbindet die Ausgabe



Beispiele:    A>RMAC TEST $PX SB RB

              Die Datei  TEST wird  vom Laufwerk A  assembliert, die
              Ausgabedatei TEST.PRN auf der Konsole, die Symboldatei
              TEST.SYM  und die  verschiebbare  Objektdatei REST.REL
              auf Laufwerk B ausgegeben.


[SEITE 7-89] *** CP/M-Modus **************************************************


SAVE-Befehl

Format:       SAVE

Zweck:        SAVE  kopiert den  Inhalt eines  Teils des  Speichers in
              eine Datei.  Bei Verwendung des SAVE-Befehls wird dieser
              zuerst eingegeben und dann  ein Programm (z.B. SID), das
              eine  Datei in  den Speicher  einliest,  gestartet. SAVE
              meldet sich dann mit einigen Abfragen wieder.

Beispiel:     A>SAVE
              A>SID DUMP.COM

              Das eingelesene Programm wird gestartet.

              *g0

              oder mit  ^C abgebrochen.  Wenn  dieses Programm beendet
              oder abgebrochen wird,  unterbricht SAVE die Rückkehr in
              das System und meldet sich wie folgt:

              SAVE Ver 3.0
              Enter file(type RETURN to exit):dump2.com

              Wenn  die   Datei  DUMP2.COM  bereits   existiert,  wird
              gefragt:

              Delete dump2.com?Y

              Dann  fragt  das System  nach  dem Speicherbereich,  der
              abgespeichert werden soll.

              Beginning hex address 100
              Ending hex address 400

              Der Speicherinhalt  von 100H bis 400H wird  in die Datei
              DUMP2.COM kopiert.


[SEITE 7-90] *** CP/M-Modus **************************************************


SET-Befehl

Format:       SET {Optionen}
              SET d: [Optionen]
              SET dateispez [Optionen]

Zweck:        Mit  dem SET-Befehl  werden Dateiattribute  (Read Write,
              Read Only, DIR und  SYS), der Paßwort-Schutz und die Art
              der  Zeit-  und Datumskennung  bestimmt.   Um die  Zeit-
              erkennung  der  Dateien  zu initialisieren,  muß  zuerst
              INITDIR ausgeführt werden.


[SEITE 7-91] *** CP/M-Modus **************************************************

Datei-Attribute setzen

Format:       SET dateispez <Optionen>


Tabelle 7.23            CP/M 3.0: Datei-Attribute


Attribut        |       Bedeutung
------------------------------------------------------------------------
                |
DIR             |       Systemattribut der Datei wird aufgehoben.
                |
SYS             |       Datei wird als Systemdatei (SYS) gekennzeichnet
                |
RO              |       Datei wird als Read-Only gekennzeichnet
                |
RW              |       Datei wird als Read-Write gekennzeichnet


[SEITE 7-92] *** CP/M-Modus **************************************************


Tabelle 7.23            CP/M 3.0: Datei-Attribute
                        (Fortsetzung)


Attribut        |       Bedeutung
------------------------------------------------------------------------
                |
ARCHIVE=OFF     |       Das Archivattribut wird entfernt. Das bedeutet,
                |       daß die Datei beim Kopieren nicht mitkopiert
                |       wird. Siehe unter PIP mit Option [A].
                |
ARCHIVE=ON      |       Das Archivattribut wird auf EIN gesetzt.
                |
F1=ON/OFF       |       Setzen oder Ausschalten des vom Benutzer
                |       definierten Attributs F1.
                |
F2=ON/OFF       |       Setzen oder Ausschalten des vom Benutzer
                |       defnierbaren Attributs F2.
                |
F3=ON/OFF       |       Setzen oder Auschalten des vom Benutzer
                |       definierbaren Attributs F3.
                |
F4=ON/OFF       |       Setzen oder Ausschalten des vom Benutzer
                |       definierbaren Attributs F4.


Beispiele:    A>SET MYFILE.TXT [RO,SYS]

              Der  Datei MYFILE.TXT  werden die  Nur-Lese-  (RO) und
              SYS-Attribute zugeordnet.

              A>SET DEINFILE.TXT <RW,DIR>

              Der Datei DEINFILE.TXT  werden  die Schreib-Lese- (RW)
              und DIR-Attribute zugeordnet.


[SEITE 7-93] *** CP/M-Modus **************************************************


Laufwerks-Attribut bestimmen

Format:       SET {d:} [RO]
              SET {d:} [RW]

Zweck:        Den  Laufwerken  kann mit  dem  SET-Befehl entweder  das
              Nur-Lese- (RO) oder das Schreib-Lese-Attribut zugeordnet
              werden.

              Ein Laufwerk, dem  das Nur-Lese-Attribut zugeordnet ist,
              kann nur  zum Lesen  von Dateien verwendet  werden.  Der
              PIP-Befehl  kann keine Dateien  auf Disketten  in diesem
              Laufwerk  kopieren,  mit   ERASE  können  keine  Dateien
              gelöscht und mit RENAME keine Dateien umbenannt werden.

              Beim  Eingeben  von  CTRL-C  wird allen  Laufwerken  das
              Schreib-/Lese-Attribut zugordnet (Reset der Laufwerke).


Beispiel:     A>SET B: [RO]<CR>

              Das Laufwerk B wird als Nur-Lese-Laufwerk markiert.

              A>SET C: [RW]<CR>

              Das  Laufwerk  C  wird  als  Schreib-Lese-Laufwerk  (RW)
              markiert. Der  Status von anderen  Laufwerken wird nicht
              verändert.

              ^C

              Alle  Laufwerke werden als  Schreib-/Lese-Laufwerke (RW)
              gesetzt.


[SEITE 7-94] *** CP/M-Modus **************************************************


Disketten-Label festlegen

Format:       SET {d} [NAME=LABELNAM.TXT]

Zweck:        Zuordnung  eines Namens (Label)  für die  Diskette.  Für
              die  Zusammenhsetzung  des  Labels gelten  die  gleichen
              Regeln wie  für den  Namen und die  Typbezeichnung einer
              Datei.

Beispiel:     A>SET B: [NAME=BEISPIEL.TXT]<CR>

              Die   Diskette   im  Laufwerk   B   bekommt  das   Label
              BEISPIEL.TXT zugeordnet.


[SEITE 7-95] *** CP/M-Modus **************************************************


Disketten-Label ein Paßwort zuordnen

Format:       SET [PASSWORD=paßwort]
              SET [PASSWORT=<CR>

              Bei   Disketten,  die  mit   einem  durch   ein  Paßwort
              geschützten Label  versehen sind, können  das Label oder
              das  Paßwort nur nach  Eingabe des  korrekten bisherigen
              Paßworts geändert  werden.  Das SET-Programm  fragt dann
              selbstständig nach dem alten Paßwort.


              SET [PASSWORD=paßwort]
              Dem Disketten-Label wird ein Paßwort zugeordnet.

              A>SET [PASSWORD=<CR>
              Ohne   die   Eingabe    einer   Bezeichnung   nach   dem
              Gleichheitszeichen   wird   das   existierende   Paßwort
              gelöscht.


[SEITE 7-96] *** CP/M-Modus **************************************************


Paßwort-Schutz für Diskettendateien ein- oder ausschalten

Format:       SET [PROTECT=ON]
              SET [PROTECT=OFF]

Zweck:        Mit PROTECT=ON  wird ein Paßwortschutz  für alle Dateien
              auf der  Diskette gesetzt. Dieser  Befehl muß ausgeführt
              werden, bevor einzelnen  Dateien auf der Diskette eigene
              Paßworte zugeordnet  werden. Mit PROTECT=OFF  wird diese
              Option wieder  ausgeschaltet.  Mit dem  SHOW-Befehl kann
              jederzeit  überprüft werden, ob  die Diskette  mit einem
              Paßwort geschützt ist oder nicht.


[SEITE 7-97] *** CP/M-Modus **************************************************


Paßwortschutz Diskettendateien zuordnen

Format:       SET dateispez [PASSWORD=paßwort]

Zweck:        Diese  Art des  SET-Befehls ordnet  den  mit 'dateispez'
              definierten Dateien einen Paßwortschutz zu.  Das Paßwort
              kann bis  zu acht Zeichen  lang sein.  Kleingeschriebene
              Zeichen werden in großgeschriebene Zeichen umgewandelt.

              Bei der Dateiendbestimmung  können auch die Platzhalter-
              zeichen  *  und ?   verwendet  werden,  SET ordnet  dann
              dasselbe Paßwort  allen Dateien  zu, auf die  die Datei-
              bezeichnung zutrifft.

Bemerkung:    

              Notieren  Sie  sich  immer  die von  Ihnen  festgelegten
              Paßworte für  Ihre Dateien. Ohne das  Paßwort zu kennen,
              ist  es  nicht  möglich,  auf  die  geschützten  Dateien
              zuzugreifen.   Wenn Sie das  Paßwort für  das Disketten-
              label  vergessen, können Sie  den Paßwortschutz  für die
              Diskette nicht wieder ausschalten.

Beispiel:     >SET MEINDAT.TXT [PASSWORD=SCHUTZ]

              SCHUTZ  ist  das  Paßwort,  das  der  Datei  MEINDAT.TXT
              zugewiesen wird.


[SEITE 7-98] *** CP/M-Modus **************************************************


Art des Paßwortschutzes für geschützte Dateien setzen

Format:       SET dateispez [PROTECT=READ]
              SET dateispez [PROTECT=WRITE]
              SET dateispez [PROTECT=DELETE]
              SET dateispez [PROTECT=NONE]

Zweck:        Der  Paßwortschutz   von  Dateien  kann   in  vier  ver-
              schiedenen  Stufen  stattfinden.   Die  Schutzmodi  sind
              READ,  WRITE, DELETE und  NONE.  Die  Bedeutungen dieser
              Modi sind in der Tabelle 7.23 erklärt.


Beispiele:    B>SET *.TXT [PASSWORD=NOS,PROTECT=WRITE]

              Das Paßwort NOS wird allen  Dateien des Typs TXT auf der
              Diskette im Laufwerk  B zugeordnet.  Jede dieser Dateien
              ist  gegen  das  unberechtigte Schreiben  und  Verändern
              geschützt.  Diesen Schutz  kann  nur derjenige  Benutzer
              aufheben, der das Paßwort kennt.



Tabelle 7.24            CP/M 3.0: SET-Paßwort-Optionen


Option          |       Schutzart
------------------------------------------------------------------------
                |
READ            |       Paßwortangabe ist zum Lesen, Kopieren,
                |       Schreiben, Löschen oder Umbenennen notwendig.
                |
WRITE           |       Paßwortangabe ist zum Schreiben, Löschen oder
                |       Umbennen notwendig. Zum Lesen ist kein Paßwort
                |       erfordlich.
                |
DELETE          |       Paßwortangabe ist nur zum Löschen oder
                |       Umbenennen der Datei notwendig. Zum Lesen oder
                |       Modifizieren der Datei ist kein Paßwort
                |       erforderlich.
                |
NONE            |       Der Datei wird kein Paßwort zugeordnet. Bei
                |       existierendem Paßwort kann mit dieser Option
                |       das Paßwort gelöscht werden.


[SEITE 7-99] *** CP/M-Modus **************************************************

Standard-Paßwort (default) bestimmen

Format:       SET [DEFAULT=paßwort]

Zweck:        Mit dem SET-Befehl für das Standard-Paßwort wird für die
              Einschaltdauer des Computers das vorgegebene Paßwort als
              Standard-Paßwort verwendet.   Auf alle Dateien,  die mit
              demselben  Paßwort  wie  das Standard-Paßwort  geschützt
              sind, kann zugegriffen werden.

              Wird bei  der Dateierstellung kein  Paßwort bestimmt und
              die  PROTECT-Option  ist  auf  ON gesetzt,  wird  diesen
              Dateien   das    Standard-Paßwort   als   ihre   Paßwort
              zugeordnet.

Beispiel:     A>SET [DEFAULT=MUSTER]

              Das  System setzt  MUSTER als  Ersatz-Paßwort  ein, wenn
              kein anderes Paßwort für die Datei angegeben wird.


[SEITE 7-100] *** CP/M-Modus *************************************************

Zeit- und Datumskennungsart

Format:       SET [CREATE=ON]
              SET [ACCESS=ON]
              SET [UPDATE=ON]

Zweck:        Mit  diesen  SET-Optionen  wird  ermöglicht,  Zeit-  und
              Datumsmarkierungen  über  Zugriffe  auf  die  Disketten-
              dateien zu speichern.

              [CREATE=ON]
              Nur  wenn  diese Option  eingeschaltet  ist, werden  den
              Dateien Zeitmarkierungen  über den Zeitpunkt  (Datum und
              Zeit) der Erstellung  im Inhaltsverzeichnis der Diskette
              zugeordnet.

              [ACCESS=ON]
              Im  Inhaltsverzeichnis der  Diskette wird  der Zeitpunkt
              des  letzten  Zugriffs  auf  die jeweilige  Datei  fest-
              gehalten,  wenn der Datei  das Attribut  [RW] zugeordnet
              ist.

              CREATE=ON und ACCESS=ON schalten sich gegenseitig aus.

              [UPDATE=ON]
              schaltet  die Erstellung  der Zeitmarkierungen  über die
              letzte Dateiveränderung ein.

Beispiel:     A>SET [ACCESS=ON]

              Nach  Eingabe dieses  Befehls  wird mit  dem Befehl  DIR
              [FULL] z.B. folgendes angezeigt:

              B>DIR [FULL]


Name            Bytes   Recs   Attributes  Prot Update Access

ONE     .TEX    9k      71     DirRW       None        08/03/81 10:56
THREE   .TEX    12k     95     DirRW       None        08/05/81 15:45
TWO     .TEX    10k     76     DirRW       None        08/10/81 09:13


[SEITE 7-101] *** CP/M-Modus *************************************************

              In der  Spalte 'Access'  wird jeweils der  Zeitpunkt des
              letzten  Zugriffs auf die  jeweilige Datei  ange- zeigt.
              Das Anzeigen  des Dateinamens  durch DIR wird  nicht als
              Dateizugriff bewertet.

              Nach der Eingabe von

              A>SET [CREATE=ON,UPDATE ON]

              wird   mit  dem  Befehl   DIR  [FULL]   z.B.   folgendes
              angezeigt:

              A>DIR [FULL]


Name        Bytes  Recs Attri  Prot  Update          Access
                        bute

BEISPIEL.   109k   873  DirRW  None  08/05/81 14:01  08/01/81 09:36
TEX
TEXTE.TEX   59k    475  DirRW  None  08/08/81 12:11  08/01/81 09:40
TWO.TEX     76k    76   DirRW  None  08/08/81 08:46  08/01/81 10:15



[SEITE 7-102] *** CP/M-Modus *************************************************

SETDEF-Befehl

Format:       SETDEF {d:{,d:{,d:{d:}}}} {[TEMPORARY=d:]
              [ORDER=(typ {,typ})]}

              SETDEF [DISPLAY / NO DISPLAY]

              SETDEF [PAGE / NO PAGE]

Zweck:        Der   SETDEF-Befehl   wird   dazu  benutzt,   bestehende
              Diskettendateien-  und  Dateityp-Suchkriterien  und  die
              Laufwerksbezeichnungen  für  die  Ablage  von  Zwischen-
              dateien   zu  bestimmen   oder   bestehende  Zuordnungen
              anzuzeigen.

              Mit SETDEF  können auch die DISPLAY-  und PAGE-Modi ein-
              und ausgeschaltet werden.

              Wenn der  DISPLAY-Modus eingeschaltet ist, [DISPLAY=ON],
              werden  die  Namen   und  Typbezeichnungen  der  jeweils
              geladenen oder  von SUBMIT ausgeführten  Dateien auf dem
              Bildschirm  angezeigt.   Bei  [DISPLAY=OFF]  wird  diese
              Anzeige unterdrückt.

              Beim  eingeschalteten  PAGE-Modus  wird die  Bildschirm-
              anzeige nach jeder voll ausgefüllten Bildschirmseite, um
              sie lesen zu können.

              CP/M  sucht gewöhnlich  nur auf  dem  aktuellen Laufwerk
              nach Dateien, wenn kein anderes Laufwerk angegeben wird.
              Mit SETDEF  kann diese  Suche auch auf  andere Laufwerke
              erweitert werden, allerdings  nur zum Ausführen von COM-
              und SUB-Dateien.


[SEITE 7-103] *** CP/M-Modus *************************************************


Anzeige der bestehenden Systemeinstellungen

Format:       SETDEF

Beispiel:     A>SETDEF

              Drive Search Path:
              1st Drive               -Default
              Search Order            -COM
              Temporary Drive         -Default
              Console PageMode        -On
              Program Name Display    -Off

              Die  oben   aufgeführte  Anzeige  erscheint,   wenn  der
              SETDEF-Befehl  gleich  nach  dem Systemstart  eingegeben
              wird und noch keine Veränderungen veranlaßt wurden.


[SEITE 7-104] *** CP/M-Modus *************************************************


Zuordnung des Laufwerks für Zwischendateien

Beispiel:               A>SETDEF <TEMPORARY=D:>

              Alle  Zwischendateien  werden  nicht auf  dem  aktuellen
              sondern  auf  dem   mit  dem  SETDEF-Befehl  angegebenen
              Laufwerk abgelegt.


[SEITE 7-105] *** CP/M-Modus *************************************************


Dateisuchkriterien bestimmen

Format:       SETDEF {d:{,d:{,d:{,d:}}}}

Zweck:        Der   Suchweg    für   COM-   oder    SUB-Dateien   wird
              bestimmt.  Wird ein  Stern (*)  im  Suchpfad eingegeben,
              wird  anschliessend  auch   auf  dem  jeweils  aktuellen
              Laufwerk gesucht.

Beispiel:     A>SETDEF C:,*

              Nach  einer  Datei  wird   zuerst  auf  Laufwerk  C  und
              anschließend, falls die  Datei nicht gefunden wurde, auf
              dem aktuellen Laufwerk gesucht.

              A>SETDEF B:,E:,*

              Gesucht wird in  folgender Reihenfolge: Laufwerk B, dann
              virtuelles  Laufwerk  E  und anschließend  das  aktuelle
              Laufwerk.


[SEITE 7-106] *** CP/M-Modus *************************************************


Bestimmen der Dateitypen für das Suchkriterium

Format:       SETDEF [ORDER = (typ {,typ})]

Zweck:        Als   Dateityp  kann   nur  COM   oder   SUB  eingesetzt
              werden. CP/M  setzt nach dem  Start nur COM  als Vorgabe
              ein.

Beispiele:    A>SETDEF [ORDER=(SUB,COM)]

              Gesucht wird nach SUB- und COM-Dateien.

              B>SETDEF [ORDER=(SUB)]

              Gesucht wird nur nach SUB-Dateien.

[SEITE 7-107] *** CP/M-Modus *************************************************

System-Anzeigemodus setzen

Format:       SETDEF [DISPLAY / NO DISPLAY]

Beispiele:    A>SETDEF [DISPLAY]

              Die Anzeige  von Namen  und Typen der  geladenen Dateien
              wird eingeschaltet.

              Wird  nach dem Einschalten  der Display-Option  z.B. PIP
              gestartet, erscheint:

              >PIP
              A:PIP   COM
              CP/M 3 PIP VERSION 3.0
              *

              auf dem Bildschirm.  Ist ein anderer Benutzerbereich als
              0 eingeschaltet  und befindet  sich PIP nicht  in diesem
              Benutzerbereich, sondern  im Bereich 0  als eine System-
              Datei, dann wird mit:

              4A>PIP
              A:PIP   COM(User0)
              CP/M 3 PIP VERSION 3.0
              *

              angezeigt,  daß PIP  aus dem  Benutzerbereich  0 geladen
              wurde.

              Nach dem CP/M-Start ist der Display-Modus ausgeschaltet.

[SEITE 7-108] *** CP/M-Modus *************************************************

System-PAGE-Modus ein- oder ausschalten

Format:       SETDEF [PAGE / NO PAGE]

              A>SETDEF [NO PAGE]


              Die  Bildschirmausgabe erfolgt ohne  Unterbrechung, auch
              wenn  der  angezeigte Text  größer  als die  Bildschirm-
              länge ist.

              Nach dem CP/M-Start ist der PAGE-Modus eingeschaltet.

[SEITE 7-109] *** CP/M-Modus *************************************************

SHOW-Befehl

Format:       SHOW {d:} {[SPACE,LABEL,USERS,DIR,DRIVE]}

Zweck:        Mit dem  SHOW-Befehl können folgende  Informationen über
              Disketten und Laufwerke angezeigt werden:

              - Zugriffstatus und freier Platz auf Diskette

              - Disketten-Label

              - Aktueller Benutzerbereich

              - Anzahl der Dateien  in einzelnen Benutzerbereichen auf
                der Diskette

              - Anzahl   der   freien  Inhaltsverzeichnis-(directory-)
                Einträge auf der Diskette

              - Laufwerksparameter


[SEITE 7-110] *** CP/M-Modus *************************************************


Zugriffsstatus und freien Platz auf der Diskette anzeigen

Format:       SHOW {d:}{[SPACE]}

Zweck:        Angezeigt  wird die Laufwerksbezeichnung,  der Zugriffs-
              status  und der freie  Platz auf  der Diskette  für alle
              angemeldeten Laufwerke.

Beispiel:     A>SHOW B:
              B: RW, Space            4k

              A>SHOW
              A: RW, Space            132k
              B: RW, Space            4k


[SEITE 7-111] *** CP/M-Modus *************************************************


Diskettenlabel anzeigen

Format:       SHOW {d:} [LABEL]

Zweck:        Angezeigt    werden   alle   Informationen    über   das
              Diskettenlabel und seine Attribute.

Beispiel:     A>SHOW B: [LABEL]

Label for Drive B:

Directory       Passwds Stamp   Stamp
Label           Reqd    Access  Update  Label    Created Label    Updated

DISKLAB.ONE     on      on      on      06/12/85 14:06   06/13/85 22:05

              In  der ersten  Spalte wird  das Label  der  Diskette im
              Laufwerk  B, in  den nächsten  Spalten, ob  ein Paßwort-
              schutz  und  die  Zeit-  und  Datumsmarkierungen  einge-
              schaltet  sind,   angezeigt.   Anschließend  werden  die
              Zeitpunkte   der   Labelerstellung   und   der   letzten
              Veränderung dargestellt.


[SEITE 7-112] *** CP/M-Modus *************************************************


Benutzerbereiche auf der Diskette anzeigen

Format:       SHOW {d:} [USERS]

Zweck:        Die  Nummern  des  aktiven  Benutzerbereichs  und  aller
              vorhandenen  Benutzerbereiche  auf  der Diskette  werden
              angezeigt, dazu die Anzahl  der Dateien in den einzelnen
              Benutzerbereichen.

              A>SHOW [USERS]

              A:Active User   :       0
              A:Active Files  :       0       2       3
              A: # of files   :       24      12      6

              A:Number of time/date directory entries: 32
              A:Number of free directory entries:      50

              Die Anzeige  der Zeit- und  Datumseinträge geschieht nur
              bei Disketten, die mit INITDIR bearbeitet wurden.


[SEITE 7-113] *** CP/M-Modus *************************************************


Anzeige freier Einträge im Disketteninhaltsverzeichnis

              SHOW {d:} [DIR]

              A>SHOW C: [DIR]

              A:Number of free directory entries:  50


[SEITE 7-114] *** CP/M-Modus *************************************************


Anzeige der Disketten-Eigenschaften

Format:       SHOW [DRIVE]]

Beispiele:    A>SHOW [DRIVE]

                  A: Drive Characteristics
              2,720: 128 Byte Record Capacity
                340: Kilobyte Drive Capacity
                128: 32 Byte Directory Entries
                128: Checked Directory Entries
                256: Records / Directory Entry
                 16: Records / Block
                  8: Sectors / Track
                  0: Reserved Tracks
               1024: Bytes

              A:>SHOW B: [DRIVE] ;  im Laufwerk  B ist  eine Kaypro-
              Diskette


                  A: Drive Characteristics
              3,152: 128 Byte Record Capacity
                394: Kilobyte Drive Capacity
                128: 32 Byte Directory Entries
                128: Checked Directory Entries
                256: Records / Directory Entry
                 16: Records / Block
                 40: Sectors / Track
                  1: Reserved Tracks
                512: Bytes / Physical Record


[SEITE 7-115] *** CP/M-Modus *************************************************


SID-Befehl

Format:       SID {pgm-dateispez} {,sym-dateispez}

Zweck:        Mit  dem SID  (Symbolic Instruction  Debugger)  kann man
              Programme, die  für den Prozessor  8080 entwickelt sind,
              anzeigen   und  austesten,  SID   unterstützt  Echtzeit-
              Unterbrechungspunkte,  schrittweise  Programmabarbeitung
              mit    Ablaufanzeige,   symbolische   Dissassemblierung,
              Assemblierung,    Anzeige    und    Veränderungen    von
              Speicherinhalten.

              SID  ohne Angabe  einer Dateibezeichnung  lädt  nur sich
              selbst  in  den  Speicher. Dann  können  Speicherinhalte
              angezeigt  oder  einfach   Programme  mit  dem  A-Befehl
              geschrieben werden.  Ohne ein ablauffähiges  Programm im
              Speicher  können  die  SID-Befehle  G, T  oder  U  nicht
              ausgeführt werden.

              SID mit Angabe  einer Dateibezeichnung lädt beides, sich
              selbst und  die angegebene Datei, in  den Speicher. Wird
              nur  der Dateiname  ohne Typbezeichnung  angegeben nimmt
              SID den Typ COM als Vorgabe. Mit den Befehlken C, T oder
              U  kann das  geladene Programm  unter Kontrolle  vom SID
              abgearbeitet werden.

              Mit  CTRL-S wird  die Bildschirmausgabe  angehalten, mit
              CTRL-Q wieder  gestartet.  Abgebrochen wird  die Ausgabe
              durch das Drücken einer beliebigen Taste.

              Mit CTRL-C  wird der SID-Programmablauf  abgebrochen und
              zurück in CP/M gesprungen.

              Ausführliche SID-Beschreibung finden Sie im SID-Handbuch
              von Digital Research.


[SEITE 7-116] *** CP/M-Modus *************************************************


Tabelle 7.25            CP/M 3.0: SID-Befehle


Befehl  | Format        |       Bedeutung
------------------------------------------------------------------------
        |               |
Assemble| As            |       Assembler-Befehl eingeben, s ist die
        |               |       Startadresse.
        |               |
Call    | Cs {b{,d}}    |       Sprung auf die Adresse s, b ist der Wert
        |               |       im Registerpaar BC und d der Wert im
        |               |       Registerpaar DE.
        |               |
Display | D{W}{s}{,f}   |       Speicherinhalt in HEX und ASCII
        |               |       anzeigen. Mit W kann das
        |               |       16-Bit-Wortformat angegeben werden, s
        |               |       ist die Startadresse und f die
        |               |       Endadresse.
        |               |
Load    | Edateispez    |       Ein Programm und Symboltabelle zuladen.
        | {,sym-dateispez|
        |               |
Load    | E*            |       Ein Programm und Symboltabelle zuladen.
        |  sym-dateispez|
        |               |
Fill    | Fs,f,d        |       Speicher mit einem Wert füllen, s ist
        |               |       die Startadresse, f die Endadresse und d
        |               |       ein 8-Bit-Wert zum Auffüllen.
        |               |
Go      | G{p}{,a{b}}   |       Programmausführung starten, p ist die
        |               |       Startadresse, a ist der erste und b der
        |               |       zweite Haltepunkt. Nach der
        |               |       Programmausführung erfolgt ein Warmstart
        |               |       und Sprung in CP/M.
        |               |
Hex     | Ha            |       Dezimal- und ASCII-Wert der Hexzahl a
        |               |       anzeigen.
        |               |
        | H#b           |       Hex-Wert der Dezimalzahl b anzeigen.
        |               |
        | Ha,b          |       Die Differenz und Summe der zwei
        |               |       Hexzahlen a und b berechnen und
        |               |       anzeigen.
        |               |
Input   | Ibefehl       |       CCP-Befehlszeile eingeben.


[SEITE 7-117] *** CP/M-Modus *************************************************


Tabelle 7.25            CP/M 3.0: SID-Befehle
                        (Fortsetzung)



Befehl  | Format        |       Bedeutung
------------------------------------------------------------------------
        |               |
List    | L{s}{,f}      |       8080-Befehle mnemonisch auflisten. s ist
        |               |       die Start- und f die Endadresse.
        |               |
Move    | Ms,h,d        |       Speicherinhalte zwischen der
        |               |       Startadresse s und Endadresse f ab
        |               |       Adresse d kopieren.
        |               |
Pass    | P{p{,c}}      |       Pass-Unterbrechnungs-Punkt setzen,
        |               |       entfernen oder anzeigen. p ist die
        |               |       Unterbrechungsadresse und c der
        |               |       Startwert des Ablaufzählers.
        |               |
Read    | Rdateispez{,d}|       Mit diesem Befehl wird eine Datei in den
        |               |       Speicher geladen. Wahlweise kann ein
        |               |       Versatz d eingegeben werden.
        |               |
Set     | S{W}s         |       Werte in den Speicher eingeben. Bei
        |               |       Eingabe von W wird ein 16-Bit-Wort
        |               |       erwartet. Eine ASCII-String-Eingabe kann
        |               |       nach einme '"' erfolgen.
        |               |
Trace   | T{n{,c}}      |       Programmabarbeitung in Einzelschritten.
        |               |       n ist die Anzahl der Schritte und c ist
        |               |       die Adresse für Trace-Dienstprogramme
        |               |       vom Typ UTL.
        |               |
Trace   | T{W}{n{,c}}   |       Bei Eingabe von W werden Unterprogramme
        |               |       schnell und nicht schrittweise
        |               |       abgearbeitet.
        |               |
Untrace | U{W}{n{,c}}   |       Kontrollierte, jedoch nicht schrittweise
        |               |       Abarbeitung. Parametereingabe wie bei T.


[SEITE 7-118] *** CP/M-Modus *************************************************


Tabelle 7.25                    CP/M 3.0: SID-Befehle
                                (Fortsetzung)


Befehl  | Format        |       Bedeutung
------------------------------------------------------------------------
        |               |
Value   | V             |       Anzeige der nächsten verfügbaren Adresse
        |               |       (NEXT), der End+1-Adresse der längsten
        |               |       zugeladenen Datei im 'MSZE', der
        |               |       aktuellen Adresse im
        |               |       Programmschrittzähler (PC) und der
        |               |       Endadresse des verfügbaren Speichers
        |               |       (END).
        |               |
Write   | Wdateispez{,s,f}      Schreiben der Speicherinhalte in die
        |               |       angegebene Datei von der Adresse s bis
        |               |       Adresse f.
        |               |
Examine | X{f}          |       Ansehen oder Ändern der CPU-Register. f
        |               |       ist eines der Statusregister-Bits C, E,
        |               |       I, M oder Z; r ist ein Register A, B, D,
        |               |       H, P oder S.


Beispiele:    A>SID

              SID wird in den Speicher geladen und gestartet.  Seine
              Bereitschaft zeigt das Programm mit dem Zeichen #.

              A>BEISPIEL.HEX

              Nach   dem  Laden  werden   folgende  Speicheradressen
              angezeigt:

              NEXT MSZE PC END nnnn mmmm pppp eeee

              Hierbei ist:

              nnnn  eine hexadezimale Angabe  für die  nächste freie
              Adresse nach dem zugeladenen Programm.

[SEITE 7-119] *** CP/M-Modus *************************************************

              mmmm  die  nächste  freie  Adresse nach  dem  längsten
              bisher zugeladenem  Programm (nach dem  SID-Aufruf ist
              nnnn=mmmmm),

              pppp ist die Adresse im Programmzähler, ab welcher die
              Programmabarbeitung mit  G ohne Zusatzangaben  (in der
              Regel 0100H) beginnt und

              eeee die  Endadresse des verfügbaren Benutzerspeichers
              (TPA).

              #DFE00+#128

              Das   'Doppelkreuz-Zeichen'  #  ist   die  SID-Bereit-
              schaftsmeldung,  D  ist  der  Befehl zur  Anzeige  von
              Speicherinhalten   und   FE00+#128   die  Angabe   der
              Startadresse  FE80h.   Ohne  Eingabe einer  Endadresse
              werden 12 Zeilen ausgegeben.


[SEITE 7-120] *** CP/M-Modus *************************************************


SUBMIT-Befehl

Format:       SUBMIT {dateispez} {Argument}...{Argument}

Zweck:        Mit  dem  SUBMIT-Befehl wird  eine  Datei  des Typs  SUB
              aufgerufen   und  die  darin   enthaltenen  CP/M-Befehle
              ausgeführt.  Mit einem Befehl wird eine beliebige Anzahl
              von CP/M-Befehlen und  -Programmen im Stapelmodus (batch
              mode) ausgeführt.

              Die  in  der  SUB-Datei  enthaltenen Befehle  werden  so
              ausgeführt,  als  ob sie  über  die Tastatur  eingegeben
              wären.

              Zur  Verkettung  von  Dateien,  d.h.   zur  aufeinander-
              folgenden Ausführung mehrerer  SUB-Dateien, kann mit der
              SUB-Datei wieder eine SUB-Datei aufgerufen werden.

              Argumente in  der Befehlszeile können an  die von SUBMIT
              aufgerufenen Programme über  die Übergabeparamter $1 bis
              $9 übergeben werden.   Das bedeutet, daß alle Parameter,
              die   nach  dem   SUBMIT-Aufruf   in  der   Befehlszeile
              eingegeben  sind, in  der  eingegebenen Reihenfolge  den
              Übergabeparameter $1 bis $9 zugeordnet werden.

              Wenn Sie die folgende Datei START.SUB

              ERA $1,BAK
              DIR $1
              PIP $1=A:$2.COM

              erstellen  und  SUBMIT  mit  folgender  Eingabe  in  der
              Befehlszeile aufrufen:

              >SUBMIT START SAM TEX

              dann  wird jedesmal  anstelle $1  dsas Argument  SAM und
              anstelle  $2 TEX  verwendet. Dazu  erstellt  SUBMIT eine
              $$$.SUB-Zwischendatei,  in der  die  korrekten Parameter
              eingesetzt sind.


[SEITE 7-121] *** CP/M-Modus *************************************************


              ERA SAM.BAK
              DIR SAM
              PIP SAM=A:TEX.COM

              Erst  diese  Zwischendatei   wird  von  SUBMIT  als  die
              endgültige Befehlsdatei verwendet.


[SEITE 7-122] *** CP/M-Modus *************************************************


Programmeingaben bei SUBMIT-Ausführung

              In  einer   SUB-Datei  können  auch   Eingaben  für  die
              aufgerufenen  Programme vorgegeben werden.  Jede Eingabe
              wird mit  '<' (spitze  Klammer auf) eingeleitet,  wie in
              folgender Beispielsdatei:

              PIP
              <B:=*.ASM
              <CON:=DUMP.ASM
              <
              DIR

              Die drei  Zeilen, nach dem PIP-Aufruf  sind Eingaben für
              den PIP-Befehl.  Die '<'  in der dritten  Zeile bedeutet
              <CR>.   Damit wird  PIP-Ablauf beendet  und in  CP/M zur
              Ausführung des nächsten Befehls, DIR, gesprungen.

              Wenn das ablaufende Programm weniger Eingaben als in der
              SUB-Datei   vorgesehen  verlangt,  werden   die  übrigen
              Eingaben ignoriert und SUBMIT gibt folgende Meldung aus:

              Warning: Programm input ignored

              Werden von  dem ablaufenden Programm  mehr Eingaben, als
              in  der  SUB-Datei  enthalten,  verlangt,  werden  diese
              Eingabe von der Tastatur erwartet.

[SEITE 7-123] *** CP/M-Modus *************************************************

Die SUB-Datei

              In  der  SUB-Datei  können  folgende  Daten  verwendet
              werden:

              - Jeder gültige CP/M-Befehl

              - Jeder gültige CP/M-Befehl mit SUBMIT Argumenten

              - Entsprechende Programmeingabezeilen

              - Eingabezeilen mit Parameter $1 - $9

              Auch hier  dürfen die Zeilen höchstens  128 Zeichen lang
              sein.

Beispiel:     DIR
              DIR *.BAK
              MAC $1 $$$4
              PIP LST:=$1.PRN[T$2$3$5]
              DIR *.ASM
              PIP
              <B:=*.ASM
              <CON:=DUMP.ASM
              <
              DIR B:


[SEITE 7-124] *** CP/M-Modus *************************************************


SUBMIT-Befehl ausführen

Format:       SUBMIT
              SUBMIT dateispez
              SUBMIT dateispez argument...argument

Zweck:        Wird nur  SUBMIT ohne weitere  Angaben eingegeben, fragt
              das  System nach den  restlichen Eingaben.   Dann können
              noch Dateibezeichnung und Argumente eingegeben werden.

Beispiel:     >A:SUBMIT<CR>

              Enter File to Submit: START B TEX

              Die SUB-Datei SUBA wird ausgeführt.

              >A:SUBMIT AA ZZ SZ<CR>

              AA bedeutet die SUB-Datei AA.SUB,
              ZZ wird anstelle aller $1- und
              SZ anstelle aller $2-Übergabeparamter in der
              AA.SUB-Datei verwendet.


[SEITE 7-125] *** CP/M-Modus *************************************************


Autostartdatei PROFILE.SUB

Jedesmal, wenn CP/M gestartet wird, sucht das  System nach einer SUB-Datei mit
dem Namen PROFILE.SUB  und führt sie, wenn sie  vorhanden ist, selbstätig aus.
Damit    kann   automatisch   jeder    beliebige   Programmablauf   ausgeführt
werden. Beispielsweise kann diese Datei folgenden Text beinhalten:

DATE SET

Dann  wird nach jedem   Systemstart  automatisch der  Befehl  DATE im   Dialog
ausgeführt.


[SEITE 7-126] *** CP/M-Modus *************************************************


TYPE-Befehl

Format:       TYPE {dateispez {[PAGE]} | [NO PAGE]}

Zweck:        Der  TYPE-Befehl  zeigt den  Inhalt  von ASCII-  (Text-)
              Dateien auf  dem Bildschirm an.   Die PAGE-Option stoppt
              die  Ausgabe  jedesmal  nach Darstellung  von  n-Zeilen.
              Diese  Zeilenzahl   entspricht  gewöhnlich  der  System-
              voreinstellung   auf  24   Zeilen  und   kann   mit  dem
              DEVICE-Befehl  geändert  werden.   TYPE-Ablauf kann  mit
              CTRL-C unterbrochen werden.

              Wird  NO  PAGE als  Argument  eingegeben, geschieht  die
              Ausgabe ohne Unterbrechung.

              Wird nur  TYPE ohne eine  Dateispezifikation eingegeben,
              erscheint folgende Aufforderung:

              Enter filename:

              und der Dateiname kann eingegeben werden.

              TAB-Zeichen  werden  bei   der  Ausgabe  auf  8  Spalten
              expandiert.   Mit  CTRL-S  kann  die  Ausgabe  jederzeit
              angehalten und mit CTRL-Q wieder fortgesetzt werden.

              Mit  CTRL-P  kann   die  Ausgabe  gleichzeitig  auf  dem
              Bildschirm und einem Drucker erfolgen.

Beispiele:    >A:TYPE MEINPROG.TXT<CR>

              Die  Ausgabe  des Inhalts  der  Datei MEINPROG.TXT  wird
              jedesmal nach 24 Zeilen angehalten.

              >A:TYPE B:NEUDATEI.BEI<NO PAGE><CR>

              Die  Ausgabe  der  Datei NEUDATEI.BEI  erfolgt  kontinu-
              ierlich von Laufwerk B.


[SEITE 7-127] *** CP/M-Modus *************************************************


Bemerkung:    Wird  mit  dem TYPE-Befehl  versucht,  den Inhalt  einer
              Binär-(nicht-ASCII)-Datei  auszugeben,  kann  es  zu den
              wildesten Effekten  auf dem Bildschirm  kommen, da diese
              Dateien auch die nichtdruckbaren Zeichen beinhalten.

              Der  Inhalt  solcher Dateien  kann  mit dem  DUMP-Befehl
              ausgegeben werden.


[SEITE 7-128] *** CP/M-Modus *************************************************


USER-Befehl

Format:       USER {nummer}

              Mit  dem USER-Befehl  wird der  aktuelle Benutzerbereich
              gesetzt. Nach  dem CP/M-Start ist  der Benutzerbereich 0
              voreingestellt.  Mit  dem  USER-Befehl  kann  einer  der
              Benutzerbereiche  0 bis  15 als  der  aktuelle Benutzer-
              bereich zugeordnet werden.

              CP/M  3.0 ordnet  jeder Datei  die  zugehörige Benutzer-
              bereichsnummer zu.  Gewöhnlich  kann man nur auf Dateien
              zugreifen,  die  in   dem  aktuellen  Benutzer-  bereich
              liegen.    Eine   Ausnahme   bilden   die   Dateien   im
              Benutzerbereich  0,   die  das  SYS-Attribut  zugeordnet
              haben.  Auf  diese Datieen  kann auch aus  jedem anderen
              Benutzerbereich zugegriffen werden.


Beispiele:    A>USER
              Enter User#:5
              5A>

              Nach der  Eingabe von 5  wird der Benutzerbereich  5 als
              der aktuelle Bereich zugeordnet.

              A>USER 3
              3A>

              Mit  diesem   Befehl  wird  in   den  Benutzerbereich  3
              gewechselt.


[SEITE 7-129] *** CP/M-Modus *************************************************


XREF-Befehl

Format:       XREF {d:} dateispez {$P}

Zweck:        Mit  dem  Befehl  XREF  wird  eine  Referenztabelle  der
              Varieblen  des  mit  'dateispez'  angegebenen  Programms
              erstellt.   XREF benötigt  dazu die  entsprechenden PRN-
              und SYM-Dateien, die von MAC oder RMAC erstellt wurden.

              Die  SYM-  und   PRN-Datei  müssen  den  im  'dateispez'
              angegebenen  Dateinamen haben. Die  Ausgabedatei bekommt
              die Typbezeichnung XRF.

Beispiele:    A>XREF B:MEINPROG

              In  diesem  Beispiel wird  XREF  von  Laufwerk A  aufge-
              rufen.  Verarbeitet werden  die Dateien MEINPROG.PRN und
              MEINPROG.SYM  die sich  auf der  Diskette im  Laufwerk B
              befinden müssen.  Die erzeugte Ausgabedatei MEINPROG.XRF
              wird auf die Diskette im Laufwerk B geschrieben.

              A>XREF B:MEINPROG $P

              Mit der Eingabe der Option $P erfolgt die Ausgabe direkt
              auf einem Drucker.

8. Fehlermeldungen
==================

8.1 BASIC-Fehlermedungen
------------------------

In diesem Abschnitt werden  die Fehlermeldungen der BASIC-Interpreter 2.0  und
7.0 und ihre  Fehlercodes (nur BASIC 7.0)  aufgeführt.  Zur schnelleren Orien-
tierung  werden  zunächst die  Fehlermeldungen  in alphabetischer  Reihenfolge
angegeben, anschließend nach Fehlercodes geordnet.

Jeder Fehlermeldung wird bei der Anzeige stets das  Wort ERROR (Fehler) hinzu-
gefügt.

Im C64-Modus gibt  es keine Fehlercodes und  damit auch keine  Möglichkeit der
programmierten Fehlerverarbeitung. D.h., in diesem Modus  führt ein Fehler auf
jeden Fall zum Abbruch des laufenden Programms.

Im C128-Modus kann mit Hilfe der Systemvariablen EL  und ER, der Funktion ERR$
sowie der Anweisungen  TRAP und RESUME (s. dort  in Kapitel 4.6) eine program-
mierte Fehlerverarbeitung realisiert werden.

Code   Meldung und Bedeutung

36     BAD DISK (Schlechte Diskette)
       Es wurde  entweder versucht, eine  noch nicht formatierte  Diskette mit
       dem verkürzten HEADER-Befehl  (s. dort in Kapitel 4.6)  zu löschen oder
       eine schadhafte Diskette zu formatieren.

18     BAD SUBSCRIPT (Falscher Feldindex)
       Es wird versucht,  auf  ein  Feldelement zuzugreifen, das außerhalb des
       in der entsprechenden DIM-Anweisung festgelegten Bereiches liegt.

30     BREAK (Unterbrechung)
       Die  STOP-Taste wurde  gedrückt,  um das  laufende  Programm zu  unter-
       brechen.

26     CAN'T CONTINUE (keine Fortsetzung möglich)
       Der  CONT-Befehl ist  nur  wirksam, wenn  das  Programm bereits  einmal
       gelaufen ist  und dann  unterbrochen wurde.  Während  der Unterbrechung
       darf das Programm jedoch nicht verändert werden (z.B.  durch Hinzufügen
       weiterer Zeilen).

31     CAN'T RESUME (RESUME ohne TRAP)
       Der  Interpreter findet  eine  RESUME-Anweisung,  ohne  daß  eine TRAP-
       Anweisung zur Fehlerverzweigung vorhanden ist.

5      DEVICE NOT PRESENT (Gerät nicht angeschlossen)
       Ein  Ein-/Ausgabe-Gerät wird  angesprochen, das  entweder ausgeschaltet
       oder nicht  angeschlossen ist, oder die  Pufferzuweisung für Kassetten-
       Ein-/Ausgabe ist aufgehoben.

34     DIRECT MODE ONLY (nur Direktmodus erlaubt)
       Der Interpreter  erkennt während der Abarbeitung  eines Programms einen
       Befehl oder eine Anweisung, der/die nur im Direktmodus erlaubt ist.

20     DIVISION BY ZERO (Division durch Null)
       Eine Division durch den Wert 0  ist nicht zulässig, da das Ergebnis un-
       endlich wird.

24     FILE DATA (ungültige Dateidaten)
       Es  wird  versucht,  mit einer  INPUT-Anweisung  Zeichenkettendaten von
       einer Eingabedatei einer numerischen Variablen zuzuweisen.

4      FILE NOT FOUND (Datei nicht gefunden)
       Es wird  entweder die spezifizierte  Datei auf Diskette  nicht gefunden
       oder die Bandendemarke auf Kassette wird gelesen.

3      FILE NOT OPEN (Datei nicht geöffnet)
       Es wird  eine Ein- oder  Ausgabeoperation für eine Datei  versucht, die
       vorher nicht geöffnet wurde.

2      FILE OPEN (Datei bereits geöffnet)
       Es wird versucht, mit einer logischen Dateinummer eine Datei zu öffnen,
       unter der bereits vorher eine andere Datei geöffnet wurde.

25     FORMULA TOO COMPLEX (zu komplexer Ausdruck)
       Es  wird  ein   zu  komplexer  numerischer  oder  Zeichenkettenausdruck
       gefunden. Ausdruck teilen oder weniger Klammern verwenden.

9      ILLEGAL DEVICE NUMBER (unerlaubte Geräteadresse)
       Es  wird  entweder  versucht,  eine  Ein-/Ausgabe-Operation  mit  einem
       unerlaubten Gerät oder Einheit  auszuführen (z.B. SAVE zum Bildschirm),
       oder es wird eine Geräteadresse oberhalb von 15 verwendet.

21     ILLEGAL DIRECT (unerlaubter Eingabemodus)
       Es wird versucht, mit INPUT oder GET im Direktmodus Daten einzulesen.

14     ILLEGAL QUANTITY (unerlaubter Wert)
       Ein numerisches Argument einer  Funktion oder ein numerischer Parameter
       für  einen Befehl oder  eine Anweisung  liegt außerhalb  des zulässigen
       Bereiches.

29     LOAD (Ladefehler)
       Beim Laden  eines Programms  von Kassette oder  Diskette ist  ein Lese-
       fehler  aufgetreten.  Ein  erneuter  Versuch  sollte  zunächst  gemacht
       werden.

32     LOOP NOT FOUND (DO ohne LOOP)
       Der  Interpreter findet  zu  einer vorhandenen  DO-Anweisung nicht  die
       zugehörige LOOP-Anweisung.

33     LOOP WITHOUT  DO (LOOP ohne DO)
       Der  Interpreter findet  eine LOOP-Anweisung  ohne  vorausgegangene DO-
       Anweisung.

8      MISSING FILE NAME (Dateiname fehlt)
       In  einem  Befehl  oder   einer  Anweisung  fehlt  die  vorgeschriebene
       Dateiangabe.

10     NEXT WITHOUT FOR (NEXT ohne FOR)
       Der  Interpreter  findet  eine  NEXT-Anweisung, zu  der  keine  voraus-
       gegangene FOR-Anweisung existiert.

35     NO GRAPHICS AREA (kein Grafikbereich reserviert)
       Es  wird versucht, eine  grafische Anweisung  (BOX, CIRCLE,  DRAW usw.)
       auszuführen, ohne daß  vorher mit der GRAPHIC-Anweisung Speicherbereich
       reserviert wurde.

6      NOT INPUT FILE (keine Eingabedatei)
       Es wird  versucht, mit INPUT oder  GET aus einer Datei  Daten zu lesen,
       die als Ausgabedatei geöffnet wurde.

7      NOT OUTPUT FILE (keine Ausgabedatei)
       Es wird  versucht, mit PRINT oder  CMD Daten in  eine Datei auszugeben,
       die als Eingabedatei geöffnet wurde.

13     OUT OF DATA (nicht genug Daten)
       Es wird versucht,  mit der READ-Anweisung  mehr Daten  zu lesen, als in
       DATA-Zeilen deklariert sind.

16     OUT OF MEMORY (Speicherüberlauf)
       Entweder  reicht der  Speicher für  das  Programm nicht  aus, oder  der
       Stapelspeicher  ist  wegen  zuvieler  aktiver  DO-,  FOR-  oder  GOSUB-
       Anweisungen übergelaufen.

15     OVERFLOW (Überlauf)
       Das Ergebnis einer Berechnung übersteigt den größten darstellbaren Wert
       (1.701411833E+38).

19     REDIM'D ARRAY (mehrfache Felddimensionierung)
       Feldvariablen  dürfen  in  BASIC  nur ein  einziges  Mal  dimensioniert
       werden.

12     RETURN WITHOUT GOSUB (RETURN ohne GOSUB)
       Der  Interpreter findet  eine  RETURN-Anweisung, zu  der keine  voraus-
       gegangene GOSUB-Anweisung existiert.

23     STRING TOO LONG (zu lange Zeichenkette)
       Zeichenketten dürfen beim Commodore-BASIC  nur maximal 255 Zeichen lang
       sein.

11     SYNTAX (Syntaxfehler)
       Ein BASIC-Befehl, eine  BASIC-Anweisung, -Funktion oder -Systemvariable
       ist falsch geschrieben oder es fehlt eine Klammer, ein Komma o.ä.

1      TOO MANY FILES (zu viele offene Dateien)
       Im  Commodore-BASIC  sind  maximal  10 gleichzeitig  geöffnete  Dateien
       erlaubt.

22     TYPE MISMATCH (fehlende Variablentyp-Übereinstimmung)
       Es  wird  eine numerische  Variable  verwendet,  wo nur  Zeichenketten-
       variablen erlaubt sind oder umgekehrt.

17     UNDEF'D STATEMENT (nichtdefinierte Zeilennummer)
       Es  wird auf  eine Zeilennummer  Bezug genommen,  die in  dem laufenden
       Programm nicht existiert.

27     UNDEFINED FUNCTION (nichtdefinierte Funktion)
       Eine anwenderspezifische Funktion wird  verwendet, die vorher nicht mit
       DEF FN definiert wurde.

28     VERFIY (Programm-Verifizierungsfehler)
       Ein mit  Hilfe des VERIFY-Befehls ausgeführter  Vergleich des Programms
       im  Hauptspeicher mit  dem  entsprechenden Programm  auf Kassette  oder
       Diskette ist nicht erfolgreich.

BASIC-FEHLERMELDUNGEN, GEORDNET NACH FEHLERCODES

Code   Meldung                     Code   Meldung

 1     TOO MANY FILES              19     REDIM'D ARRAY
 2     FILE OPEN                   20     DIVISION BY ZERO
 3     FILE NOT OPEN               21     ILLEGAL DIRECT
 4     FILE NOT FOUND              22     TYPE MISMATCH
 5     DEVICE NOT PRESENT          23     STRING TOO LONG
 6     NOT INPUT FILE              24     FILE DATA
 7     NOT OUTPUT FILE             25     FORMULA TOO COMPLEX
 8     MISSING FILE NAME           26     CAN'T CONTINUE
 9     ILLEGAL DEVICE NUMBER       27     UNDEFINED FUNCTION
10     NEXT WITHOUT FOR            28     VERIFY
11     SYNTAX                      29     LOAD
12     RETURN WITHOUT GOSUB        30     BREAK
13     OUT OF DATA                 31     CAN'T RESUME
14     ILLEGAL QUANTITY            32     LOOP NOT FOUND
15     OVERFLOW                    33     LOOP WITHOUT DO
16     OUT OF MEMORY               34     DIRECT MODE ONLY
17     UNDEF'D STATEMENT           35     NO GRAPHICS AREA
18     BAD SUBSCRIPT               36     BAD DISK


8.2 FLOPPY-DISK-FEHLERMELDUNGEN
-------------------------------

In diesem Abschnitt werden die Fehlermeldungen des Floppy-Disk-Betriebssystems
(DOS) aufgeführt und beschrieben.  Der Text der Fehlermeldung sowie Fehlercode
können im C128-Modus  mit Hilfe der der Systemvariablen  DS$ und  DS abgefragt
und angezeigt werden. Da der  Fehlercode generell Bestandteil des Fehlertextes
ist, wird auf eine alphabetische Anordnung verzichtet.

Fehlercodes  unter 20 können ignoriert werden.   Ausnahme ist der Code 01, der
der Meldung  über  gelöschte Dateien,  die  vom DOS  nach  der  Ausführung des
SCRATCH-Befehl bereitgestellt wird, vorangesetzt ist.

Bei allen Meldungen mit Codes von 20 oder darüber bedeutet die erste Zahl nach
der Meldung  ('tt') die Nummer der Disketten-Spur  und die  zweite Zahl ('ss')
die Nummer des Sektors in dieser Spur, bei der/dem der Fehler aufgetreten ist.
Bei  der Meldung 01 bedeutet  die erste Zahl nach  der Meldung  die Anzahl der
gelöschten Dateien. Die zweite Zahl ist hier immer 00.


Code   Meldung und Bedeutung
01     FILES SCRATCHED,nn,00 (Dateien gelöscht)
       Es wurden 'nn' Dateien gelöscht.

20     READ ERROR,tt,ss (Lesefehler)
       Das DOS kann für den angegebenen Diskettensektor die Blockkennung nicht
       identifizieren. Dies  kann durch eine nicht  erlaubte Sektornummer oder
       durch eine zerstörte Blockkennung verursacht werden.

21     READ ERROR,tt,ss (Lesefehler)
       Das DOS kann für  die angegebene Diskettenspur den Synchronisationscode
       nicht  identifizieren.  Dies  kann  durch fehlerhafte  Einstellung  des
       Schreib/Lese-Kopfes,  eine unformatierte  oder  eine falsch  eingelegte
       Diskette verursacht werden.

22     READ ERROR,tt,ss (Lesefehler)
       Das DOS kann den  angegebenen Datenblock nicht lesen oder verifizieren,
       da  dieser nicht  korrekt  geschrieben wurde.  Dieser  Fehler tritt  im
       Zusammenhang  mit den  Blockbefehlen  für Direktzugriff  auf weist  auf
       einen ungültigen Sektorzugriff hin.

23     READ ERROR,tt,ss (Lesefehler)
       Das DOS findet beim Lesen  des angegebenen Sektors Fehler in einem oder
       mehreren Datenbytes durch eine  ungültige Prüfsumme. Diese Meldung kann
       auch auf Erdungsprobleme bei der Floppy-Disk deuten.

24     READ ERROR,tt,ss (Lesefehler)
       Das DOS  findet beim  Lesen der Daten  im angegebenen  Sektor ungültige
       Bit-Muster und  generiert deshalb einen  Hardware-Fehler. Diese Meldung
       kann auch auf Erdungsprobleme bei der Floppy-Disk deuten.

25     WRITE ERROR,tt,ss (Schreibfehler)
       Das  DOS  findet  nach  dem  Schreiben des  angegebenen  Sektors  keine
       Übereinstimmung der geschriebenen Daten  mit den Daten im Schreibpuffer
       (read-after-write check).

26     WRITE PROTECT ON,tt,ss (Schreibschutz aufgeklebt)
       Das DOS  kann auf die  Diskette im bezogenen Laufwerk  nicht schreiben,
       weil die Schreibschutzlasche aufgeklebt ist.

27     READ ERROR,tt,ss (Lesefehler)
       Das DOS  findet in  der Blockkennung für  den angegebenen  Sektor einen
       Prüfsummenfehler.

28     WRITE ERROR,tt,ss (Schreibfehler)
       Das DOS kann den angegeben Sektor wegen Überlänge nicht schreiben.

29     DISK ID MISMATCH,tt,ss (Keine Diskettenkennungs-Übereinstimmung)
       Das  DOS versucht,  auf eine  Diskette zuzugreifen,  die noch  nicht im
       Laufwerk initialisiert  wurde.  Dieser  Fehler tritt auch  bei unleser-
       licher Diskettenkennung auf.

30     SYNTAX ERROR,00,00 (Syntaxfehler)
       Der über  den Befehlskanal an  die Floppy-Disk übertragene  Befehl kann
       vom  DOS  nicht interpretiert  werden  (z.B.  fehlerhafte Parameter  im
       Befehl).

31     SYNTAX ERROR,00,00 (Syntaxfehler)
       Der an  die Floppy-Disk übertragene Befehl ist  ungültig.  Die Befehls-
       kennung muß das erste Zeichen in der Befehlszeichenkette sein.

32     SYNTAX ERROR,00,00 (Syntaxfehler)
       Der an die Floppy-Disk übertragene Befehl ist länger als 58 Zeichen.

33     SYNTAX ERROR,00,00 (Syntaxfehler)
       In  einer  OPEN-  oder   DOPEN-Anweisung  oder  bei  einem  SAVE-  oder
       DSAVE-Befehl   wurden  verbotenerweise  die   Jokerzeichen  ?   oder  *
       (s. Kapitel 6.3) verwendet.

34     SYNTAX ERROR,00,00 (Syntaxfehler)
       In  einem Befehl  oder einer  Anweisung fehlt  der Dateiname  oder kann
       nicht als solcher identifiziert werden.

35     SYNTAX ERROR,00,00 (Syntaxfehler)
       Wie Fehler 31.

50     RECORD NOT PRESENT,tt,ss (logischer Datensatz nicht vorhanden)
       Entweder wird  versucht, mit  GET# oder INPUT#  über das  logische Ende
       einer Datei hinaus  zu lesen, oder es wird  versucht, den Lesezeiger in
       einer Relativdatei  mit der  RECORD-Anweisung hinter das  logische Ende
       der Datei zu  positionieren. Wenn jedoch damit die  Datei in Verbindung
       mit  einer anschließenden PRINT-Anweisung  erweitert werden  soll, kann
       diese  Meldung  ignoriert  werden.  Nach dieser  Meldung  sollten  ohne
       vorherige  Neupositionierungen die Anweisungen  GET# oder  INPUT# nicht
       verwendet werden.

51     OVERFLOW IN RECORD,tt,ss (zu langer Satz)
       Es wird versucht, mit PRINT# einen logischen Datensatz in eine Relativ-
       datei  zu  schreiben, dessen  Länge  einschließlich des  abschließenden
       Wagenrücklaufcodes  die  in  der DOPEN-Anweisung  angegebene  Satzlänge
       überschreitet.

52     FILE TOO LARGE,tt,ss (Datei zu groß)
       Bei   der  Ausführung   einer  RECORD-Anweisung   zur  Dateierweiterung
       diagnostiziert  DOS  nicht   mehr  ausreichend  Speicherplatz  auf  der
       Diskette.

60     WRITE FILE OPEN,tt,ss (Ausgabedatei offen)
       Eine  nicht  korrekt geschlossene  Ausgabedatei  kann  nicht zum  Lesen
       geöffnet werden.

61     FILE NOT OPEN,tt,ss (Datei nicht göffnet)
       Es  wird   versucht,  auf  eine  nicht   geöffnete  Datei  zuzugreifen.
       Gelegentlich wird  diese Meldung  nicht generiert und  der Dateizugriff
       vielmehr von DOS einfach ignoriert.

62     FILE NOT FOUND,tt,ss (Datei nicht gefunden)
       Auf der angegebenen Diskette findet das DOS die angegebene Datei nicht.

63     FILE EXISTS,tt,ss (Datei existiert bereits)
       Es  wird  versucht,  auf  der  Diskette im  angegebenen  Laufwerk  eine
       Ausgabedatei  unter  einem Namen  einzurichten,  der  bereits für  eine
       existierende Datei verwendet wurde.

64     FILE TYPE MISMATCH,tt,ss (keine Dateityp-Übereinstimmung)
       Es  wird  versucht,  auf  der  Diskette im  angegebenen  Laufwerk  eine
       existierende Datei unter einem Dateityp  zu eröffnen, der nicht mit dem
       auf der Diskette vermerkten Typ übereinstimmt.

65     NO BLOCK,tt,ss (Block bereits belegt)
       Es wird versucht, mit dem DOS-Befehl B-A (block allocate) einen bereits
       reservierten Block zu  reservieren. Bei dieser Meldung geben  tt und ss
       den nächst  höheren freien  Block auf der  Diskette an. Sind  beide 00,
       dann sind alle Blöcke mit höheren Disk-Adressen belegt.

66     ILLEGAL TRACK OR SECTOR,tt,ss (Spur und Sektor ungültig)
       DOS  hat versucht,  auf eine  Spur oder  einen Sektor  zuzugreifen, die
       nicht mit  dem aktuellen Format übereinstimmen. Dies  kann auf Probleme
       beim Lesen des Disk-Adreßzeigers hindeuten.

67     ILLEGAL SYSTEM T OR S,tt,ss (Systemspur oder Systemsektor ungültig)
       Das  DOS diagnostiziert  einen Formatfehler  bei einer  Systemspur oder
       einem Systemsektor.

70     NO CHANNEL,tt,ss (Kein Datenpuffer frei)
       Beim Öffnen einer Datei kann  DOS keinen Datenpuffer mehr zuordnen. Zur
       gleichen Zeit kann das DOS  nur maximal 5 offene sequentielle, 3 offene
       Relativ-Dateien oder 6 Direktzugriffskanäle verwaltet.

71     DIRECTORY ERROR,tt,ss (Fehler im Diskettenverzeichnis)

       Die auf  der angegebenen Diskette gespeicherte  BAM (block availability
       map =  Verzeichnis der belegten  und freien Sektoren) stimmt  nicht mit
       der  vom  DOS im  Arbeitspeicher  für  diese  Diskette verwalteten  BAM
       überein. Die Diskette sollte mit

       OPEN 15,8,15,"I"

       erneut   initialisiert  werden.    Geöffnete  Dateien   können  dadurch
       möglicherweise geschlossen werden.

72     DISK FULL,tt,ss (Diskette voll)
       Entweder sind  alle verfügbaren  Sektoren auf der  angegebenen Diskette
       belegt oder das Verzeichnis hat  keinen Platz mehr für weitere Einträge
       (144 maximal).

73     DOS MISMATCH,tt,ss (falsche DOS-Version)
       Die  Versionen  1  und  2  des  DOS  sind  lese-  aber  nicht  schreib-
       kompatibel.   Diese Meldung  wird immer  dann generiert,  wenn versucht
       wird, auf eine  Diskette zu schreiben, die mit  einem DOS einer anderen
       Version  formatiert  wurde.   Außerdem  kann  diese  Meldung  nach  dem
       Einschalten angezeigt werden.

74     DRIVE NOT READY,tt,ss (Laufwerk nicht bereit)
       Es  wird   versucht,  auf   ein  Laufwerk  ohne   eingelegte  Disketten
       zuzugreifen.

*********************************************
*     [ANHANG A]:                           *
*                                           *
*     Zeichencode-Tabellen, Steuercodes     *
*********************************************

[SEITE A-1 * ZEICHENCODE-TABELLEN]

ASCII UND CHR$ CODES

  Dieser Anhang zeigt für alle x, welches Zeichen auf dem Bildschirm er-
scheint, wenn Sie PRINT CHR$(x) senden. Umgekehrt können Sie auch das Ergebnis
für PRINT ASC("x") entnehmen, wobei "x" der zugehörigen gedrückten Taste ent-
spricht. Dies ist besonders nützlich, um das in einem GET Statement empfangene
Zeichen zu ermitteln, zwischen Groß- und Kleinschrift umzuschalten und um
nicht druckbare Steuerzeichen, wie etwa Umschaltung Groß-/Kleinschrift zu
senden, die nicht in einem String zwischen Anführungszeichen eingeschlossen
werden können.

Zeichen      CHR$         Zeichen CHR$| Zeichen CHR$ | Zeichen CHR$
--------------------------------------+--------------+-------------
              0        {CRSR-DOWN} 17 |    "     34  |    3     51
              1         {RVS-ON}   18 |    #     35  |    4     52
              2        {CLR-HOME}  19 |    $     36  |    5     53
              3        {INST-DEL}  20 |    %     37  |    6     54
              4                    21 |    &     38  |    7     55
   {WHT}      5                    22 |    '     39  |    8     56
              6                    23 |    (     40  |    9     57
              7                    24 |    )     41  |    :     58
blockiert
{SHIFT}{C=}   8                    25 |    *     42  |    ;     59
entriegelt
{SHIFT}{C=}   9                    26 |    +     43  |    <     60
             10                    27 |    ,     44  |    =     61
             11           {RED}    28 |    -     45  |    >     62
             12       {CRSR-RIGHT} 29 |    .     46  |    ?     63
{RETURN}     13           {GRN}    30 |    /     47  |    @     64
Umschaltung
Kleinbuchst. 14           {BLU}    31 |    0     48  |    A     65
             15          {SPACE}   32 |    1     49  |    B     66
             16             !      33 |    2     50  |    C     67

[SEITE A-2 * ZEICHENCODE-TABELLEN]

Zeichen      CHR$     Zeichen     CHR$     Zeichen   CHR$     ZEICHEN   CHR$
----------------------------------------------------------------------------
   D         68       {GRAFIK}     97        {PI}    126                155
   E         69       {GRAFIK}     98      {GRAFIK}  127      {PUR}     156
   F         70       {GRAFIK}     99                128     {CRSR LEFT}157
   G         71       {GRAFIK}    100                129      {YEL}     158
   H         72       {GRAFIK}    101                130      {CYN}     159
   I         73       {GRAFIK}    102                131      {SPACE}   160
   J         74       {GRAFIK}    103                132     {GRAFIK}   161
   K         75       {GRAFIK}    104        {f1}    133     {GRAFIK}   162
   L         76       {GRAFIK}    105        {f3}    134     {GRAFIK}   163
   M         77       {GRAFIK}    106        {f5}    135     {GRAFIK}   164
   N         78       {GRAFIK}    107        {f7}    136     {GRAFIK}   165
   O         79       {GRAFIK}    108        {f2}    137     {GRAFIK}   166
   P         80       {GRAFIK}    109        {f4}    138     {GRAFIK}   167
   Q         81       {GRAFIK}    110        {f6}    139     {GRAFIK}   168
   R         82       {GRAFIK}    111        {f8}    140     {GRAFIK}   169
   S         83       {GRAFIK}    112 {SHIFT}{RETURN}141     {GRAFIK}   170
   T         84       {GRAFIK}    113 Umsch.Großbuch.142     {GRAFIK}   171
   U         85       {GRAFIK}    114                143     {GRAFIK}   172
   V         86       {GRAFIK}    115        {BLK}   144     {GRAFIK}   173
   W         87       {GRAFIK}    116      {CRSR UP} 145     {GRAFIK}   174
   X         88       {GRAFIK}    117      {RVS OFF} 146     {GRAFIK}   175
   Y         89       {GRAFIK}    118     {CLR HOME} 147     {GRAFIK}   176
   Z         90       {GRAFIK}    119     {INST DEL} 148     {GRAFIK}   177
   [         91       {GRAFIK}    120                149     {GRAFIK}   178
 {PFUND}     92       {GRAFIK}    121                150     {GRAFIK}   179
   ]         93       {GRAFIK}    122                151     {GRAFIK}   180
   ^         94       {GRAFIK}    123                152     {GRAFIK}   181
{PFEIL-LINKS}95       {GRAFIK}    124                153     {GRAFIK}   182
{GRAFIK}     96       {GRAFIK}    125                154     {GRAFIK}   183

[SEITE A-3 * ZEICHENCODE-TABELLEN]

Zeichen      CHR$     Zeichen     CHR$     Zeichen   CHR$     ZEICHEN   CHR$
----------------------------------------------------------------------------
{GRAFIK}      184      {GRAFIK}    186     {GRAFIK}  188       {GRAFIK} 190
{GRAFIK}      185      {GRAFIK}    187     {GRAFIK}  189       {GRAFIK} 191

Codes     192-233        wie Codes     96-127
Codes     224-254        wie Codes    160-190
Code      255            wie Code     126
***************************************************
*     [ANHANG B]:                                 *
*                                                 *
*     Speicherorganisation                        *
*                                                 *
*     B.1.1 Einführung                            *
*     B.1.2 C128-Speicherorganisation             *
*     B.1.3 C128-ROM-Organisation                 *
*     B.1.4 RAM-Speicherorganisation              *
*     B.1.5 Anordnung von MMU und                 *
*           Ein-/Ausgabebereich im Speicher       *
*     B.2   Beschreibung der MMU-Register         *
*     B.2.1 Das Konfigurations-Register           *
*     B.2.2 Der Präkonfigurations-Mechanismus     *
*     B.2.3 Das Modus-Konfigurations-Register     *
*     B.2.4 Das RAM-Konfigurations-Register       *
*     B.2.5 Die Speicherseiten-Zeiger             *
*     B.2.6 Das System-Versions-Register          *
***************************************************

[SEITE B-1 * SPEICHERVERWALTUNG (MMU)]

ANHANG B: DIE SPEICHERVERWALTUNG MIT DER MMU

B.1.1 EINFÜHRUNG

Die Speicher-Verwaltungseinheit (Memory Management Unit- MMU) wurde entworfen,
um die komplexen Vorgänge im C128-System zu kontollieren. Sie wickelt alle
C64-Operationen im C64-Modus ab, ist also absolut kompatibel zum C64. Zusätz-
lich kontrolliert die MMU die Organisation spezieller C128-Operationen ein-
schließlich des CP/M-Modus (Z80-Prozessor).

Hier eine kurze Zusammenfassung der MMU-Merkmale:

1.   Bereitstellung und Verwaltung eines umgesetzten Adreßbusses
     (Translated-Adress-Bus TA8 - TA15).

2.   Bereitstellung und Verwaltung der drei verschiedenen Betriebsmodi
     (C128 - C64 - CP/M).

3.   Bereitstellung und Verwaltung der CAS-Auswahl-Leitungen für die
     RAM-Speicherbankumschaltung.

B.1.2 C128-SPEICHERORGANISATION

Die Speicherorganisation wird durch spezielle Register der MMU kontrolliert.
Diese Register steuern das Umsetzen der Adressen des 8502-Prozessors. Dabei
werden 64 kByte Adreßraum in bis zu 1 MByte RAM umgesetzt und verwaltet.

Weiterhin sind bis zu 96 kByte interner ROM und 32 kByte externer ROM im
C128-System verfügbar.

In Bild B.1 auf der folgenden Seite ist die Speicherorganisation des C128 für
den C64- und den C128-Modus zusammengefaßt:

[SEITE B-2 * SPEICHERVERWALTUNG (MMU)]

                     Bild B.1: C128 Memory Belegung

    Interne/Externe  C-64          C-128          RAM Bank 0  RAM Bank 1
         ROMs        Modus         Modus
                               .==============.
                              /              /|
$FF00 .========.-.=========.-/==============/||--.=========.-.=========.
$FC00 |        |-| Kernal  |-| Kernal       |||--| 1k gem. |-|         |\
      | Spiele-| | (40-Zei-| | (Maschinen-  |||  | Bereich | |         | \
$F000 | ROM    |-| chen-   |-| spr. Monitor)|||--| 4k gem. |-|         |  |
      |        | | Editor  | |              |||  | Bereich | |         |  |
$E000 `========'-|=========|-|==============|||--| 8k gem. |-|         | HIGH
                 | I/O und | | I/O und      |||  | Bereich | |         | Be-
                 | Charac- | | Character-   |||  |         | |         | reich
                 | ter-ROM | | ROM          |||  |         | |         |  |
$D000 -----------`========='-|==============|||--|         |-|         |  |
                             | 40/80-Zei-   |||  |         | |         | /
                             | chen-Editor  |||  |         | |         |/
$C000 .========.-.=========.-|==============|||--| 16k gem.|-|         |
      | Inter- | | BASIC   | |              |||  | Bereich | |         |\
      | preter-| | V2.0    | |              |||  |         | |         | \
      | ROM    | |         | |              |||  |         | |         | MID-
$A000 |========|-`========='-|  BASIC-HIGH  |||  |         | |         | Be-
      | Erwei- |             |     V7.0     |||  |         | |         | reich
      | rungs- |             |              |||  |  64K    | |   64K   | /
      | ROM    |             |              |||  |  RAM    | |   RAM   |/
$8000 `========'-------------|==============|||--| BASIC-  |-|Variablen|
                             |              |||  |  Text   | |         |\
                             |              |||  |         | |         | \
                             |  BASIC-LOW   |||  |         | |         | LOW-
$6000 -----------------------|              |||  |         | |         | Be-
                             |     V7.0     |||  |         | |         | reich
                             |              ||/  |         | |         | /
                             |              |/   |         | |         |/
$4000 -----------------------`==============/  --| 16k gem.|-|         |
                                              |  | Bereich | |         |
                                             ||  |         | |         |
            (Ebene 2) Function-ROM intern ---'|  |         | |         |
            (Ebene 3) Function-ROM extern ----'  |         | |         |
                                                 |         | |         |
$2000 -------------------------------------------| 8k gem. |-|         |
                                                 | Bereich | |         |
$1000 -------------------------------------------| 4k gem. |-|         |
                                                 | Bereich | |         |
$0400 -------------------------------------------| 1k gem. |-|         |
                                                 | Bereich | |         |
$0002 -------------------------------------------|=========|-|=========|
                                                 | 8502    | | 8502    |
                                                 | I/O Port| | I/O Port|
$0000 -------------------------------------------`========='-`========='

[SEITE B-3 * SPEICHERVERWALTUNG (MMU)]

B.1.3 C128-ROM-Organisation

Der C128-Modus ist immer nach dem Einschalten oder nach einem Systemreset
aktiv. Dieser Modus wird durch ein Bit im MMU-Konfigurations-Register kontrol-
liert. Im C128-Modus beansprucht die MMU den Speicherbereich ab Adresse $FFOO
und im Ein/Ausgabe (I/O)-Bereich den Platz ab Adresse $D500. Die Benutzung der
MMU-Register, die ab $FFOO angelegt sind, erlaubt die Speicherverwaltung ohne
Beanspruchung der Register im I/O-Bereich und gewährleistet damit ein Minimum
an Speicherplatzverlust. Im C64-Modus belegen die MMU-Register keinen Spei-
cherplatz, obwohl die MMU immer noch von der Hardware für die Speicherverwal-
tung benutzt wird.

Die ROMs im C64-Modus entsprechen denen des Commodore 64. Das interne BASIC
und das Betriebssystem des C128 versorgen den C64-Modus mit dem normalen
Commodore 64 Betriebssystem. Dazu wird ein Teil des ROMs, der im C128-Modus
verwendet wird, dupliziert.

Im C128-Modus stehen bis zu 48 kByte Systemsoftware zur Verfügung. Wieviel
davon genutzt wird, wird durch geeignete Steuer-Software be- stimmt. Da nicht
benötigte Teile des Betriebssystems einfach weggeschaltet werden, ist ein
schnellerer Zugriff auf den dahinterliegenden RAM möglich.

Die in der Speicheraufteilung nach Bild B.1 erwähnten externen ROMs werden im
C64-Modus verwendet und gehorchen den C64-Regeln in bezug auf Speicherum-
schaltung, d.h. Steckmodule schalten sich selbst über die EXROM- und GAME-
Steuerleitungen ein.

Externe ROMs im C128-Modus gehorchen den Regeln ähnlich dem TED-Schema für
ROM-Umschaltung, d.h. sie werden bei der Systeminitialisierung abgefragt, um
zu prüfen, ob sie vorhanden sind und mit welcher Priorität sie zugeschaltet
werden.

Diese Methode ist weitaus flexibler als eine verdrahtete ROM-Austauschmethode,
denn Betriebssystem- und BASIC-ROM können von einem Anwenderprogramm gegen
anwenderspezifische ROMs getauscht oder auch ganz einfach weggeschaltet
werden. Eine solche Speichermanipulation wird durch Beschreiben des MMU-
Konfigurations-Registers bei der Adresse $D500 oder $FFOO erreicht.

Die Hardware hat die Fähigkeit, die vorher eingegebenen Werte für eine be-
stimmte Konfiguration zu speichern und erzwingt das Laden des Konfigurations-
Registers, in dem eines der Lade-Konfigurations-Register (LCR)

[SEITE B-4 * SPEICHERVERWALTUNG (MMU)]

beschrieben wird. Dies erlaubt dem Programmierer z.B. dadurch jederzeit Zugang
zu einer RAM-Speicherbank zu haben, daß ein ROM in dieser Speicherbank durch
Voreinstellung nicht eingeschaltet wird.


B.1.4 RAM-SPEICHERORGANISATION

Wir beziehen uns nochmals auf das Bild B.1 (C128-Speicherorganisation). Für
den vorhandenen RAM-Bereich von 128 kByte werden dynamische Speicherbausteine
verwendet. Dieser RAM-Bereich wird in zwei Speicherbänke von je 64 kByte ein-
geteilt (64 kByte ist der maximale Adreßraum, den die 8502- und Z80-Prozes-
soren adressieren können). Zwischen den Speicherbänken kann umgeschaltet
werden.

Der als RAM gekennzeichnete Bereich ist der Speicher, den der Mikroprozessor
"sieht", wenn alle ROMs weggeschaltet sind.

Die Speicherbankumschaltung kann auf zwei verschiedene Weisen vorgenommen
werden.

Die aktuelle Speicherbank ergibt sich aus dem Wert, der im Konfigurations-
Register gespeichert ist. (Es gibt noch andere Speicher-Modi, die sich über
die gerade eingeschaltete Bank hinwegsetzen. Diese Modi werden in einem
späteren Abschnitt behandelt.) Eine Änderung dieses Registers wirkt sich immer
sofort und direkt aus. Ein indirektes Benutzen dieser Register mit program-
mierten Bank-Konfigurationswerten besteht im Beschreiben eines der indirekten
Lade-Register (LCR - Load Configuration Register).

Die LCR-Register sind im Speicherbereich ab der Adresse $FFOO angelegt. Durch
Beschreiben eines der LCRs wird der Inhalt des mit ihm korrespondierenden PCRs
(Prä-Konfigurations-Register) in das Konfigurations-Register übertragen (es
wird in das Konfigurations-Register geODERt). Auf diese Weise kann der
Programmierer bis zu 4 verschiedene vorprogammierte Zustände einstellen.

So könnte z.B. Bank 1 eine Datenbank sein, also ein reiner RAM-Bereich ohne
zugeschalteten ROM oder Ein-/Ausgabe-Bereich, während in Bank 0 das System-ROM
und der Ein-/Ausgabebereich durch Voreinstellung eingeschaltet sind.

Wenn man in einer 64-kByte-Bank arbeitet, ist es manchmal wünschenswert,
Daten in der Bank 1 zu hinterlegen, aber dennoch das System-RAM

[SEITE B-5 * SPEICHERVERWALTUNG (MMU)]

(Stack, Zero Page, Bildschirm) zu behalten. Für diesen Zweck ist die MMU in
der Lage, einen gemeinsamen RAM-Bereich bereitzustellen.

Dieser RAM-Bereich kann zu- oder abgeschaltet werden. Er ist in seiner Größe
veränderbar und kann programmiert am Anfang oder am Ende einer Bank angelegt
werden. Der gemeinsame RAM-Bereich kann aber auch aufgeteilt werden, und ein
Teil kann am Anfang und der andere Teil am Ende der Bank stehen.

Die Größe eines gemeinsamen RAM-Bereiches wird durch die Bits 0 und 1 im RAM-
Konfigurations-Register (RCR) bestimmt. Wenn beide Bits = 0 sind, sind
1 kByte, ist Bit 0 = 1 und Bit 1 = 0 sind 4 kByte, ist Bit 0 = 0 und Bit 1 = 1
sind 8 kByte und sind beide Bit = 1, sind 16 kByte als gemeinsamer Bereich
eingeschaltet.

Ist Bit 2 des RCRs gesetzt, wird der gemeinsame Bereich am unteren Ende des
RAM-Bereiches, ist Bit 3 im RCR gesetzt, am oberen Ende des RAM-Bereiches
angelegt. In allen Fällen ist der gemeinsame Speicherbereich physikalisch ein
Bestandteil der Speicherbank 0.

Die ersten 512 Bytes des Speichers (Zero Page (P0) und Stapelspeicher (P1))
können unabhängig vom RCR im gesamten Adreßraum angeordnet werden. Wenn der
Prozessor eine Adresse der Zero Page oder des Stapelspeichers anwählt, addiert
die MMU den Inhalt des PO- oder des P1-Registerpaares auf die Adesse und legt
die neue, erweiterte Adresse (Adressenbits A16 und A17) auf den Bus. Dabei
kann natürlich eine Speicherumschaltung (RAM Banking) vorkommen. Wenn die PO-
bzw. P1-Register beschrieben werden, werden sie solange zwischengespeichert
bis das niederwertige Byte im PO-Register beschrieben wird. Dadurch werden
vorzeitige Änderungen der Systemkonfiguration oder ungültige Systemzustände
vermieden.

Gleichzeitig werden Zero Page und Stapelspeicher mit dem Speicher vertauscht,
der beide ersetzt hat, wenn der Prozessor eine Adresse verwendet, die inner-
halb des durch die PO- oder P1-Register bezeichneten Bereiches liegt.

Es ist jedoch zu beachten, daß bei einem System-Reset die Zeiger auf die tat-
sächliche Zero Page und den tatsächlichen Stapelspeicher gesetzt werden.

[SEITE B-6 * SPEICHERVERWALTUNG (MMU)]

Der VIC-Baustein kann durch 2 Bits im MMU-RAM-Konfigurations-Register adres-
siert werden. Das Register steuert die Adressleitungen A16 und A17 und erlaubt
damit, den VIC-Baustein beliebig innerhalb eines 256-kByte-Bereiches zu
plazieren.

Anmerkung: Die Address-Enable-Control (AEC)-Leitung wird von der MMU benutzt,
um den VIC-Adreßraum zu steuern, d.h., wenn AEC = 0 ist, kann der VIC-Baustein
adressiert werden.

Dies bedeutet, daß ein von außen gesteuerter direkter Speicherzugriff (DMA),
der auch auf die AEC-Leitung einwirkt und die Leitung ebenfalls nach logisch
Null zieht, den VIC-Baustein ansprechen kann.

B.1.5 Anordnung von MMU und Ein-/Ausgabebereich im Speicher

Der in Bild B.2 gezeigte Ein-/Ausgabe-Speicherbereich (I/O-Bereich) ist
eine vergrößerte Darstellung des in Bild B.1 als "I/O und Character ROM"
gekennzeichneten Bereiches.

Wenn der I/O-Bereich zugeschaltet ist, können VIC, SID, alle sonstigen
Ein-/Ausgabeeinrichtungen sowie die zusätzlich eingefügten MMU-Regi-
ster angesprochen werden. Alle I/O-Funktionen sind an der Stelle verblie-
ben, wo sie beim C64 waren mit Ausnahme der MMU, die hinzugefügt wurde.

Mit Ausnahme von 4 Registern, die beim C128-Modus in der Zero Page
angeordnet wurden, sind die neuen MMU-Register bei ungenutzten Adres-
sen des I/O-Bereichs angelegt.

[SEITE B-7 * SPEICHERVERWALTUNG (MMU)]

                Bild B.2: Adressen der I/O Bausteine

                          .---------------------------------------.
                         /                                       /|
                        /                                       / |
       $DFFF-----------/---------------------------------------/ /|
                       |                 I/02                  |/ |
       $DF00-----------|---------------------------------------' /|
                       |                 I/01                  |/ |
       $DE00-----------|---------------------------------------' /|
                       |                CIA#2                  |/ |
       $DD00-----------|---------------------------------------' /|
                       |                CIA#1                  |/ |
       $DC00-----------|---------------------------------------'  |
                       |                                       |  |
                       |                                       |  |
                       |               Farb RAM                |  |
                       |                                       | /|
                       |                                       |/ |
       $D800-----------|---------------------------------------' /|
                       |             (Reserviert)              |/ |
       $D700-----------|---------------------------------------'  |
                       |                8563                   | /|
                       |       (80 Zeichen Video Chip)         |/ |
       $D600-----------|---------------------------------------'  |
                       |                MMU                    | /|
                       |       (Memory management unit)        |/ |
       $D500-----------|---------------------------------------'  |
                       |                SID                    | /|
                       |            (Sound Chip)               |/ |
       $D400-----------|---------------------------------------'  |
                       |                                       |  |
                       |                                       |  |
                       |                VIC                    |  |
                       |       (Video Chip 40-Zeichen)         |  |
                       |                                       | /
                       |                                       |/
       $D000-----------`---------------------------------------'
                                I/0 Bereich

B.2 Beschreibung der MMU-Register

Bild B.3 zeigt die Register der MMU zusammen mit Ihren Adressen. Im folgenden
werden die einzelnen Register beschrieben.

Zu beachten ist, daß die MMU im C64-Modus weggeschaltet ist und die Daten-Ein-
und -Ausgabe nur dann gültig ist, wenn die AEC-Leitung logisch "hoch" (1)
liegt. Dies ist notwendig, um Buskonflikte während eines VIC-Zyklusses zu
vermeiden.

[SEITE B-8 * SPEICHERVERWALTUNG (MMU)]

B.2.1 Das Konfigurations-Register

Das Konfigurations-Register (CR) kontrolliert ROM-, RAM- und I/O-Konfiguration
im C128-System. Es liegt sowohl bei Adresse $D500 des I/O-Bereiches als auch
bei Adresse $FF00.

Im C128-Modus kontrolliert das Bit 0, ob der I/O-Bereich ($D500-$D5FF) einge-
schaltet oder ob der ROM/RAM-Bereich zugeschaltet ist. Eine 0 schaltet die
I/O-Konfiguration ein. Eine 1 erlaubt eine der verschiedenen ROM/RAM-Kombina-
tionen einzuschalten. Welche, hängt vom Zustand der anderen Bits im Konfigura-
tions-Register ab. Der Wert dieses Bits wird zwischengespeichert, bis der
Taktimpuls abfällt, um einen unstabilen Zustand zu vermeiden. Im C64-Modus
wird die I/O-Select-Leitung durch dieses Bit auf 1 festgehalten. Zu beachten
ist, daß, wenn der I/O-Bereich nicht eingeschaltet ist, der ROM/RAM-Zugriff
durch die ROM-High-Konfigurations-Bits kontrolliert wird (dies wird in einem
späteren Abschnitt behandelt). Das Bit 0 ist nach dem Einschalten oder nach
einem Systemreset auf 0 gesetzt. Wenn Bit 0 = 1 ist, schalten sich die MMU-
Register ($D500-$D508) dazu. Wenn Bit 0 = 0 ist, werden die Register aus dem
Speicherbereich weggeschaltet. Die MMU-Register im Bereich von $FF00-$FF04
sind im C128-Modus immer präsent. Die I/O-Select-Leitung zeigt im C128-Modus
den Zustand dieses Bits an.

[SEITE B-9 * SPEICHERVERWALTUNG (MMU)]

          Bild B.3: MMU Register Belegung

                       .---------------------.
                      /                     /| --- LOAD CONFIGURATION REG D
                     /                     / |
                    /---------------------/ /| --- LOAD CONFIGURATION REG C
    $FF04 ----------|         LCRD        |/ |
                    |---------------------' /| --- LOAD CONFIGURATION REG B
    $FF03 ----------|         LCRC        |/ |
                    |---------------------' /| --- LOAD CONFIGURATION REG A
    $FF02 ----------|         LCRB        |/ |
                    |---------------------' /| --- CONFIGURATION REGISTER
    $FF01 ----------|         LCRA        |/ /
                    |---------------------' /
    $FF00 ----------|         CR          |/
                    `---------------------'
                       .---------------------.
                      /                     /| --- VERSION REGISTER
                     /                     / |
                    /---------------------/ /| --- PAGE 1 POINTER HIGH
    $D50B ----------|         VR          |/ |
                    |---------------------' /| --- PAGE 1 POINTER LOW
    $D50A ----------|         P1H         |/ |
                    |---------------------' /| --- PAGE 0 POINTER HIGH
    $D509 ----------|         P1L         |/ |
                    |---------------------' /| --- PAGE 0 POINTER LOW
    $D508 ----------|         P0H         |/ |
                    |---------------------' /| --- RAM CONFIGURATION REGISTER
    $D507 ----------|         P0L         |/ |
                    |---------------------' /| --- MODE CONFIGURATION REGISTER
    $D506 ----------|         RCR         |/ |
                    |---------------------' /| --- PRECONFIGURATION REGISTER D
    $D505 ----------|         MCR         |/ |
                    |---------------------' /| --- PRECONFIGURATION REGISTER C
    $D504 ----------|         PCRD        |/ |
                    |---------------------' /| --- PRECONFIGURATION REGISTER B
    $D503 ----------|         PCRC        |/ |
                    |---------------------' /| --- PRECONFIGURATION REGISTER A
    $D502 ----------|         PCRB        |/ |
                    |---------------------' /| --- CONFIGURATION REGISTER
    $D501 ----------|         PCRA        |/ |
                    |---------------------' /
    $D500 ----------|         CR          |/
                    `---------------------'

[SEITE B-10 * SPEICHERVERWALTUNG (MMU)]

                               MMU Register Typen

Page Pointer
      .---.---.---.---.---.---.---.---.
     /   /   /   /   /   /   /   /   /|
    /---/---/---/---/---/---/---/---/ /
PxH | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |/
    +---"---"---"---"---"---"---"---'
                       \   \   \   \
                        \   \   \   `------ A16
                         \   \   `--------- A17
                          \   `------------ A18
                           `--------------- A19

      .---.---.---.---.---.---.---.---.
     /   /   /   /   /   /   /   /   /|
    /---/---/---/---/---/---/---/---/ /
PxL | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |/
    +---"---"---"---"---"---"---"---'
       \   \   \   \   \   \   \   \
        \   \   \   \   \   \   \   `------ A8
         \   \   \   \   \   \   `--------- A9
          \   \   \   \   \   `------------ A10
           \   \   \   \   `--------------- A11
            \   \   \   `------------------ A12
             \   \   `--------------------- A13
              \   `------------------------ A14
               `--------------------------- A15


Mode Configuration Reg.

      .---.---.---.---.---.---.---.---.
     /   /   /   /   /   /   /   /   /|
    /---/---/---/---/---/---/---/---/ /
    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |/
    +---"---"---"---"---"---"---"---'
       \   \   \   \   \           \                    0 = Z-80
        \   \   \   \   \           `------ Proc. Mode  1 = 8502
         \   \   \   \   \
          \   \   \   \   \                        0 = Input
           \   \   \   \   `--------------- FSOIR  1 = Output
            \   \   \   `------------------ /GAME Sense
             \   \   `--------------------- /EXROM Sense
              \   `------------------------ OS Mode  0 = C128  1 = C64
               `--------------------------- 40/80 Sense

Version Register
      .---.---.---.---.---.---.---.---.
     /   /   /   /   /   /   /   /   /|
    /---/---/---/---/---/---/---/---/ /
    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |/
    +---"---"---"---"---"---"---"---'
       \         /     \         /
        `-------'       `-------'
            |               |
            |               `-------------- MMU Version
            `------------------------------ Bank Version

RAM Configuration Register

      .---.---.---.---.---.---.---.---.
     /   /   /   /   /   /   /   /   /|
    /---/---/---/---/---/---/---/---/ /
    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |/
    +---"---"---"---"---"---"---"---'                     00 - 1k
       \   \   \ /     \ /     \ /                        01 - 4k
        \   \   \       \       \                         10 - 8k
         \   \   \       \       `--------- Share Amount  11 - 16k
          \   \   \       \
           \   \   \       `--------------- Share Status  00 - No Share
            \   \   \                                     01 - Share Bottom
             \   \   \               00 - Block 1         10 - Share Top
              \   \   `-- RAM Block  01 - Block 2         11 - Share Both
               \   \                 10 - Block 3
                \   \                11 - Block 4
                 \   \
                  \   `-------------------- VA 16
                   \                               VIC RAM Bank
                    `---------------------- VA 17

Configuration Reg.
Preconfiguration Reg.

      .---.---.---.---.---.---.---.---.
     /   /   /   /   /   /   /   /   /|
    /---/---/---/---/---/---/---/---/ /
    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |/
    +---"---"---"---"---"---"---"---'
       \   \   \ /     \ /     \   \                   0 - System I/O
        \   \   \       \       \   `------ I/O Space  1 - Hi ROM Space
         \   \   \       \       \
          \   \   \       \       \                       0 - System ROM
           \   \   \       \       `------- ROM LO Space  1 - RAM
            \   \   \       \
             \   \   \       `------------- ROM MID Space 00 - System ROM
              \   \   \                                   01 - INT, FUNC, ROM
               \   \   \                                  10 - EXT, FUNC, ROM
                \   \   \                                 11 - RAM
                 \   \   `----------------- ROM HI Space
                  \   \
                   \   `------------------- A 16
                    \                             RAM BANK 0-3
                     `--------------------- A 17



[SEITE B-11 * SPEICHERVERWALTUNG (MMU)]

Das Bit 1 kontrolliert im C128-Modus den Prozessorzugriff zum niederwertigen
ROM-Bereich (s. Bild B.1 ), der im Adreßraum $4000-$7FFF angelegt ist. Ist das
Bit 1, so erscheint der Bereich als RAM und wird mit CAS-Signalen versorgt.
Wenn Bit 1 = 0 ist, wird System-ROM in diesen Bereich eingeschaltet. Dieses
Bit hat Auswirkung auf die Speicher-Status-Leitungen MS0 und MS1. Es wird im
PLA (Progamable Logic Array) decodiert und gibt den entsprechenden ROM-Steck-
platz (chip select) frei. Wurde an dieser Stelle ROM gewählt, werden die
beiden MS0- und MS1-Leitungen nach 0 gezogen, wenn der Prozessor diesen
Bereich adressiert. Bit 1 wird auf 0 gesetzt, wenn im C128-Modus das BASIC-
Low-ROM (s. Bild B.1 ) eingeschaltet werden soll.

Die nächsten zwei Bits (Bit 2 und 3) bestimmen im C128-Modus die Speicherart
(ROM oder RAM) für den mittleren Bereich, der im Adressraum von $8000-$BFFF
angelegt ist. Wenn beide Bits auf 0, sind wird hier das System-ROM angelagert.
Ist nur das Bit 2 = 1, wird das interne Funktions-RAM zugeschaltet. Das ex-
terne Funktions-ROM ist eingeschaltet, wenn das Bit 3 alleine 1 ist. RAM wird
in diesem Bereich angelegt, wenn beide Bits auf 1 gesetzt sind.

Diese beiden Bits haben auch eine Auswirkung auf die Speicherstatus-Leitungen:

Wenn der mittlere Bereich adressiert wird, reflektiert MS0 den Zustand von Bit
3 und MS1 den Zustand von Bit 2. Beide Bits werden auf 0 gesetzt, wenn der
BASIC-High-ROM eingeschaltet wird.

Die Bits 4 und 5 bestimmen die Speicherart (RAM oder ROM im Adreßraum $C000-
$FFFF. Diese beiden Bits haben keinen Einfuß auf den C64-Modus. Ähnlich wie
im mittleren Bereich, ist, wenn beide Bits auf 0 gesetzt sind, das System-ROM
eingeschaltet.

Ist Bit 4 allein 1, wird das interne Funktions-ROM zugeschaltet. Das externe
Funktions-ROM ist eingeschaltet, wenn Bit 5 allein 1 ist. Sind beide Bits auf
1 gesetzt, ist in diesem Bereich RAM angelegt. Zu beachten ist, daß, wenn das
I/O-Bit 1 ist, der Bereich zwischen $D500 und $D5FF unabhängig vom Zustand
dieser Bits für I/O-Funktionen reserviert ist. Ist das I/O-Bit 0, ist in
diesem Bereich ($D000-$DFFF) der Zeichengenerator (Character ROM) angelegt.
Das bedeutet, daß im oberen ROM im Bereich $D000-$DFFF immer eine Lücke
existiert. Wie bei den anderen ROM-Select-Bits beeinflussen diese beiden Bits
auch die Memory-Select-Leitungen. Bit 5 korrespon-

[SEITE B-12 * SPEICHERVERWALTUNG (MMU)]

diert mit MS1 und Bit 4 mit MS0. Die beiden Bits werden durch Einschalten oder
durch einen System-Reset auf 0 gelegt und die ROMs mit Betriebssystem und
Zeichengenerator werden eingeschaltet.

Auch hier ist zu beachten, daß im C128-Modus ebenfalls eine Lücke für die MMU-
Register im Bereich von $FF04 vorhanden ist. Diese Lücke wird durch die beiden
MS-Leitungen und die beiden CAS-Enable-Leitungen geschaffen, die alle auf 1
gehalten werden.

Die beiden letzten Bits (Bit 6 und 7) kontrollieren die RAM-Bank-Auswahl. Ihre
Funktion hängt von der MMU-Version ab. Für die vorliegende Version als 128-
kByte-System ist nur das Bit 6 signifikant. Ist das Bit 6 auf 0, ist die Bank
0 eingeschaltet, indem das CAS0-Signal freigegeben wird. Ist Bit 6 = 1, wird
das CAS1-Signal freigegeben und schaltet damit die Bank 1 ein. Bit 7 ist in
dieser Version inaktiv.

B.2.2 Der Präkonfigurations-Mechanismus

Der Präkonfigurations-Mechanismus ist eine Besonderheit der MMU. Er erlaubt
mit einem Minimum an Zeit- und Speicheraufwand, das Konfigurations-Register
mit seinen verschiedenen Konfigurationen zu laden.

Dabei werden zwei Registersätze verwendet, die Präkonfigurations-Register und
die Lade-Konfigurations-Register.

Die Präkonfigurations-Register (PCRA - PCRD) werden für die Speicherung
mehrerer verschiedener Speicherkonfigurationen benutzt und können mit einem
einfachen Befehl geändert werden. Das Format jedes PCRs gleicht dem Format
des Konfigurations-Registers (CR). Wird ein Wert in ein PCR gespeichert, hat
dies noch keine unmittelbare Auswirkung. Die PCR belegen den I/O-Bereich von
$D501-$D504. Diese Register sind nach dem Einschalten oder nach einem System-
Reset auf 0 gesetzt.

Die Lade-Konfigurations-Register (LCRA - LCRD) korrespondieren direkt mit den
PC-Registern. Wird in ein LCR geschrieben, veranlaßt dieses, daß der Inhalt
des mit dem LCR korrespondierenden PCR in das CR gebracht wird. Die LCRs sind
im Bereich $FF01-$FF04 angelegt. Weder die LCRs noch die PCRs wirken sich im
C64-Modus aus. Zu beachten ist, daß diese Register und das CR bei $FF00 immer
verfügbar sind, unabhängig ob ROM, RAM oder die High-ROM-Bankkonfiguration
eingeschaltet ist. Jede Adressierung in diesem Bereich veranlaßt die MMU, die
beiden Memory-Status-Leitungen sowie die beiden CAS-Enable-Leitungen auf 1 zu
legen.

[SEITE B-13 * SPEICHERVERWALTUNG (MMU)]

B.2.3 Das Modus-Konfigurations-Register

Der augenblicklich eingeschaltete Rechner-Modus wird durch das Modus-Konfi-
gurations-Register (MCR) bestimmt. Es kontrolliert, welcher Prozessor (8502
oder Z80) das System steuert, welcher der Systemmodi (C128 oder C64) gerade
eingeschaltet ist und steuert außerdem verschiedene andere Systembesonder-
heiten.

Das erste Bit (Bit 0) bestimmt, welcher Prozessor aktiviert ist. Es kann als
invertierter Ausgang des Z80-Enable-Signals angesehen werden. Liegt dieses Bit
auf 0, zeigt es an, daß der 8502 Prozessor aktiv ist, liegt es auf 1, ist der
Z80-Prozessor aktiv. Dieses Bit wird nach dem Einschalten oder nach einem
Systemreset auf 0 eingestellt.

Alle Zugriffe auf den Speicherbereich $0000-$0FFF werden in den Speicher-
bereich $D000-$DFFF übertragen, genau an die Stelle, wo das CP/M-ROM-BIOS
physikalisch angelegt ist.

Um zu verhindern, daß der Prozessor mitten in einem Befehl umgeschaltet wird,
ist Bit 0 zwischengespeichert, bis ein Taktzyklus abgelaufen ist.

Bei einem Z80-BIOS-Zugriff sind die beiden Memory-Status-Leitungen (MS0 und
MS1) auf 0 und haben damit das System-ROM eingeschaltet. Für den Bereich von
$001F - $0FFF sind die MS0- und MS1-Leitungen auf 1 . Die beiden RAM-Banks
können über die Adresse A16 eingeschaltet werden. A16 schaltet die beiden
CAS0- und CAS1-Leitungen.

Im C64-Modus wird die Z80-Enable-Leitung immer auf 0 gehalten, unabhängig vom
Zustand des Bits 0.

Die Bits 1 und 2 sind ungenutzt, aber für spätere Porterweiterungen gedacht.
In der augenblicklichen Version sind beide Bits auf 1, wenn sie gelesen
werden. Sie können aber nicht beschrieben werden.

Bit 3 ist das FSDIR-Kontroll-Bit. Es wird als Ausgabebit für den schnellen
seriellen Disketten-Daten-Bus-Puffer und als Eingabebit für das Disk-Enable-
Signal benutzt. Der MMU-Anschluß FSDIR zeigt den Zustand dieses Bits an, das
nach dem Einschalten oder nach einem Systemreset auf 0 gesetzt ist.

Bit 3 ist als bidirektionaler Port eingerichtet, ähnlich wie ein Bit im MOS
6529-Port. Der Wert, der diesem Bit zugeordnet wird, wird ausgegeben und

[SEITE B-14 * SPEICHERVERWALTUNG (MMU)]

wird auch wieder gelesen, wenn nicht von außen das Port auf 0 gezogen wird.
In diesem Fall wird dieses Bit als 0 gelesen. Wird die externe Quelle ent-
fernt, zeigt das Bit seinen vorherigen Zustand an.

Die Bits 4 und 5 sind das GAME- und EXROMIN-Eingabebit. Sie zeigen, ob die
Steckmodulleitungen GAME oder EXROMIN, die im C64-Modus benutzt werden, belegt
sind.

Bei C128-Steckmoduln werden diese Sense-Leitungen nicht benutzt, wodurch an-
hand des Zustands dieser Leitungen im C128-Modus erkannt werden kann, ob es
sich um C64-Steckmodule handelt und der C64-Modus eingeschaltet werden muß.
Diese Bits sind ebenfalls als bidirektionale Bits ausgelegt.

Das GAME-Bit kontrolliert die Umschaltung des Farbspeichers, wenn es als Aus-
gabebit geschaltet ist. Das Bit 5 (EXROMIN) wird im Augenblick nicht als Aus-
gabe genutzt.

Bit 6 schaltet zwischen den beiden Operationsmodi um. Dieses Bit ist nach dem
Einschalten oder nach einem Systemreset auf 0 voreingestellt, d.h., der C128-
Modus ist eingeschaltet, alle MMU-Register sind aktiviert und alle C128-
Steuer-Leitungen sind vorbereitet. Wird dieses Bit auf 1 gesetzt, so wird die
MMU ab- und der C64-Modus eingeschaltet.

Zu beachten ist, daß die MS3-Leitung den Zustand des Bits 6 invertiert dar-
stellt.

Ist das Bit 7 als Eingabebit deklariert, zeigt es den Zustand der 40/80-Dis-
play-Taste an. Ist Bit 7 = 1, ist die Taste offen, ist es 0, ist die Taste
gedrückt.

Der Anzeige-Modus wird entsprechend der Softwareinterpretation dieses Bits
ein- oder ausgeschaltet. Als Ausgabebit wird dieses Bit gegenwärtig nicht
genutzt.

B.2.4 Das RAM-Konfigurations-Register

Das RAM-Konfigurations-Register setzt die Segmentparameter für den Prozessor
und für den Blockzeiger des VIC-Bausteins. Dieses Register ist im I/O-Bereich
bei $D506 angelegt (s. Bild B.4).

Die Bits 0 und 1 bestimmen die Größe des auf die einzelnen Speicherbänke auf-
teilbaren RAMs. Vorausgesetzt, daß ein gemeinsamer RAM-Bereich

[SEITE B-15 * SPEICHERVERWALTUNG (MMU)]

deklariert wurde, werden die RAM-Bank-Bits des Konfigurations-Registers grund-
sätzlich überlesen, da die ausgewählte RAM-Bank für nicht-gemeinsame Bereiche
genutzt wird (die ROM- und I/O-Bereich-Bits des Konfigurationsregisters (s.
Kapitel B.2.1) bleiben jedoch wirksam). Wenn der Wert der Bits 0 und 1 Null
ist, werden 1 kByte gemeinsamer RAM eingeschaltet. Ist nur das Bit 0 = 1,
werden 4 kByte, ist nur das Bit 1 = 1, werden 8 kByte und sind beide Bits
auf 1, werden 16 kByte gemeinsamer RAM-Bereich eingeschaltet. Diese Bits
wirken sich im C64-Modus nicht aus. Nach dem Einschalten oder nach einem
System-Reset sind beide Bits auf 0 voreingestellt.

Bits 2 und 3 bestimmen, ob und wo ein gemeinsamer Speicherbereich angelegt
wird. Sind beide Bits auf 0, wird kein gemeinsamer Bereich eingerichtet. Ist
das Bit 2 auf 1 , ist der untere RAM-Bereich als gemeinsamer Bereich dekla-
riert. Ist Bit 3 auf 1, ist der obere RAM-Bereich als gemeinsamer Bereich
eingerichtet. Sind beide Bits gesetzt, ist ein Teil des gemeinsamen Bereiches
im unteren und der andere Teil im oberen RAM-Bereich angelegt. Beim Ein-
schalten oder nach einem System-Reset sind beide Bits auf 0 gesetzt, so daß
kein gemeinsamer Bereich vereinbart ist.

Bei der vorliegenden MMU-Version wird die Auswahl des gemeinsamen Bereiches
durch die CAS0- und CAS1-Signale bestimmt. Das CAS0- wird auf 0 und das CAS1-
Signal auf 1 gehalten.

Bit 4 und 5 werden z.Z. nicht genutzt, sind aber als Blockzeiger-Bits gedacht.
Damit wird es zukünftig möglich sein, bis zu 1 MByte RAM in 256-kByte-Blöcken
zu adressieren. Sind beide Bits 0, ist der 1. 256 K-Block aktiviert. ist nur
das Bit 4 = 1, ist der 2. Block aktiviert usw. Auf diese Weise lassen sich 4
Blöcke 256 kByte adressieren.

Bits 6 und 7 sind die RAM-Block-Zeiger für den VIC-Baustein. Bei der vorlie-
genden MMU-Version wird das Bit 7 ignoriert. Das Bit 6 wird dazu benutzt, das
CAS0-Signal auf 0 zu legen, wenn Bit 6 = 0 ist bzw., wenn Bit 6 = 1 ist, das
CAS1-Signal auf 0 zu legen. So wird entweder Bank 0 oder 1 angewählt.

Beim 2-MHz-Betrieb übernimmt der 80-Zeichen-Baustein die Bildschirm-Steuer-
funktionen, wobei der VIC-Baustein abgeschaltet wird. Das Abschalten wird von
dem VIC-Baustein selber verursacht, indem das AEC-(Address-Enable-Control)
Signal konstant hochgehalten wird.

Zu beachten ist, daß ein VIC-Zyklus erkannt wird, wenn AEC nach 0 gezogen
wird. Dieses kann von einem DMA (Direct Memory Access) herrühren, der

[SEITE B-16 * SPEICHERVERWALTUNG (MMU)]

die ACE-Leitung ebenfalls nach 0 zieht. Jeder DMA veranlaßt die MMU, in die
VIC-Konfiguration umzuschalten.

B.2.5 Die Speicherseiten-Zeiger

Die Seitenzeiger (s. Bild B.4) sind vier Register, die eine unabhängige Adres-
sierung der beiden untersten Speicherseiten von je 256 Byte erlauben. Dies
ist besonders nützlich, denn sie helfen, die Festlegung der Zero Page und des
Stapelspeichers auf den physikalischen Adreßbereich $0000-$01FF, wie sie
normalerweise für die 6500-Prozessor-Familie gilt, zu beseitigen.

Für die Verschiebung der Zero Page liefert die MMU die beiden Zero Page-
Zeiger-Register P0H und P0L (Page 0 Pointer High, Page 0 Pointer Low). Bei
einem beliebigen Zero Page-Zugriff ($0000-$00FF) werden die Bits 0 bis 3 des
P0H-Registers und die mit dem P0H-Registern korrespondieren Adressen TA16 bis
TA19 gesetzt.

In der vorliegenden Version kontrolliert das Bit 0 die Erzeugung des CAS0-
oder des CAS1-Signals abhängig davon, ob das Bit 0 = 0 oder 1 ist. Die Bits
1 bis 3 werden ignoriert.

Die restlichen Bits sind 0, sie überdecken die RAM-Bank-Bits. Die ROM-Block-
und die I/O-Block-Bits bestimmen, welche physikalische Speicherseite als Zero
Page bei allen Zero-Page-Zugriffen erscheint. Wird das P0H-Register beschrie-
ben, wird es solange zwischengespeichert, bis auch das P0L-Register beschrie-
ben wird.

Die Bits 0-7 dieses Registers wirken auf die Adressen TA8-TAl5, wenn auf eine
deklarierte Zero Page zugegriffen wird. In diesem Fall wird automatisch auf
die Original-Zero Page umgeschaltet. Ein Schreiben in dieses Register erzwingt
einen Zero Page-Transfer, sobald der Taktimpuls auf 0 geht. Die beiden Regis-
ter sind im I/O-Bereich angelegt, und zwar P0L bei $D507 und P0H bei $D508.

Die Register für die Verschiebung der Speicherseite 1 (Stapelspeicher) sind im
I/O-Bereich für P1L bei $D509 und P1H bei $D50A angeordnet. Die Funktionen und
die korrespodierenden Signale entsprechen denen von P0H und P0L. Die Register-
paare sind nach dem Einschalten oder nach einem System-Reset auf 0 voreinge-
stellt, d.h. Zero Page und Stapelspeicher liegen physikalisch und logisch im
Adreßbereich $01FF.

[SEITE B-17 * SPEICHERVERWALTUNG (MMU)]

B.2.6 Das System-Versions-Register

Das letzte Register, das hier erwähnt werden soll, ist das Versions-Register
(s. Bild B.4). Es ist im I/O-Bereich bei $D50B angelegt. Dieses Register ist
ein Leseregister (read only).

Es enthält in dem niederwertigen Halbbyte eine Information über die aktuelle
MMU-Version. In dem höherwertigen Halbbyte ist eine Information über den Spei-
cherausbau enthalten. Damit ist es möglich, für zukünftige Versionen entwik-
kelte Programme, die den Speicherausbau berücksichtigen, ablaufen zu lassen.

************************************
*     [ANHANG C]:                  *
*                                  *
*     Maschinensprache-Monitor     *
************************************

[SEITE C-1 * MASCHINENSPRACHE-MONITOR]

ANHANG C: MASCHINENSPRACHE-MONITOR

Für Anwender, die den Speicher des C128 direkt verwalten wollen oder mit
Maschinensprache-Programmen arbeiten, enthält das Betriebssystem des C128
einen Monitor, durch den der Benutzer im C128-Modus jederzeit wichtige Infor-
mationen über den inneren Zustand des Computers erhalten kann.

Im allgemeinen handelt es sich dabei um Inhalte von Registern und Speicher-
stellen. Dabei werden zur besseren Übersicht alle Adressen und Speicherinhalte
in hexadezimaler Schreibweise (hex) angegeben. Damit werden alle Registerin-
halte als zweistellige und alle Adressen als vier- oder fünfstellige Hex-
Zahlen angegeben. Die höchstwertige Hex-Ziffer einer fünfstelligen Adreßangabe
bezeichnet die Speicherkonfiguration, bei der der vorangestellte Monitorbefehl
wirken soll. Es gibt folgende 16 Speicherkonfigurationen:

0        RAM-Bank 0
1        RAM-Bank 1
2        RAM-Bank 2 (zukünft. Erweiterung)
3        RAM-Bank 3 (zukünft. Erweiterung)
F        Betr.-System + BASIC, RAM, I/O, Zeichengenerator

Der Monitor wird durch den Befehl MONITOR des BASIC 7.0 im C128-Modus aufge-
rufen. Er wird ebenfalls aktiviert, wenn ein Maschinenspracheprogramm ausge-
führt wird, das den Befehl BRK mit dem Befehlscode 0 enthält. Dabei wird
folgende Bildschirmanzeige sichtbar:

MONITOR
    PC  SR  AC  XR  YR  SP
  FB000 00  00  00  00  F8

Die Abkürzungen in der oberen Reihe der Anzeige haben folgende Bedeutung:

PC:  Der Programmzähler (program counter), der die Adresse des näch-
     sten auszuführenden Befehls enthält.

SR:  Der Inhalt des Statusregisters des Mikroprozessors 8502.

AC:  Der Inhalt des Akkumulator-Registers des Mikroprozessors 8502.

[SEITE C-2 * MASCHINENSPRACHE-MONITOR]

XR:  Der Inhalt des Indexregisters X des Mikroprozessors 8502.

YR:  Der Inhalt des Indexregisters Y des Mikroprozessors 8502.

SP:  Der Inhalt des Stapelzeigers (stack pointer) des Mikroprozessors 8502.

Der Maschinensprache-Monitor kennt eine ganze Reihe komfortabler Befehle, mit
dem der Speicher des C128 bearbeitet werden kann, Speicherbereiche von/auf
Kassette oder Diskette geladen/gespeichert und Maschinensprache-Programme
assembliert, disassembliert, ausgeführt und getestet werden können. Nach einer
Zusammenstellung aller möglichen Befehle wird jeder Befehl ausführlich und
anhand von Beispielen beschrieben.

Befehl                  Bedeutung

A (assemble)            Assembliert eine Zeile in 6502-Befehlscode.
C (compare)             Vergleicht zwei Speicherbereiche byteweise
                        und zeigt Unterschiede an.
D (disassemble)         Disassembliert einen Speicherbereich mit
                        Maschinensprache-Code.
F (fill)                Füllt einen Speicherbereich mit einem angegebenen
                        Byte.
G (go)                  Startet ein Maschinensprache-Programm bei
                        einer angegebenen Adresse.
H (hunt)                Durchsucht einen Speicherbereich nach einer
                        angegebenen Bytefolge.
L (load)                Lädt eine Programmdatei von Kassette oder
                        Diskette.
M (memory)              Zeigt den Inhalt eines angegebenen Speicher-
                        bereiches hexadezimal an.
R (register)            Zeigt den Inhalt der Prozessorregister an.
S (save)                Speichert den angegebenen Speicherbereich auf
                        Kassette oder Diskette.
T (transfer)            Verschiebt den Inhalt eines angegebenen
                        Speicherbereiches.
V (verify)              Vergleicht einen Speicherbereich mit einer
                        Programmdatei auf Kassette oder Diskette.
X (exit)                Beendet den Monitor und kehrt in den BASIC-
                        Direktmodus zurück.
>                       Modifiziert ein bis acht Speicherzellen ab
                        der angegebenen Adresse.

[SEITE C-3 * MASCHINENSPRACHE-MONITOR]

Befehl                  Bedeutung

.                       Identisch mit dem A-Befehl.
;                       Modifiziert die Prozessorregister.
@                       Zeigt den Floppy-Disk-Status an oder über-
                        trägt einen Floppy-Disk-Befehl.

Für die Syntax der Beschreibungen der einzelnen Befehle gelten dieselben
Regeln, die in Kapitel 4.5 für die BASIC-Befehle zusammengestellt wurden.

Adressen können grundsätzlich in jedem Zahlensystem angegeben werden (s.u.).
Sind sie hexadezimal 1- bis 4-stellig, so beziehen sie sich auf die Speicher-
bank 0, sind sie hexadezimal 5-stellig, so gibt die höchstwertige Hexadezimal-
ziffer die gewünschte Speicherbank an.

Der Monitor zeigt Adressen grundsätzlich 5-stellig hexadezimal an.

Je nach eingestellter Bildschirmbreite werden beim M-Befehl 8 bzw. 16 Byte-
inhalte je Bildschirmzeile sowohl hexadezimal als auch als Zeichen in ASCII-
Codierung dargestellt.

Numerische Werte können beim Monitor durch Voranstellen von speziellen Sym-
bolen in jedem Zahlensystem definiert werden.

kein Symbol             hexadezimale Werte (Voreinstellung)
$                       hexadezimale Werte
+                       dezimale Werte
&                       oktale Werte
%                       binäre Werte

Beispiel:               M+14500+14550

                        Der Speicherbereich zwischen 14500 und 14550
                        dezimal in der Bank 0 wird angezeigt.

[SEITE C-4 * MASCHINENSPRACHE-MONITOR]

A Assemblieren

Format:       A Adresse Befehl [Operand]

Zweck:        Assembliert den angegebenen Maschinensprache-Befehl bei der
              angegebenen Adresse.

              Adresse  Hexadezimale Speicheradresse, bei der der Befehl
              assembliert werden soll.

              Befehl  Mnemonische Schreibweise des Maschinensprache-Befehls
              (s. Programmierhandbuch für den Mikroprozessor 6502).

              Operand  Definiert, falls erforderlich, den Adressierungsmodus
              und muß hexadezimal angegeben werden.

Bemerkungen:  Drücken der RETURN-Taste beendet die Eingabe der Befehlszeile
              und startet die Assemblierung. Die assemblierte Zeile über-
              schreibt dabei die eingegebene.

              Wird die RETURN-Taste ohne weitere Eingabe gedrückt, so wird der
              Assemblermodus beendet.

              Es kann nur in RAM-Bereiche assembliert werden.

              Werden Fehler erkannt, so wird ein Fragezeichen (?) angezeigt
              und der Cursor wird auf den Anfang der nächsten Zeile gesetzt.
              Mit Hilfe des Bildschirmeditors kann die Zeile korrigiert
              werden.

Beispiele:    A 1200 LDX #$0
              A 1200 A2 00                LDX #$00
              A 1202

[SEITE C-5 * MASCHINENSPRACHE-MONITOR]

C Speichervergleich

Format:       C Adresse1 Adresse2 Adresse3

Zweck:        Vergleicht zwei Speicherbereiche und zeigt die Adressen der
              unterschiedlichen Speicherbytes an.

              Adresse1  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, gegen den verglichen wird.

              Adresse2  Hexadezimale Speicheradresse, die das Ende des
              Bereiches definiert, gegen den verglichen wird.

              Adresse3  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, mit dem verglichen wird.

Bemerkungen:  Für alle gefundenen Unterschiede werden die Adressen je nach der
              Bildschirmbreite in 5 oder 10 Spalten angezeigt.

[SEITE C-6 * MASCHINENSPRACHE-MONITOR]

D Disassemblieren

Format:       D [Adresse1] [Adresse2]

Zweck:        Disassembliert einen Bereich mit Maschinencode und zeigt dafür
              die mnemonischen Befehle zusammen mit dem Code an.

              Adresse1  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, der disassembliert werden soll.

              Adresse2  Hexadezimale Speicheradresse, die das Ende des
              Bereiches definiert, der disassembliert werden soll.

Bemerkungen:  Das Disassemblierungs-Anzeigeformat unterscheidet sich von dem
              der Assemblierung darin, daß am Zeilenanfang ein Punkt (.) statt
              eines A ausgegeben wird. Außerdem wird der Maschinensprache-Code
              zusätzlich vor dem mnemonischen Code angezeigt.

              Nicht identifizierbare Codes werden in der Befehlsspalte als ???
              dargestellt.

              Die Disassemblierungsliste kann jederzeit mit dem Bildschirm-
              editor modifiziert werden, wodurch automatisch der Assembler
              aktiviert wird (.-Befehl).

              Werden die Adressangaben weggelassen, so werden 19 Bildschirm-
              zeilen angezeigt.

Beispiel:     .D F6000 F6006
              .F6000 A5 63                LDA #$63
              .F6002 D0 F3                BNE $5FF7
              .F6004 A9 05                LDA #$05
              .F6006 20 FB 4F             JSR $4FFB

[SEITE C-7 * MASCHINENSPRACHE-MONITOR]

F Speicherbereich füllen

Format:       F Adresse1 Adresse2 Byte

Zweck:        Füllt einen Speicherbereich mit einem angegebenen Byte.

              Adresse1  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, der gefüllt werden soll.

              Adresse2  Hexadezimale Speicheradresse, die das Ende des
              Bereiches definiert, der gefüllt werden soll.

              Byte  Eine ein- oder zweistellige Hexadezimalzahl, die den Code
              angibt, mit dem der Bereich gefüllt werden soll.

Bemerkungen:  Dieser Befehl ist zur Erzeugung bestimmter Datenstrukturen oder
              RAM-Bereiche hilfreich.

Beispiel:     F 0400 0518 EA

              Der Bereich zwischen $0400 und $0518 in der Speicherbank 0 wird
              mit $EA (Code für den NOP-Maschinensprachebefehl) gefüllt.

[SEITE C-8 * MASCHINENSPRACHE-MONITOR]

G Programm starten

Format:       G [Adresse]

Zweck:        Startet ein Maschinenspracheprogramm bei einer angegebenen
              Adresse.

              Adresse  Hexadezimale Speicheradresse, bei der das Programm
              gestartet werden soll. Wird Adresse weggelassen, so beginnt die
              Programmausführung beim aktuellen Stand des Programmzählers, der
              mit dem R-Befehl (s. dort) angezeigt werden kann.

Bemerkungen:  Ehe das Programm gestartet wird, werden die aktuellen Register-
              inhalte (durch den R-Befehl anzeigbar) gesichert.

              Um nach der Ausführung des Maschinenspracheprogramms wieder den
              Monitor aufzurufen, muß der letzte Programmbefehl ein BRK-Befehl
              (Code $00) sein.

Beispiel:     G 140C

              Das bei der Adresse $104C in der Speicherbank 0 beginnende
              Maschinenspracheprogramm wird gestartet.

[SEITE C-9 * MASCHINENSPRACHE-MONITOR]

H Speicherbereich durchsuchen


Format:       H Adresse1 Adresse2 Daten

Zweck:        Durchsucht einen Speicherbereich nach einer angegebenen Byte-
              folge.

              Adresse1  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, der durchsucht werden soll.

              Adresse2  Speicheradresse, die das Ende des Bereiches definiert,
              der durchsucht werden soll.

              Daten  Eine oder mehrere zweistellige Hexadezimalzahlen,
              getrennt durch ein Leerzeichen oder eine Zeichenkette, der ein
              Apostroph (') vorangestellt ist.

Bemerkungen:  Es werden die Adressen aller Stellen des angegebenen Bereiches,
              bei denen die definierten Daten gefunden wurden, je nach ein-
              gestellter Bildschirmbreite in 5 bzw. 10 Spalten angezeigt.

Beispiel:     H A000 A100 4C FF A9

              Durchsucht den Bereich zwischen $A000 und $A100 in der Speicher-
              bank 0 nach der Bytefolge $4CFFA9.

              H F4000 FFFFF 'MON

              Durchsucht den Bereich zwischen $F4000 und FFFFF nach der
              Zeichenkette MON.

[SEITE C-10 * MASCHINENSPRACHE-MONITOR]

L Programmdatei laden

Format:       L Dateiname [,Geräteadr] [,Ladeadr]

Zweck:        Lädt eine Programmdatei von Kassette oder Diskette in den
              Speicher.

              Dateiname  Eine Zeichenkette von maximal 16 Zeichen Länge,
              eingeschlossen in Anführungszeichen ("), die den Dateinamen
              angibt.

              Geräteadr  Die Geräteadresse des externen Datenträgers, von dem
              geladen werden soll. Für Kassette muß 01 und für Floppy-Disk je
              nach dort eingestellter Adresse ein Wert zwischen 04 und 0F
              angegeben werden.

              Ladeadr  Eine gültige Speicheradresse, ab der geladen werden
              soll. Wird Ladeadr weggelassen, so wird die Datei ab der Adresse
              in der aktuellen Speicherbank geladen, ab der sie auch gespei-
              chert wurde.

Bemerkungen:  Es wird immer die gesamte Datei geladen.

Beispiele:    L "PROGR 1",08

              Lädt die Programmdatei PROGR 1 von Diskette ab der Speicher-
              adresse, ab der die Datei auch gespeichert wurde.

              L "PROGRAMM",0A,2000

              Lädt die Programmdatei PROGRAMM von Diskette in Floppy-Disk Nr.
              10 ab Adresse $2000 in der aktuellen Speicherbank.

[SEITE C-11 * MASCHINENSPRACHE-MONITOR]

M Speicherinhalt anzeigen

Format:       M Adresse1 [Adresse2]

Zweck:        Zeigt den Inhalt eines wählbaren Speicherbereiches in einer
              wählbaren Speicherbank auf dem Bildschirm an.

              Adresse1  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, der angezeigt werden soll. Wird Adresse1
              weggelassen, so wird der Speicherbereich ab dem aktuellen Pro-
              grammzähler in der Speicherbank 0 in 12 Zeilen auf dem Bild-
              schirm angezeigt.

              Adresse2  Hexadezimale Speicheradresse, die das Ende des
              Bereiches definiert, der angezeigt werden soll. Wird Adresse2
              weggelassen, so wird der Speicherbereich ab Adresse1 in 12
              Zeilen auf dem Bildschirm angezeigt.

Bemerkungen:  Der Speicherbereich wird in folgendem Format angezeigt
              (Beispiel):

              > 1A048 41 E7 00 AA AA 00 98 56   :A!.**..V

              Nach dem >-Zeichen folgt die vollständige Adresse des ersten
              Byte der angezeigten Zeile, dann je nach eingestellter Bild-
              schirmbreite die Inhalte von 8 bzw. 16 Speicherbytes in hexa-
              dezimaler Codierung und dann die ASCII-Äquivalente dieser 8 bzw.
              16 Byte in inverser Darstellung. Nicht darstellbare Codes
              werden hier durch Punkte (.) angezeigt.

              Der angezeigte Speicherinhalt kann mit Hilfe des Bildschirm-
              editors verändert werden. Dazu wird der Cursor auf die betref-
              fende Byteanzeige im hexadezimalen Feld gestellt und die
              Änderung hexadezimal eingegeben. Durch Drücken der RETURN-Taste
              wird immer eine Bildschirmzeile übernommen (>-Befehl).

[SEITE C-12 * MASCHINENSPRACHE-MONITOR]

              Eingabefehler oder der Versuch, ROM-Bereiche zu modifizieren
              führen zur Anzeige eines Fragezeichens (?) an der aktuellen
              Cursor-Position

              Es werden immer vollständige Bildschirmzeilen angezeigt.

Beispiel:     .M F4540 F4547
              >F4540 54 52 4F CE 54 52 4F 46: TRONTROF

[SEITE C-13 * MASCHINENSPRACHE-MONITOR]

R Prozessorregister anzeigen und ändern

Format:       R

Zweck:        Zeigt den aktuellen Inhalt sämtlicher Register des Mikroprozes-
              sors 8502 (Programmzähler PC, Statusregister SR, Akkumulator AC,
              Indexregister XR und YR, Stapelzeiger SP) sowie den Interrupt-
              Vektor IRQ an.

Bemerkungen:  Die Registerinhalte können geändert werden, indem die Einträge
              der Registeranzeige mit dem Bildschirmeditor geändert werden.
              Drücken der RETURN-Taste übernimmt die Einträge (;-Befehl).

Beispiel:     .R
                  PC     SR AC XR YR SP
              .; FB000   00 00 00 00 F8


[SEITE C-14 * MASCHINENSPRACHE-MONITOR]

S Speicherbereich sichern

Format:       S "[Laufw:]Name",Geräteadr,Adresse1,Adresse2

Zweck:        Sichert einen angegebenen Speicherbereich auf Kassette oder
              Diskette als Programmdatei.

              Laufwerk  Wird auf Diskette gespeichert, so muß hier bei Doppel-
              laufwerken unbedingt 0 oder 1 eingegeben werden. Bei Einzel-
              laufwerken kann die Laufwerksangabe entfallen. Soll auf Kassette
              gespeichert werden, muß die Angabe Laufw: entfallen.

              Name  Eine Zeichenkette von maximal 16 Zeichen bei Kassetten-
              bzw. 14 Zeichen bei Disketten-Sicherung, die den Dateinamen
              angibt.

              Geräteadr  Die Geräteadresse des externen Datenspeichers, auf
              dem der Speicherbereich gesichert werden soll. Für Kassette muß
              01 und für Floppy-Disk je nach dort eingestellter Adresse ein
              Wert zwischen 04 bis 0F angegeben werden.

              Adresse1  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, der gesichert werden soll.

              Adresse1  Hexadezimale Speicheradresse + 1, die das Ende des
              Bereiches definiert, der gesichert werden soll.

Bemerkungen:  Die ersten beiden Byte der gesicherten Datei enthalten die
              Startadresse des gesicherten Speicherbereiches in der Anordnung
              höherwertiges Byte / niederwertiges Byte.

[SEITE C-15 * MASCHINENSPRACHE-MONITOR]

Beispiele:    S "SPIEL",01,1B000,1B800

              Speichert den Adressbereich von $B000 bis $B7FF einschließlich
              in Speicherbank 1 unter dem Namen SPIEL als Programmdatei auf
              Kassette.

              S"0:MEM",0A,2000,2500

              Speichert den Bereich $2000 bis $24FF der Speicherbank 0 auf
              Diskette in Laufwerk 0 der Floppy-Disk mit der Geräteadresse 10.

[SEITE C-16 * MASCHINENSPRACHE-MONITOR]

T Speicherbereich übertragen

Format:       T Adresse1 Adresse2 Adresse3

Zweck:        Überträgt den Inhalt eines angegebenen Speicherbereiches in
              einen anderen Speicherbereich.

              Adresse1  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, dessen Inhalt verschoben werden soll.

              Adresse2  Hexadezimale Speicheradresse, die das Ende des
              Bereiches definiert, dessen Inhalt verschoben werden soll.

              Adresse3  Hexadezimale Speicheradresse, die den Anfang des
              Bereiches definiert, in den der Inhalt übertragen werden soll.

Bemerkungen:  Speicherinhalte können von höheren zu niederen Adressen und
              umgekehrt verschoben werden und es können die Inhalte beliebig
              großer Speicherbereiche verschoben werden.

              Während der Übertragung wird eine automatische Prüfung der über-
              tragenen Bytes durchgeführt, um Speicherfehler anzeigen zu
              können.

Beispiel:     T 1400 1600 1401

              Verschiebt den Inhalt des Bereiches $1400 bis $1600 in der
              Speicherbank 0 um ein Byte nach "oben".


[SEITE C-17 * MASCHINENSPRACHE-MONITOR]

V Programmdatei verifizieren

Format:       V Dateiname [,Geräteadr] [,Anfadr]

Zweck:        Vergleicht eine Programmdatei auf Kassette oder Diskette mit
              einem Speicherbereich.

              Dateiname  Eine Zeichenkette von maximal 16 Zeichen Länge,
              eingeschlossen in Anführungszeichen ("), die den Dateinamen
              angibt.

              Geräteadr  Die Geräteadresse des externen Datenträgers, von dem
              verglichen werden soll. Für Kassette muß 01 und für Floppy-Disk
              je nach dort eingestellter Adresse ein Wert zwischen 04 bis 0F
              angegeben werden.

              Anfadr  Eine gültige Speicheradresse, ab der verglichen werden
              soll. Wird Anfadr weggelassen, so wird der Speicherbereich ab
              der Adresse mit der Datei verglichen,ab der diese auch gespei-
              chert wurde.

Bemerkungen:  Es wird immer die gesamte Datei verglichen.

              Nach dem Drücken der RETURN-Taste wird bei diesem Befehl die
              Meldung VERIFYING angezeigt. Wird fehlende Übereinstimmung bei
              einem Byte gefunden, so wird zusätzlich die Meldung ERROR
              angezeigt.

Beispiele:    .V "PROGR 1",08

              Vergleicht die Programmdatei PROGR 1 mit dem Speicherbereich ab
              der Adresse in der aktuellen Speicherbank, ab der die Datei auch
              gespeichert wurde.

[SEITE C-18 * MASCHINENSPRACHE-MONITOR]

X Rückkehr in des BASIC-Direktmodus

Format:       X

Zweck:        Beendet den Monitorbetrieb und verzweigt zurück in den BASIC-
              Direktmodus.

Beispiel:     .X
              READY.

[SEITE C-19 * MASCHINENSPRACHE-MONITOR]

> Speicherinhalte definieren

Format:       > Adresse Byte1 [Byte2 ... Byten]

Zweck:        Definiert je nach eingestellter Bildschirmbreite die Inhalte von
              8 bzw. 16 aufeinanderfolgenden Speicherzellen ab einer ange-
              gebenen Adresse.

              Adresse  Hexadezimale Speicheradresse, ab der Speicherzellen-
              inhalte definiert werden sollen.

              Byte1 ... Byten  Bis zu 8 bzw. 16 Byte in 2-stelliger hexa-
              dezimaler Schreibweise getrennt durch eine Leerstelle, die im
              Speicher abgelegt werden sollen.

Bemerkungen:  Unabhängig von der Anzahl der eingegebenen Bytes wird nach Aus-
              führung dieses Befehls immer die ganze Bildschirmzeile von 8
              bzw. 16 Speicherbyteinhalten angezeigt.

              Dieser Befehl wird bei der Modifizierung der Bildschirmanzeige
              des M-Befehls (s. dort) automatisch ausgeführt.

Beispiel:     > 02200 41 42 43

              Ab der Adresse 2200 in der Speicherbank 0 werden die Bytes $41,
              $42 und $43 abgelegt.


[SEITE C-20 * MASCHINENSPRACHE-MONITOR]

. Assemblieren

Dieser Befehl hat dieselbe Wirkung wie der A-Befehl (s. dort).

[SEITE C-21 * MASCHINENSPRACHE-MONITOR]

@ Floppy-Disk-Bedienung

Format:       @ [Geräteadr][,[Floppybefehl]]

Zweck:        Zeigt den Status der angeschlossenen Floppy-Disk an (nur @
              [Geräteadr]) oder überträgt eine angegebene Bedienungszeichen-
              kette an die Floppy-Disk.

              Geräteadr  Ein Wert zwischen 08 und 0F für die Geräteadresse der
              angeschlossenen Floppy-Disk. Voreingestellt ist 08.

              Floppybefehl  Eine gültige Floppy-Disk-Befehlszeichenkette (s.a.
              Kapitel 6 und Floppy-Disk-Handbuch).

Beispiele:    @
              00, OK,00,00

              Der Floppy-Status wurde abgefragt.

              @,S0:PRG*
              01, FILES SCRATCHED,02,00


              Auf der Diskette in Laufwerk 0 der Floppy-Disk mit der Geräte-
              adresse 8 wurden 2 Dateien, deren Namen mit PRG beginnen, ge-
              löscht.

              @8,$

              Das Inhaltsverzeichnis der Diskette in der Floppy-Disk mit der
              Geräteadresse 8 wird angezeigt.

*******************************************
*     [ANHANG D]:                         *
*                                         *
*     Besonderheiten der DIN-Tastatur     *
*******************************************

[SEITE D-1 * BESONDERHEITEN DER TASTATUR]

Tastaturbelegung bei gleichzeitigem Drücken der Commodore-Taste im DIN Modus.

************************************************
*     [ANHANG E]:                              *
*                                              *
*     Registerzuordnungen beim SID und VIC     *
************************************************

[SEITE E-1 * REGISTERZUORDNUNGEN BEIM SID UND VIC]

KONTROLLREGISTER FÜR TONERZEUGUNG

Basisadresse des SID: 54272dez = D400hex

        REGISTER                        INHALT

STIMME   1  2  3
       +--+--+--+-----------------------------------------------------------+
       | 0| 7|14| FREQUENZ, LO-BYTE (0...255)                               |
       +--+--+--+-----------------------------------------------------------+
       | 1| 8|15| FREQUENZ, HI-BYTE (0...255)                               |
       +--+--+--+-----------------------------------------------------------+
       | 2| 9|16| TASTVERHÄLTNIS, LO-BYTE (0...255) (NUR FÜR RECHTECK)      |
       +--+--+--+-----------------------------------------------------------+
       | 3|10|17| TASTVERHÄLTNIS, HI-BYTE (0...15)                          |
       +--+--+--+----------------+----------+----------+----------+---------+
       | 4|11|18| Wellenform:    | RAUSCHEN | RECHTECK | SÄGEZAHN | DREIECK |
       |  |  |  |                |   129    |   65     |    33    |   17    |
       +--+--+--+----------------+----------+---+------+----------+---------+
       | 5|12|19| ANSCHLAG                      | ABSCHWELLEN               |
       |  |  |  | 0*16 (hart)...15*16 (weich)   | 0 (hart)...15*16 (weich)  |
       +--+--+--+-------------------------------+---------------------------+
       | 6|13|20| HALTEN                        | AUSKLINGEN                |
       |  |  |  | 0*16 (stumm)...15*16 (laut)   | 0 (schnell)...15 (langsam)|
       +--+--+--+-------------------------------+---------------------------+
       |24|24|24| LAUTSTÄRKE: 0 (stumm)...15 (volle Lautstärke)             |
       +--+--+--+-----------------------------------------------------------+

Weitere Register des SID

        REGISTER                        INHALT
       +--------+-----------------------------------------------------------+
       |   21   | GRENZFREQUENZ FILTER, LO-BYTE (0...7)                     |
       +--------+-----------------------------------------------------------+
       |   22   | GRENZFREQUENZ FILTER, HI-BYTE (0...255)                   |
       +--------+-----------------------------+-----------------------------+
       |   23   | RESONANZ                    |      FILTER EINSCHALTEN     |
       |        | 0 (keine)...15*16 (stark)   | extern | Sti3 | Sti2 | Sti1 |
       |        |                             |    8   |   4  |   2  |   1  |
       +--------+-----------------------------+--------+------+------+------+
       |   24   |      FILTER-MODUS           |         LAUTSTÄRKE          |
       |        | Sti3 | Hoch | Band | Tief   |                             |
       |        | aus  | Paß  | Paß  | Paß    |                             |
       |        | 128  | 64   | 32   | 16     |  0 (stumm)...15 (laut)      |
       +--------+-----------------------------+-----------------------------+

Mit Hilfe dieser Einstellungen können Sie verschiedene Instrumente nachahmen:

       +------------+-------------+------------+----------+-----------------+
       | Instrument | Wellenform  |  Anschlag  |  Halten  | Tastverhältnis  |
       +------------+-------------+------------+----------+-----------------+
       | Piano      | Puls     65 |      9     |     0    |    HI-0, LO-255 |
       | Flöte      | Dreieck  17 |     96     |     0    |                 |
       | Cembalo    | Sägezahn 33 |      9     |     0    |                 |
       | Xylophon   | Dreieck  17 |      9     |     0    |                 |
       | Orgel      | Dreieck  17 |      0     |   240    |                 |
       | Akkordeon  | Dreieck  17 |    102     |     0    |                 |
       | Trompete   | Sägezahn 33 |     96     |     0    |                 |
       +------------+-------------+------------+----------+-----------------+ 

BEMERKUNG: Die Einstellungen für die Hüllkurve sollten immer gePOKEt werden,
bevor die Wellenform gePOKEt wird.

[SEITE E-2 * REGISTERZUORDNUNGEN BEIM SID UND VIC]

SPRITE REGISTER ZUORDNUNG

Basisadresse VIC =  53248dez = D000hex
+---------+------+------+------+------+------+------+------+------+----------+
|Register#|      |      |      |      |      |      |      |      |          |
|Dez Hex  | DB7  | DB6  | DB5  | DB4  | DB3  | DB2  | DB1  | DB0  |          |
+---------+------+------+------+------+------+------+------+------+----------+
|  0   0  | S0X7 | S0X6 | S0X5 | S0X4 | S0X3 | S0X2 | S0X1 | S0X0 | SPRITE 0X|
|         +------+------+------+------+------+------+------+------+----------+
|  1   1  | S0Y7 |      |      |      |      |      |      | S0Y0 | SPRITE 0Y|
|         +------+------+------+------+------+------+------+------+----------+
|  2   2  | S1X7 |      |      |      |      |      |      | S1X0 | SPRITE 1X|
|         +------+------+------+------+------+------+------+------+----------+
|  3   3  | S1Y7 |      |      |      |      |      |      | S1Y0 | SPRITE 1Y|
|         +------+------+------+------+------+------+------+------+----------+
|  4   4  | S2X7 |      |      |      |      |      |      | S2X0 | SPRITE 2X|
|         +------+------+------+------+------+------+------+------+----------+
|  5   5  | S2Y7 |      |      |      |      |      |      | S2Y0 | SPRITE 2Y|
|         +------+------+------+------+------+------+------+------+----------+
|  6   6  | S3X7 |      |      |      |      |      |      | S3X0 | SPRITE 3X|
|         +------+------+------+------+------+------+------+------+----------+
|  7   7  | S3Y7 |      |      |      |      |      |      | S3Y0 | SPRITE 3Y|
|         +------+------+------+------+------+------+------+------+----------+
|  8   8  | S4X7 |      |      |      |      |      |      | S4X0 | SPRITE 4X|
|         +------+------+------+------+------+------+------+------+----------+
|  9   9  | S4Y7 |      |      |      |      |      |      | S4Y0 | SPRITE 4Y|
|         +------+------+------+------+------+------+------+------+----------+
| 10   A  | S5X7 |      |      |      |      |      |      | S5XO | SPRITE 5X|
|         +------+------+------+------+------+------+------+------+----------+
| 11   B  | S5Y7 |      |      |      |      |      |      | S5YO | SPRITE 5Y|
|         +------+------+------+------+------+------+------+------+----------+
| 12   C  | S6X7 |      |      |      |      |      |      | S6X0 | SPRITE 6X|
|         +------+------+------+------+------+------+------+------+----------+
| 13   D  | S6Y7 |      |      |      |      |      |      | S6Y0 | SPRITE 6Y|
|         +------+------+------+------+------+------+------+------+----------+
| 14   E  | S7X7 |      |      |      |      |      |      | S7X0 | SPRITE 7X|
|         +------+------+------+------+------+------+------+------+----------+
| 15   F  | S7Y7 |      |      |      |      |      |      | S7Y0 | SPRITE 7Y|
|         +------+------+------+------+------+------+------+------+----------+
| 16  10  | S7X8 | S6X8 | S5X8 | S4X8 | S3X8 | S2X8 | S1X8 | S0X8 | Höchste  |
|         |      |      |      |      |      |      |      |      | Bits der |
|         |      |      |      |      |      |      |      |      | X-Werte  |
|         +------+------+------+------+------+------+------+------+----------+
| 17  11  | RC8  | ECS  | BSM  | BLNK | RSEL | YSCL2| YSCL1| YSCL0|          |
|         +------+------+------+------+------+------+------+------+----------+
| 18  12  | RC7  | RC6  | RC5  | RC4  | RC3  | RC2  | RC1  | RC0  |RASTER    |
|         +------+------+------+------+------+------+------+------+----------+
| 19  13  | LPX7 |      |      |      |      |      |      | LPX0 |LIGHTPEN X|
|         +------+------+------+------+------+------+------+------+----------+
| 20  14  | LPY7 |      |      |      |      |      |      | LPY0 |LIGHTPEN Y|
|         +------+------+------+------+------+------+------+------+----------+
| 21  15  | SE7  |      |      |      |      |      |      | SE0  |SPRITE    |
|         |      |      |      |      |      |      |      |      |ENABLE    |
|         |      |      |      |      |      |      |      |      |(EIN/AUS) |
|         +------+------+------+------+------+------+------+------+----------+
| 22  16  | N.C. | N.C. | RST  | MCM  | CSEL | XSCL2| XSCL1| XSCL0|          |
|         +------+------+------+------+------+------+------+------+----------+
| 23  17  | SEXY7|      |      |      |      |      |      | SEXY0|SPRITE    |
|         |      |      |      |      |      |      |      |      |EXPAND Y  |
+---------+------+------+------+------+------+------+------+------+----------+

[SEITE E-3 * REGISTERZUORDNUNGEN BEIM SID UND VIC]

+---------+------+------+------+------+------+------+------+------+----------+
|Register#|      |      |      |      |      |      |      |      |          |
| Dez Hex | DB7  | DB6  | DB5  | DB4  | DB3  | DB2  | DB1  | DBO  |          |
+---------+------+------+------+------+------+------+------+------+----------+
|  24  18 | VS13 | VS12 | VS11 | CB13 | CB12 | CB11 | CB10 | N.C. | Speicher-|
|         |      |      |      |      |      |      |      |      | bereich  |
|         |      |      |      |      |      |      |      |      | für Bild-|
|         |      |      |      |      |      |      |      |      | schirm-  |
|         |      |      |      |      |      |      |      |      | zeichen  |
+---------+------+------+------+------+------+------+------+------+----------+
|  25  19 | IRQ  | N.C. | N.C. | N.C. | LPIRQ| ISSC | ISBC | RIRQ | Interrupt|
|         |      |      |      |      |      |      |      |      | Requests |
+---------+------+------+------+------+------+------+------+------+----------+
|  26  1A | N.C. | N.C. | N.C. | N.C. | MLPI | MISSC| MISBC| MRIRQ| Interrupt|
|         |      |      |      |      |      |      |      |      | Request  |
|         |      |      |      |      |      |      |      |      | MASKS    |
+---------+------+------+------+------+------+------+------+------+----------+
|  27  1B | BSP7 |      |      |      |      |      |      | BSP0 | Hinter-  |
|         |      |      |      |      |      |      |      |      | grund    |
|         |      |      |      |      |      |      |      |      | Sprite   |
|         |      |      |      |      |      |      |      |      | PRIORITÄT|
+---------+------+------+------+------+------+------+------+------+----------+
|  28  1C | SCM7 |      |      |      |      |      |      | SCM0 | MULTI-   |
|         |      |      |      |      |      |      |      |      | COLOR    |
|         |      |      |      |      |      |      |      |      | SPRITE   |
|         |      |      |      |      |      |      |      |      | SELECT   |
+---------+------+------+------+------+------+------+------+------+----------+
|  29  1D | SEXX7|      |      |      |      |      |      | SEXX0| SPRITE   |
|         |      |      |      |      |      |      |      |      | EXPAND X |
+---------+------+------+------+------+------+------+------+------+----------+
|  30  1E | SSC7 |      |      |      |      |      |      | SSC0 | Sprite-  |
|         |      |      |      |      |      |      |      |      | Sprite   |
|         |      |      |      |      |      |      |      |      | KOLLISION|
+---------+------+------+------+------+------+------+------+------+----------+
|  31  1F | SBC7 |      |      |      |      |      |      | SBC0 | Sprite-  |
|         |      |      |      |      |      |      |      |      | Hinter-  |
|         |      |      |      |      |      |      |      |      | grund    |
|         |      |      |      |      |      |      |      |      | KOLLISION|
+---------+------+------+------+------+------+------+------+------+----------+
|         |                     FARBINFORMATION                   |          |
|  32  20 |      |      |      |      |      |      |      |      | Bildrand |
+---------+------+------+------+------+------+------+------+------+----------+
|  33  21 |      |      |      |      |      |      |      |      | Hinter-  |
|         |      |      |      |      |      |      |      |      | grund 0  |
+---------+------+------+------+------+------+------+------+------+----------+
|  34  22 |      |      |      |      |      |      |      |      | Hinter-  |
|         |      |      |      |      |      |      |      |      | grund 1  |
+---------+------+------+------+------+------+------+------+------+----------+
|  35  23 |      |      |      |      |      |      |      |      | Hinter-  |
|         |      |      |      |      |      |      |      |      | grund 2  |
+---------+------+------+------+------+------+------+------+------+----------+
|  36  24 |      |      |      |      |      |      |      |      | Hinter-  |
|         |      |      |      |      |      |      |      |      | grund 3  |
+---------+------+------+------+------+------+------+------+------+----------+
|  37  25 |      |      |      |      |      | Sprite Multicolor  | SMCO     |
+---------+------+------+------+------+------+--------------------+----------+
|  38  26 |      |      |      |      |      | Sprite Multicolor  | SMC1     |
+---------+------+------+------+------+------+------+------+------+----------+
|  39  27 |      |      |      |      |      |      |      |      | Farbe    |
|         |      |      |      |      |      |      |      |      | Sprite 0 |
+---------+------+------+------+------+------+------+------+------+----------+
|  40  28 |      |      |      |      |      |      |      |      | Farbe    |
|         |      |      |      |      |      |      |      |      | Sprite 1 |
+---------+------+------+------+------+------+------+------+------+----------+
|  41  29 |      |      |      |      |      |      |      |      | Farbe    |
|         |      |      |      |      |      |      |      |      | Sprite 2 |
+---------+------+------+------+------+------+------+------+------+----------+
|  42  2A |      |      |      |      |      |      |      |      | Farbe    |
|         |      |      |      |      |      |      |      |      | Sprite 3 |
+---------+------+------+------+------+------+------+------+------+----------+
|  43  2B |      |      |      |      |      |      |      |      | Farbe    |
|         |      |      |      |      |      |      |      |      | Sprite 4 |
+---------+------+------+------+------+------+------+------+------+----------+
|  44  2C |      |      |      |      |      |      |      |      | Farbe    |
|         |      |      |      |      |      |      |      |      | Sprite 5 |
+---------+------+------+------+------+------+------+------+------+----------+
|  45  2D |      |      |      |      |      |      |      |      | Farbe    |
|         |      |      |      |      |      |      |      |      | Sprite 6 |
+---------+------+------+------+------+------+------+------+------+----------+
|  46  2E |      |      |      |      |      |      |      |      | Farbe    |
|         |      |      |      |      |      |      |      |      | Sprite 7 |
+---------+------+------+------+------+------+------+------+------+----------+

Die Farbinformation entnehmen Sie bitte der Tabelle auf Seite 139.
Im Multicolor-Modus dürfen nur die Farbcodes 0 ... 7 benutzt werden.

[SEITE E-4 * REGISTERZUORDNUNGEN BEIM SID UND VIC]

80-Zeichen Video-Controller 8563

Der Video-Controller 8563 kann über die Adressen $D600 und $D601 angesprochen
werden. Die Übergabe eines Wertes an den Controller (Nur C128 Betriebsart)
geschieht folgendermaßen:

Übergabe der Registernummer (0-36) an Adresse $D600 (54784 dez.) und Übergabe
des Wertes an Adresse $D601 (54785 dez.)

Bsp.: Ändern des Vordergrund-Farbregisters 26

BANK15:POKE DEC("D600"),26:POKE DEC("D601"),9

Reg. (dez.)  Bits            Funktion
------------------------------------------------------------------------------
0            76543210        Gesamte Anzahl der Zeichen zwischen aufeinander
                             folgenden horizontalen Synchronimpulsen minus 1
 1           76543210        Anzahl der dargestellten Zeichen pro Zeile
 2           76543210        Position des horizontalen Synchronimpulses
 3           7654....        Breite des vertikalen Synchronimpulses
                             (Anzahl der Bildschirmzeilen)
             ....3210        Breite des horizontalen Synchronimpulses
                             (Zeichengenerator-Taktzyklen plus 1 )
 4           76543210        Gesamtzahl Zeichenzeilen minus 1
                             (Siehe auch Register 5)
 5           ...43210        Feinabgleich (Anzahl der Bildzeilen)
 6           76543210        Anzahl der dargestellten Zeilen
 7           76543210        Position des vertikalen Synchronimpulses
                             (Anzahl Zeichenzeilen)
 8           ......10        Anzeigeform
                             X0: Kein Zeilensprung
                             01: Zeilensprung
                             11: Zeilensprung doppelte Dichte
 9           ...43210        Anzahl der Bildschirmzeilen pro
                             Zeichenzeile minus 1
10           .65.....        Cursor Modus:
                             00: Cursor blinkt nicht
                             01: Kein Cursor sichtbar
                             10: Cursor blinkt mit 1/16 der Bildwiederhol-
                             frequenz
                             11: Cursor blinkt mit 1/32 der Bildwiederhol-
                             frequenz
             ...43210        Cursor Startadresse

[SEITE E-5 * REGISTERZUORDNUNGEN BEIM SID UND VIC]

80-Zeichen Video-Controller 8563

Reg. (dez.)  Bits            Funktion
------------------------------------------------------------------------------
11           ...43210        Cursor Endadresse
12           76543210        Startadresse des Bildschirmspeichers
                             (High Byte)
13           76543210        Startadresse des Bildschirmspeichers
                             (Low Byte)
14           76543210        Cursor-Position im Bildschirmspeicher
                             (High Byte)
15           76543210        Cursor Position im Bildschirmspeicher
                             (Low Byte)
16           76543210        Vertikale Light-Pen Position (In Zeichen-Zeilen
                             plus 1)
17           76543210        Horizontale Light-Pen Position (In Zeichen-Zeilen
                             plus 8)
18           76543210        Bildschirmspeicher-Adresse auf die sich der
                             nächste CPU- Lese-, oder Schreibbefehl bezieht
                             (High Byte)
19           76543210        Siehe Register 18 (Low Byte)
20           76543210        Startadresse des Attribut-Speichers (High Byte)
21           76543210        Startadresse des Attribut-Speichers (Low Byte)
22           7654....        Zeichenbreite in Pixel minus 1 (Inklusive Zei-
                             chenzwischenraum)
             ....3210        Zeichenbreite in Pixel minus 1 (Ohne Zeichen-
                             zwischenraum)
             ...43210        Anzahl der Bildschirmzeilen pro Zeichenzeile
                             minus 1 ohne vertikalen Zeichenabstand
             7.......        Block Copy  0: Block wird geschrieben nach einem
                                            Schreiben in Register 30
                                         1: Block wird kopiert nach einem
                                            Schreiben in Register 30
             .6......                    0: Normaldarstellung
                                         1: Reversdarstellung
             ..5.....        Blinkfrequenz der Buchstaben
                                         0: Blinkfrequenz = 1/16 der Bild-
                                            wiederholfrequenz
                                            1: Blinkfrequenz = 1 /32 der Bild-
                                            wiederholfrequenz

[SEITE E-6 * REGISTERZUORDNUNGEN BEIM SID UND VIC]

80-Zeichen Video-Controller 8563

Reg. (dez.)  Bits            Funktion
------------------------------------------------------------------------------
             ...43210        Anzahl der Bildschirmzeilen, die der Bildschirm
                             nach oben geschoben wird. Der Inhalt dieses
                             Registers sollte zwischen 0 und dem Inhalt des
                             Registers 9 liegen
25           7.......        Betriebsart  0: Textdarstellung
                                          1: Bit-Mapped-Darstellung
             .6......        Attribute    0: Attribute abgeschaltet
                                             (Vordergrundfarbe durch Register
                                             26 bestimmt)
                                          1: Vordergrundfarbe und Attribut
                                             sind im Attribut-Byte enthalten
             ..5.....        Semigrafik Betriebsart
                                          0: Der horizontale Zwischenraum
                                             zweier Zeichen wird in der
                                             Hintergrundfarbe dargestellt
                                          1: Der horizontale Zwischenraum
                                             zweier Zeichen wird in der
                                             gleichen Farbe dargestellt, wie
                                             das letzte normal dargestellte
                                             Zeichen.
             ...4...         Pixelgröße   0: Pixelgröße = 1 DOT-Takt
                                          1: Pixelgröße = 2 DOT-Takte
                             Horizontale Parameter müssen angepaßt werden
             ....3210        Anzahl der Pixel, die der Bildschirm nach links
                             geschoben wird. Der Wert dieses Registers sollte
                             zwischen dem Wert von Register 22 (Bit 4-7) und
                             0 (Inklusive) sein. Register 22 (Bits 0-3) sollte
                             um den Wert dieser 4 Bits erhöht werden, um eine
                             konstante Zeichenbreite zu erreichen
26           7654....        Vordergrundfarbe (RGBI), wenn Bit 6 von Register
                             25 = 0
             ....3210        Hintergrundfarbe für alle Zeichen und Rahmenfarbe
27           76543210        Wert, der zum Bildschirm- und Attributzeiger nach
                             jeder Zeile aufaddiert wird um die nächste Zeile
                             zu erhalten

[SEITE E-7 * REGISTERZUORDNUNGEN BEIM SID UND VIC]

80-Zeichen Video-Controller 8563

Reg. (dez.)        Bits                Funktion
------------------------------------------------------------------------------
28           765.....        Adresse des Zeichengenerators (Bits 13-15).
                             Vorher sollte Register 9 gesetzt werden
             ..4....         DRAM-Type (4416/4164)
                                       0: 4416
                                       1: 4164
29           ...43210        Bildschirmzeilenzähler für Unterstreichen
30           76543210        Anzahl der Block-Write oder Block-Copy Zyklen.
                             Eine 0 entspricht 256 Zyklen. Das Verändern
                             dieses Registers startet den Block-Zyklus
31           76543210        Daten für Block-Write und normales "Write".
                             Beim Lesen des Registers wird die durch Register
                             18/19 bestimmte Bildschirmposition übergeben
32           76543210        Block-Copy Quelladresse (Bits 15-8). Die Ziel-
                             adresse wird in Register 18/19 erwartet
33           76543210        Block-Copy Quelladresse (Bits 7-0)
34           76543210        Anzahl der Zeichen vom Beginn der dargestellten
                             Zeile bis zur positiven Flanke des Display-
                             enable-pins
35           76543210        Anzahl der Zeichen vom Beginn der dargestellten
                             Zeile bis zur negativen Flanke des Display-
                             enable-pins
36           ....3210        Anzahl der Refresh-Zyklen pro Bildschirmzeile

********************************
*     [Anhang F]:              *
*                              *
*     Musiknotentabelle        *
********************************

[SEITE F-1 * MUSIKNOTENTABELLE]

WERTE FÜR MUSIK-NOTEN

In diesem Anhang finden Sie ein vollständige Liste der Noten, zugehörigen
Frequenzen und Frequenzparameter und der Werte, die in die Register FREQ HI
und FREQ LO des Klangchips gePOKEt werden müssen, um den gewünschten Ton zu
erzeugen.

Nr.   Note-Oktave   Frequenz (Hz)   Parameter   Hi-Byte   Low-Byte

 0        C-0           16.4           278         1         22
 1        C#-0          17.3           295         1         39
 2        D-0           18.4           313         1         57
 3        D#-0          19.4           331         1         75
 4        E-0           20.6           351         1         95
 5        F-0           21.8           372         1        116
 6        F#-0          23.1           394         1        138
 7        G-0           24.5           417         1        161
 8        G#-0          26.0           442         1        186
 9        A-0           27.5           468         1        212
10        A#-0          29.1           496         1        240
11        H-0           30.9           526         2         14
12        C-1           32.7           557         2         45
13        C#-1          34.6           590         2         78
14        D-1           36.7           625         2        113
15        D#-1          38.9           662         2        150
16        E-1           41.2           702         2        190
17        F-1           43.7           743         2        231
18        F#-1          46.2           788         3         20
19        G-1           49.0           834         3         66
20        G#-1          51.9           884         3        116
21        A-1           55.0           937         3        169
22        A#-1          58.3           992         3        224
23        H-1           61.7          1051         4         27
24        C-2           65.4          1114         4         90
25        C#-2          69.3          1180         4        156
26        D-2           73.4          1250         4        226
27        D#-2          77.8          1325         5         45
28        E-2           82.4          1403         5        123
29        F-2           87.3          1487         5        207
30        F#-2          92.5          1575         6         39
31        G-2           98.0          1669         6        133
32        G#-2         103.8          1768         6        232
33        A-2          110.0          1873         7         81
34        A#-2         116.5          1985         7        193
35        H-2          123.5          2103         8         55
36        C-3          130.8          2228         8        180
37        C#-3         138.6          2360         9         56
38        D-3          146.8          2500         9        196
39        D#-3         155.6          2649        10         89
40        E-3          164.8          2807        10        247
41        F-3          174.6          2974        11        158
42        F#-3         185.0          3150        12         78
43        G-3          196.0          3338        13         10
44        G#-3         207.7          3536        13        208
45        A-3          220.0          3746        14        162
46        A#-3         233.1          3969        15        129
47        H-3          246.9          4205        16        109
48        C-4          261.6          4455        17        103
49        C#-4         277.2          4720        18        112
50        D-4          293.7          5001        19        137
51        D#-4         311.1          5298        20        178
52        E-4          329.6          5613        21        237
53        F-4          349.2          5947        23         59
54        F#-4         370.0          6301        24        157
55        G-4          392.0          6676        26         20
56        G#-4         415.3          7072        27        160
57        A-4          440.0          7493        29         69
58        A#-4         466.2          7939        31          3
59        H-4          493.9          8411        32        219
60        C-5          523.3          8911        34        207
61        C#-5         554.4          9441        36        225
62        D-5          587.3         10002        39         18
63        D#-5         622.3         10597        41        101
64        E-5          659.3         11227        43        219
65        F-5          698.5         11894        46        118
66        F#-5         740.0         12602        49         58
67        G-5          784.0         13351        52         39
68        G#-5         830.6         14145        55         65
69        A-5          880.0         14986        58        138
70        A#-5         932.3         15877        62          5
71        H-5          987.8         16821        65        181
72        C-6         1046.5         17821        69        157
73        C#-6        1108.7         18881        73        193
74        D-6         1174.7         20004        78         36
75        D#-6        1244.5         21193        82        201
76        E-6         1318.5         22454        87        182
77        F-6         1396.9         23789        92        237
78        F#-6        1480.0         25203        98        115
79        G-6         1568.0         26702       104         78
80        G#-6        1661.2         28290       110        130
81        A-6         1760.0         29972       117         20
82        A#-6        1864.7         31754       124         10
83        H-6         1975.5         33642       131        106
84        C-7         2093.0         35643       139         59
85        C#-7        2217.5         37762       147        130
86        D-7         2349.3         40008       156         72
87        D#-7        2489.0         42387       165        147
88        E-7         2637.0         44907       175        107
89        F-7         2793.8         47578       185        218
90        F#-7        2960.0         50407       196        231
91        G-7         3136.0         53404       208        156
92        G#-7        3322.4         56580       221          4
93        A-7         3520.0         59944       234         40
94        A#-7        3729.3         63508       248         20

  Sie sind nicht an die Werte dieser Tabelle gebunden! Wenn Sie mehrere
Stimmen benutzen, sollten Sie sogar bewußt die zweite und dritte Stimme
etwas "verstimmen", d. h. das Lo-Byte aus der Tabelle leicht (!) abändern.
Sie bekommen so einen volleren Klang.

***************************************
*     [ANHANG G]:                     *
*                                     *
*     Besonderheiten im C64-Modus     *
*     (Funkt.-Tasten, Grafik)         *
***************************************

[SEITE G-1 * BESONDERHEITEN IM C64-MODUS]

ABFRAGE DER DREHREGLER UND STEUERKNÜPPEL

Abfrage der Drehregler (Paddles):

Sind die Drehregler in Port 1 eingesteckt, so werden die Werte, die
den Stellungen der Potentionmeter entsprechen, in die Adressen 54297
und 54298 eingelesen.
  Das Drücken der Feuerknöpfe wird in der Adresse 56321 registriert.
Dort wird Bit 2 bzw. Bit 3 gelöscht.
  Die Drehregler in Port 2 benutzen für die Abfrage der Feuerknöpfe
die Adresse 56320. Die Potentiometerpositionen werden in denselben
Adressen registriert wie bei Port 1.
  Die Umschaltung auf Port 2 geschieht durch Setzen von Bit 7 in
Adresse 56320. Da dieses Bit jedoch bei jedem Interrupt zurückgesetzt
wird, ist die Abfrage der Paddles am Port 2 nur in Verbindung mit einem
Maschinenprogramm möglich.


Abfrage der Steuerknüppel (Joysticks)

Die Abfrage der Joysticks geschieht in den Adressen 56321 (Port 1) und
56320 (Port 2). Den 4 Richtungen des Joysticks (oben, unten, links,
rechts) entspricht das Löschen der Bits 0, 1, 2 und 3. Bei Betätigen
der Feuerknöpfe wird Bit 4 im jeweiligen Register gelöscht.

[SEITE G-2 * BESONDERHEITEN IM C64-MODUS]

BELEGUNG DER FUNKTIONSTASTEN

Die Funktionstasten (f1 bis f8) entsprechen den ASCII-Codes 133 bis
140 (vergl. Liste der ASCII-Codes). Die Abfrage des Tastaturpuffers
kann in etwa in Form einer GET-Schleife geschehen, wie im folgenden
Programm gezeigt wird:

        1 REM FUNKTIONSTASTEN
        10 GETA$:IFA$=""THEN 10
        20 IFA$=CHR$(133)THEN 40
        30 GOTO 10
        40 PRINT"F1-TASTE WURDE GEDRUECKT"
        50 GOTO 10
        READY.

**************************************
*     [ANHANG H]:                    *
*                                    *
*     Organisation der Zero Page     *
**************************************

[SEITE H-1 * ORGANISATION DER ZERO PAGE]

SPEICHERBELEGUNG IM C64-MODUS

 (* =nützliche Adressen)

 Hex                  Dezimal         Beschreibung

 0000                 0               6510 Daten Richtungsregister
 0001                 1               6510 Ausgaberegister
 0002                 2               nicht benutzt
 0003 - 0004          3 - 4           Vektor zur Umrechnung Float - Fixed
 0005 - 0006          5 - 6           Vektor zur Umrechnung Fixed - Float
 0007                 7               Suchzeichen
 0008                 8               Flag für Gänsefüßchen Modus
 0009                 9               TAB Spaltenzähler
 000A                10               0 = LOAD, 1 = VERIFY
 000B                11               Zeiger für Eingabepuffer /
                                      Anzahl Elemente
 000C                12               Flag für Standard DIM
 000D                13               Typ: FF = String, 00 = numerisch
 000E                14               Typ: 80 = Integer, 00 = Fließkomma
 000F                15               Flag für DATA / LIST
 0010                16               Element / FNx Flag
 0011                17               00 = INPUT, 40 = GET, 98 = READ
 0012                18               Vorzeichen des ATN
                                      Flag für Gleichheit bei Vergleich
 0013                19               aktuelles E/A Gerät
*0014 - 0015         20 - 21          Integer Wert
 0016                22               Zeiger auf temporären Stringstapel
 0017 - 0018         23 - 24          Letzter temporärer String Vektor
 0019 - 0021         25 - 33          Stapel für temporäre Strings
 0022 - 0025         34 - 37          Bereich für Hilfszeiger
 0026 - 002A         38 - 42          Bereich für Produkt bei Multiplikation
*0028 - 002C         43 - 44          Zeiger auf Basic Anfang
*002D - 002E         45 - 46          Zeiger auf Variablen Anfang
*002F - 0030         47 - 48          Zeiger auf Beginn der Arrays
*0031 - 0032         49 - 50          Zeiger auf Ende der Arrays
*0033 - 0034         51 - 52          Zeiger auf Stringspeicher
                                      (bewegt sich abwärts)
 0035 - 0036         53 - 54          Hilfszeiger für Strings
*0037 - 0038         55 - 56          Zeiger auf Speichergrenze
 0039 - 003A         57 - 58          Nummer der aktuellen Basic Zeile

[SEITE H-2 * ORGANISATION DER ZERO PAGE]

 Hex                  Dezimal         Beschreibung

 003B - 003C         59 - 60          Nummer der vorhergehenden Basic-Zeile
 003D - 003E         61 - 62          Zeiger auf Basic Statement für CONT
 003F - 0040         63 - 64          Nummer der aktuellen DATA Zeile
 0041 - 0042         65 - 66          Adresse des aktuellen DATA Elements
*0043 - 0044         67 - 68          Sprungvektor für Input
 0045 - 0046         69 - 70          aktueller Variablenname
 0047 - 0048         71 - 72          Adresse der aktuellen Variablen
 0049 - 004A         73 - 74          Variablenzeiger für FOR...NEXT
 0048 - 004C         75 - 76          Zwischenspeicher für Basic Zeiger
 004D                77               Akkumulator für Vergleichssymoble
 004E - 0053         78 - 83          verschieden genutzter Arbeitsbereich
                                      (Zeiger, usw.)
 0054 - 0056         84 - 86          Sprungvektor für Funktionen
 0057 - 0060         87 - 96          verschieden genutzter Bereich für
                                      numerische Operationen
*0061                97               Fließkomma Akkumulator#1
                                      (FAC): Exponent
*0062 - 0065         98 - 101         Fließkomma Akkumulator#1
                                      (FAC): Mantisse
*0066               102               Fließkomma Akkumulator#1
                                      (FAC): Vorzeichen
 0067               103               Zeiger für Polynom Auswertung
 0069 - 006E        105 - 110         Fließkomma Akkumulator#2
                                      Exponent usw.
 006F               111               Vorzeichen Vergleich Akku#1 / Akku #2
 0070               112               niederwertige Stelle Akku#1 (Rundung)
 0071 - 0072        113 - 114         Länge des Kassettenpuffers
*0073 - 008A        115 - 138         CHRGET Subroutine (hole ein Zeichen)
 007A - 0078        122 - 123         Basic Zeiger innerhalb der Subroutine
 0088 - 008F        139 - 143         Startwert des Zufallgenerators
*0090               144               Statusbyte ST
 0091               145               Flag für STOP und RVS Taste
 0092               146               Zeitkonstante für Kassette
 0093               147               0 = LOAD, 1 = VERIFY
 0094               148               serieller Ausgang: Flag für
                                      zurückgestelltes Zeichen

[SEITE H-3 * ORGANISATION DER ZERO PAGE]

 Hex                  Dezimal         Beschreibung

 0095               149               zurückgestelltes Zeichen
 0096               150               EOT von Kassette empfangen
                                      (Cassette Sync #)
 0097               151               Speicher für Register
*0098               152               Anzahl offener Files
*0099               153               Eingabegerät (normal = 0)
*009A               154               Ausgabe (CMD) Gerät (normal = 3)
 0098               155               Paritätsbyte von Band
 009C               156               Flag für Byte empfangen
 009D               157               Ausgabe Kontrolle (80 = direkt,
                                      00 = RUN)
 009E               158               Fehler vom Band / Zeichenpuffer
 009F               159               Fehler vom Band korrigiert
*00A0 - 00A2        160 - 162         interne Uhr (HML)
 00A3               163               serieller Bit Zähler
                                      Flag für EOI
 00A4               164               Zyklen Zähler
 00A5               165               Abwärtszähler beim Schreiben
                                      auf Kassette
 00A6               166               Zeiger auf Kassettenpuffer
 00A7 - 00AB        167 - 171         Flags für Schreiben und Lesen
                                      von Kassette
 00AC - 00AD        172 - 173         Zeiger für Prg.Start
 00AE - 00AF        174 - 175         Zeiger für Programmende
 00B0 - 00B1        176 - 177         Zeitkonstanten für Band
*00B2 - 00B3        178 - 179         Zeiger auf Anfang des Kassettenpuffers
 00B4               180               Band Timer (1 = gesetzt), Bit Zähler
 00B5               181               Band EOT / RS 232 nächstes Bit
                                      zum Senden
 00B6               182               ***
*00B7               183               Anzahl Zeichen im Filenamen
*00B8               184               aktuelle logische Filenummer
*00B9               185               aktuelle Sekundäradresse
*00BA               186               aktuelles Gerät
*00BB - 00BC        187 - 188         Zeiger auf Filenamen
 00BD               189               ***
 00BE               190               Anzahl zum Lesen/Schreiben verbleibender
                                      Blocks

[SEITE H-4 * ORGANISATION DER ZERO PAGE]

 Hex                  Dezimal         Beschreibung

 00BF               191               serieller Wortpuffer
 00C0               192               Kassettenmotor Flag
 00C1 - 00C2        193 - 194         E/A Startadresse
 00C3 - 00C4        195 - 196         Zeiger auf Vektoradressen des KERNAL
*00C6               198               Anzahl Zeichen im Tastaturpuffer
*00C7               199               RVS Flag für Bildschirm
 00C8               200               Zeiger auf Zeilenende für Eingabe
 00C9 - 00CA        201 - 202         Position des Eingabecursors (Zeile,
                                      Spalte)
*00CB               203               gedrückte Taste (64=keine Taste)
 00CC               204               Cursor an/aus (0=Cursor blinkt)
 00CD               205               Zähler für blinkenden Cursor
 00CE               206               Zeichen in Cursorposition
 00CF               207               Cursor in Blinkphase
 00D0               208               Eingabe von Bildschirm/Tastatur
*00D1 - 00D2        209 - 210         Zeiger auf Bildschirmzeile
*00D3               211               Zeiger auf Bildschirmspalte
 00D4               212               0=direkter Cursor, sonst programmiert
                                      (QUOTE MODE)
*00D5               213               Länge der aktuellen Bildschirmzeile
                                      (40/80)
*00D6               214               Zeile, in der sich der Cursor befindet
 00D7               215               Letzte Taste/Prüfsumme/Puffer
*00D8               216               Anzahl ausstehender Inserts
*00D9 - 00F0        217 - 240         Bildschirmzeilen Verknüpfungstabelle
 00F1               241               unechte Bildschirmzeile
 00F2               242               Bildschirmzeilen Marke
*00F3 - 00F4        242 - 244         Zeiger auf Bildschirm Farbe
 00F5 - 00F6        245 - 246         Zeiger auf Tastatur Decodiertabelle
 00F7 - 00F8        247 - 248         R5232 Empfangszeiger
 00F9 - 00FA        249 - 250         R5232 Übertragungszeiger
*00FB - 00FE        251 - 254         Freier Platz in Page 0 für Betriebs-
                                      system
 00FF               255               Basic Speicher
 0100 - 010A        256 - 266         Arbeitsbereich zur Umwandlung von
                                      Fließkomma in ASCII
 0100 - 013E        256 - 318         Bandfehler
 0100 - 01FF        256 - 511         Bereich des Prozessor Stapels
*0200 - 0258        512 - 600         Basic Eingabepuffer

[SEITE H-5 * ORGANISATION DER ZERO PAGE]

 Hex                  Dezimal         Beschreibung

*0259 - 0262        601 - 610         Tabelle der logischen Files
*0263 - 026C        611 - 620         Tabelle der Gerätenummern
*026D - 0276        621 - 630         Tabelle der Sekundäradressen
*0277 - 0280        631 - 640         Tastaturpuffer
*0281 - 0282        641 - 642         Startadresse des RAM für Betriebssystem
*0283 - 0284        642 - 644         Ende des RAM für Betriebssystem
 0285               645               Flag für Zeitüberschreitung auf
                                      seriellem Bus
*0286               646               aktueller Farbcode
 0287               647               Farbe unter Cursor
*0288               648               Bildschirmspeicher Adresse (Page)
*0289               649               maximale Größe des Tastaturpuffers
*028A               650               Tastenwiederholung (128=alle Tasten)
*0288               651               Zähler für Wiederholungsgeschwindigkeit
 028C               652               Zähler für Wiederholungsverzögerung
*028D               653               Flag für SHIFT/CNTRL
 028E               654               letztes SHIFT Muster der Tastatur
 028F - 0290        655 - 656         Zeiger auf Tastatur Decodiertabelle
*0291               657               SHIFT Modus (0=gesetzt, 128=blockiert)
 0292               658                automat. Scrolling abwärts (0=ein
                                      >0=aus)
 0293               659               R5232 Kontrollregister
 0294               660               R5232 Befehlsregister
 0285 - 0296        661 - 662         nicht Standard (Bit Zeit)
                                      ***
 0297               663               R5232 Statusregister
 0298               664               Anzahl zu sendender Bits
 0299 - 029A        665 - 666         Baud Rate
 0298               667               R5232 Empfangszeiger > receive
 029C               668               R5232 Eingabezeiger  > receive
 029D               669               R5232 Übertragungszeiger > send
 029E               670               R5232 Ausgabezeiger      > send
 029F - 02A0        271 - 672         enthält IRQ-Vektor während Kassetten-
                                      betrieb
 02A1 - O2FF        673 - 767         ***
*0300 - 0301        768 - 769         Vector für Fehlermeldungen

[SEITE H-6 * ORGANISATION DER ZERO PAGE]

 Hex                  Dezimal         Beschreibung

 0302 - 0303        770 - 771         Vector für Basic Warmstart
 0304 - 0305        772 - 773         Umwandlung von Schlüsselwörtern in
                                      Tokens
 0306 - 0307        774 - 775         Umwandlung der Tokens in Schlüsselwörter
 0308 - 0309        776 - 777         neuen Basic Befehl ausführen
 030A - 0308        778 - 779         arithmetisches Element holen
 030C               780               Speicher für 6502 "A Register
 030D               781               Speicher für 6502 "X Register
 030E               782               Speicher für 6502 "Y Register
 030F               783               Speicher für 6502 "P Register
 0310 - 0313        784 - 787         USR Sprung
 0314 - 0315        788 - 789         Hardware Interrupt (IRQ) (EA31)
 0316 - 0317        790 - 791         Break Interrupt (FE66)
 0318 - 0319        792 - 793         nicht maskierbarer Interrupt (NMI)
                                      (FE47)
 031A - 031B        794 - 795         OPEN (F40A) (F34A)
 031C - 031D        796 - 797         CLOSE (F291 )
 031E - 031F        798 - 799         Kanal für Eingabe (F2C7) (F209)
 0320 - 0321        800 - 801         Kanal für Ausgabe (F250)
 0322 - 0323        802 - 803         Wiederherstellung der E/A
                                      (Löschen aller offenen Kanäle (F333)
 0324 - 0325        804 - 805         INPUT (F157)
 0326 - 0327        806 - 807         OUTPUT (F1CA)
 0328 - 0329        808 - 809         STOP-Taste prüfen (F770)
                                      (F6ED)
 032A - 0328        810 - 811         GET (Fl3E)
 032C - 032D        812 - 813         Close aller Kanäle (F32F)
 032E - 032F        814 - 815         Benutzer-IRO (FE66)
 0330 - 0331        816 - 817         RAM laden (F4A5)
 0332 - 0333        818 - 819         RAM speichern (FSED)
 0334 - 033B        820 - 827         ***
 033C - O3FB        828 - 1019        Kassettenpuffer
 0400 - O7FF       1024 - 2047        1 K Bildschirmspeicher
(0400 - 07E7       1024 - 2023        Video Matrix)
(07F8 - O7FF       2040 - 2047        Zeiger für Sprites)
 0800 - 9FFF       2048 - 40959       Basic Benutzerspeicher
 A000 - BFFF      40960 - 49151       8K Basic ROM
 C000 - CFFF      49152 - 53247       4K RAM

[SEITE H-7 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0000 00000 D8502        8502 Datenrichtungs-register
0001 00001 R8502        8502 Datenregister
0002 00002 BANK         Monitor und Long-Call/Jump-Register
0003 00003 PC-HI        Register für Befehlszähler High
0004 00004 PC-LO        Register für Befehlszähler Low
0005 00005 S-REG        Register für Statusbyte
0006 00006 A-REG        Register für Akkumulator
0007 00007 X-REG        X-Register
0008 00008 Y-REG        Y-Register
0009 00009 STKPTR       Stapelzeiger

Basic Zero-Page

0009 00009 INTEGR       Temporärer Speicher für den Integer-Wert bei OR/AND
0009 00009 CHARAC       Suchzeichen
OOOA 00010 ENDCHR       Flag: Suchen nach einem Ausführungszeichen am Ende
                        eines Strings
OOOB 00011 TRMPOS       Bildschirmspalte ab letztem TAB
OOOC 00012 VERCK        Flag: 0=LOAD, 1 =VERIFY
OOOD 00013 COUNT        Eingabepuffer, Anzahl der Elemente
OOOE 00014 DIMFLG       Flag: Standard-Felddimensionierung
OOOF 00015 VALTYP       Datentyp: $FF=String, $00=numerisch
0010 00016 INTFLG       Datentyp: $80=Ganze Zahl, $00=Gleitkomma
0011 00017 GARBFL       Flag: DATAs lesen, LIST, Garbage-Collection
0011 00017 DORES
0012 00018 SUBFLG       Flag: Benutzerfunktionsaufruf
0013 00019 INPFLG       Flag: $00=INPUT, $40=GET, $98=READ
0014 00020 DOMASK

[SEITE H-8 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0014 00020 TANSGN       Flag: Vorzeichen des TAN/Flag für Gleichheit bei
                        Vergleich
0015 00021 CHANNL       Momentanes I/0-Gerät
0015 00021 POKER        Poke-Adresse
0016 00022 LINNUM       Zeilennummer Integer, oder 2-Byte-Adresse für GOTO,
                        GOSUB,POKE,PEEK,SYS,WAIT
0018 00024 TEMPPT       Zeiger: Temporärer Stringstapel
0019 00025 LASTPT       Letzte Stringadresse
001B 00027 TEMPST       Stapel für temporäre Strings
0024 00036 INDEX        Bereich für Hilfszeiger
0024 00036 INDEX1
0024 00036 INDEX2
0028 00040 RESHO        Gleitkomma-Ergebnis der Multiplikation
0029 00041 RESMOH
002A 00042 ADDEND
002A 00042 RESMO
0028 00043 RESLO
002D 00045 TXTTAB       Zeiger: Anfang Basic-Text
002F 00047 VARTAB       Zeiger: Anfang Basic-Variablen
0031 00049 ARYTAB       Zeiger: Anfang Basic-Felder
0033 00051 STREND       Zeiger: Ende Basic-Felder + 1
0035 00053 FRETOP       Zeiger: Anfang der Stringspeicherung
0037 00055 FRESPC       Hilfszeiger für Strings
0039 00057 MAX-MEM-1    Oberste String/Variablen Adresse in Bank 1
0038 00059 CURLIN       Derzeitige Basic-Zeilennummer
003D 00061 TXTPTR       Zeiger auf Basic-Text für CHRGET, etc.
003F 00063 FORM         Wird von PRINT USING benutzt
003F 00063 FNDPNT       Zeiger auf gefundenes Byte (Von SEARCH)
0041 00065 DATLIN       Derzeitige DATA-Zeilennummer
0043 00067 DATPTR       Derzeitige DATA-Adresse

[SEITE H-9 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0045 00069 INPPTR       Vektor:INPUT-Routine
0047 00071 VARNAM       Derzeitiger Basic-Variablenname
0049 00073 FDECPT
0049 00073 VARPNT       Adresse der aktuellen Variablen
0048 00075 LSTPNT
0048 00075 ANDMSK
0048 00075 FORPNT       Variablenzeiger für FOR/NEXT
0048 00075 EORMSK
004D 00077 VARTXT
004D 00077 OPPTR        Zwischenspeicher für Basic-Zeiger/Daten
004F 00079 OPMASK       Vergleichs-Maske, größer = $01, gleich = $02,
                        kleiner= $04
0050 00080 GRBPNT
0050 00080 TEMPF3
0050 00080 DEFPNT       Zeiger auf Variable einer DEF FN-Funktion
0052 00082 DSCPNT       Zeiger auf String-Diskriptor in einer Variablen-Liste
0055 00085 HELPER       Flag: HELP oder LIST
0056 00086 JMPER
0058 00088 OLDOV
0059 00089 TEMPF1       Temporärer Zeiger, temporärer Gleitpunktakkumulator
005A 00090 ARYPNT       Zeiger zur Initialisierung bei einem DIM-Befehl
005A 00090 HIGHDS
005C 00092 HIGHTR       Zeiger, der von der Block Transfer Routine benutzt
                        wird
005E 00094 TEMPF2
005F 00095 DECCNT
0061 00097 GRBTOP
0061 00097 DPTFLG       Wird auf $80 gesetzt, wenn ein Eingabestring (Zahl)
                        einen Dezimalpunkt enthält
0061 00097 LOWTR

[SEITE H-10 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0062 00098 EXPSGN       Vorzeichen des Exponenten, $80 = negativ
0063 00099 FAC1         Gleitkommaakkumulator #1, besteht aus dem Exponenten,
                        4 Bytes für die Mantisse, und einem Vorzeichen-Byte.
                        Integer-Ergebnisse werden in FAC 1+3 und FAC 1+4
                        abgespeichert
0069 00105 DEGREE
0069 00105 SGNFLG       Zeiger für Polynomauswertung
006A 00106 ARGEXP       Gleitkommaakkumulator #2, Exponent, 4 Byte Mantisse,
                        Vorzeichenbyte
0070 00112 STRNG1
0070 00112 ARISGN       Vorzeichenvergleich Akku # 1 mit Akku #2. $00=gleiches
                        Vorzeichen, $FF=unterschiedlich
0071 00113 FACOV        Akku # 1, niederwertige Stelle, Rundung
0072 00114 STRNG2
0072 00114 POLYPT
0072 00114 CURTOL
0072 00114 FBUFPT       Zeiger: Kassettenpuffer
0074 00116 AUTINC       Inkrement beim AUTO-Befehl, $00=aus
0076 00118 MVDFLG       Flag: Gesetzt, wenn 1OK Byte für Hires-Grafik reser-
                        viert
0077 00119 NOZE         Anzahl führender Nullen beim PRINT USING-Befehl
0077 00119 SPRNUM       Temporärer Speicher bei SPRITE-und MOVSPR-Befehlen
0077 00119 KEYNUM       Temporärer Speicher für MID$-Befehl
0078 00120 HULP         Zähler
0078 00120 KEYSIZ
0079 00121 SYNTMP       Temporärer Speicher bei indirektem Laden

[SEITE H-11 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
007A 00122 DSDESC       Deskriptor für DS$
007D 00125 TOS          Obergrenze des Run-Time-Stack
007F 00127 RUNMOD       Flag: RUN/DIRECT-Modus
0080 00128 PARSTS       DOS Statuswort, Syntaxcheck
0080 00128 POINT        Zeiger bei PRINT USING auf Dezimalpunkt
0081 00129 PARSTX
0082 00130 OLDSTK

Zero-Page für Grafik

0083 00131 COLSEL       Ausgewählte aktuelle Farbe
0084 00132 MULTICOLOR-1
0085 00133 MULTICOLOR-2
0086 00134 FOREGROUND   Vordergrundfarbe
0087 00135 SCALE-X      SCALE-Faktor in X-Richtung
0089 00137 SCALE-Y      SCALE-Faktor in Y-Richtung
0088 00139 STOPNB       Vergleichsregister für PAINT
008C 00140 GRAPNT
008E 00142 VTEMP1
008F 00143 VTEMP2

Zero-Page für Kernal/Editor

0090 00144 STATUS       Statusbyte bei I/O-Operationen
0091 00145 STKEY        Flag: STOP-Taste
0092 00146 SVXT         Zeit-Konstante für Kassette
0093 00147 VERCK        Flag: $00=LOAD. $01 =VERIFY
0094 00148 C3PO         Flag: Serieller Bus-Zeichen im Buffer
0095 00149 BSOUR        Zeichen im Puffer für seriellen Bus
0096 00150 SYNO         Kassetten SYNC.-Nr. (EOT von Kassette empfangen)
0097 00151 XSAV         Temporäre Datenadresse
0098 00152 LDTND        Anzahl der offenen
                        Dateien/Dateitabellen-Index
0099 00153 DFLTN        Standard-Eingabegerät
009A 00154 DFLTO        Standard-Ausgabegerät

[SEITE H-12 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0098 00155 PRTY         Paritätsbyte von Kassette
009C 00156 DPSW         Flag: Byte empfangen
009D 00157 MSGFLG       Flag: $80=Direktmodus,$00=Programm
009E 00158 PTR1         Bandfehler/Zeichenpuffer
009E 00158 T1           Temporärer Speicher
009F 00159 PTR2         Bandfehler korrigiert
009F 00159 T2           Temporärer Speicher
00A0 00160 TIME         Echtzeituhr (ca.) 1/60 s
00A3 00163 R2D2         Temporärer Datenbereich
00A3 00163 PCNTR        Temporärer Speicher (Kassette)
00A4 00164 BSOUR1       Temporärer Speicher (Serielle-Routine)
00A5 00165 COUNT        Temporärer Speicher (Serielle-Routine)
00A5 00165 CNTDN        Kassetten Sync.: Abwärtszählung beim Schreiben
00A6 00166 BUFPT        Zeiger: Kassettenpuffer
00A7 00167 INBIT        RS-232-Eingabebits/Kassette temporär
00A8 00168 BITCI        RS-232-Eingabebit-Zählung/Kassette temporär
00A9 00169 RINONE       RS-232-Startbit-Überprüfung
00AA 00170 RIDATA       RS-232-Eingabebyte-Puffer/Kassette temporär
00AB 00171 RIPRTY       RS-232-Eingabeparität/Kassette, Zählung
00AC 00172 SAL          Zeiger: Kassettenpuffer/Bildschirm scrollen
00AE 00174 EAL          Kassettenende/Programmende
00BO 00176 CMPO         Kassetten-Zeit-Konstante
00B2 00178 TAPE1        Zeiger: Anfang des Kassettenpuffers
00B4 00180 BITTS        RS-232-Bitzähler (Senden)
00B5 00181 NXTBIT       RS-232-Nächstes zu übertragendes Bit
00B6 00182 RODATA       RS-232-Bytepuffer
00B7 00183 FNLEN        Länge des aktuellen Dateinamens

[SEITE H-13 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
00B8 00184 LA           Logische Dateinummer
00B9 00185 SA           Aktuelle Sekundäradresse
00BA 00186 FA           Aktuelle Gerätenummer
00BB 00187 FNADR        Zeiger: Aktueller Dateiname
00BD 00189 ROPRTY       RS-232-Parität/Kassette temporär
00BE 00190 FSBLK        Anzahl der zum Lesen/Schreiben verbleibenden Blocks
                        (Kassette)
00BF 00191 DRIVE
00C0 00192 CAS1         Kassettenmotor-Flag
00C1 00193 STAL         Ein-/Ausgabe-Startadresse (Low)
00C2 00194 STAH         Ein-/Ausgabe-Startadresse (High)
00C3 00195 MEMUSS       Temporärer Speicher (Zeiger)
00C5 00197 DATA         Kassette: Schreib-/Lese-Daten
00C6 00198 BA           Aktuelle Bank für LOAD/SAVE/VERIFY-Operationen
00C7 00199 FNBANK       Bank, in der sich der aktuelle Filenamen befindet
00C8 00200 RIBUF        RS-232-Eingabepuffer-Zeiger
00CA 00202 ROBUF        RS-232-Ausgabepuffer-Zeiger

Zero-Page für 40/80-Zeichen Editor

00CC 00204 KEYTAB       Vektor: Tastatur-Decodiertabelle
00CE 00206 IMPARM       Hilfszeiger für Strings
00D0 00208 NDX          Anzahl der Zeichen im Tastaturpuffer (Warteschlange)
00D1 00209 KYNDX        Zähler für Zeichen einer Funktionstaste
00D2 00210 KEYIDX       Zeiger auf String einer Funktionstaste
00D3 00211 SHFLAG       Flag für: SHIFT/CONTROL/COMMODORE-Taste
00D4 00212 SFDX         Nummer der augenblicklich gedrückten Taste
00D5 00213 LSTX         Nummer der zuletzt gedrückten Taste

[SEITE H-14 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
00D6 00214 CRSW         RETURN-Input-Flag
00D7 00215 MODE         40/80-Zeichen-Flag $00=40-/$80=80-Zeichen
00D8 00216 GRAPHM       Text/Grafik-Flag
00D9 00217 CHAREN       Ram/Rom-Flag für Video-Chip (40-Zeichen), Bit 2
00DA 00218 SEDSAL       Bildschirmeditor: Startadresse Zeile
00DC 00220 SEDEAL       Bildschirmeditor: Endadresse Zeile
00DE 00222 SEDT1        Temporärer Speicher für Editor
00DF 00223 SEDT2        Temporärer Speicher für Editor
00DA 00218 KEYSIZ       Register für Funktionstasten
00DB 00219 KEYLEN
00DC 00220 KEYNUM
00DD 00221 KEYNXT
00DE 00222 KEYBNK
00DF 00223 KEYTMP
00DA 00218 BITMSK       Temporäres Register für TAB und Zeilenüberlauf (Line
                        Wrap)
00DB 00219 SAVER        Temporäres Register

[SEITE H-15 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Die folgenden Adressen beziehen sich auf den gerade aktuellen Bildschirm
(40- oder 80-Zeichen) und werden nach Bedarf in einen anderen Speicherbereich
($0A40) kopiert. Damit bleiben die jeweilige Cursorposition, Fensterdefinition
u. dgl. auch bei einem Wechsel von 40- auf 80-Zeichen, oder umgekehrt, er-
halten.

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
00EO 00224 PNT          Zeiger auf aktuelle Zeile (Text)
00E2 00226 USER         Zeiger auf aktuelle Zeile (Attribute)
00E4 00228 SCBOT        Fenster-Untergrenze
00E5 00229 SCTOP        Fenster-Obergrenze
00E6 00230 SCLF         Fenster-linker Rand
00E7 00231 SCRT         Fenster-rechter Rand
00E8 00232 LSXP         Aktuelle Eingabe-Spalte, Start
00E9 00233 LSTP         Aktuelle Eingabe-Zeile, Start
00EA 00234 INDX         Aktuelle Eingabe-Zeile, Ende
00EB 00235 TBLX         Aktuelle Cursor-Zeile
00EC 00236 PNTR         Aktuelle Cursor-Spalte
00ED 00237 LINES        Maximale AnzahI der Zeilen
00EE 00238 COLUMNS      Maximale Anzahl der Bildschirmfarben
00EF 00239 DATAX        Nächstes auszugebendes Zeichen
00F0 00240 LSTCHR       Vorhergehendes Zeichen (für ESC-Test)
00F1 00241 COLOR        Attribut des nächsten auszugebenden Zeichens
                        (Standard: Vordergrundfarbe)
00F2 00242 TCOLOR       Temporäres Register für die Farbe des Zeichens (Insert
                        & Delete)
00F3 00243 RVS          Reverse-Flag
00F4 00244 OTSW         Anführungszeichen-Flag
00F5 00245 INSRT        Einfügemodus-Flag
00F6 00246 INSFLG       Flag für automatisches Einfügen
00F7 00247 LOCKS        Verhindert Commodore/Shift und Ctrl-S
00F8 00248 SCROLL       Verhindert Bildschirmscrollen und Zeilenverknüpfung
00F9 00249 BEEPER       Verhindert Ctrl-G (Beil)
00FF 00255 LOFBUF

[SEITE H-16 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Die folgenden Adressen werden nicht vom Monitor benutzt

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0002 00002 PCB
0003 00003 PCH
0004 00004 PCL
0005 00005 FLGS
0006 00006 ACC
0007 00007 XR
0008 00008 YR
0009 00009 SP
007A 00122 TXTPTR

Basis/DOS-Bereich

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0100 00256 FBUFFR       Bereich für den Filenamen
                        (16-Zeichen)
0110 00272 XCNT         Zähler für das DOS
0111 00273 DOSF1L       Länge des Filenamens 1
0112 00274 DOSDS1       Laufwerk 1
0113 00275 DOSF2L       Länge des Filenamens 2
0114 00276 DOSDS2       Laufwerk 2
0115 00277 DOSF2A       Adresse des Filenamens 2
0117 00279 DOSOFL       BLOAD/BSAVE Startadresse
0119 00281 DOSOFH       BSAVE Endadresse
011B 00283 DOSLA        Logische Adresse
011C 00284 DOSFA        Physikalische Adresse
011D 00285 DOSSA        Sektoradresse
011E 00286 DOSRCL       Record Länge
011F 00287 DOSBNK
0120 00288 DOSDID       Laufwerks Identifizierung
0122 00290 DIDCHK       Flag: Arbeit beendet

[SEITE H-17 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Die folgenden Adressen werden bei PRINT USING benutzt

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0123 00291 BNR          Zeiger auf Beginn
0124 00292 ENR          Zeiger auf Ende
0125 00293 DOLR         Dollar Flag
0126 00294 FLAG         Komma Flag
0127 00295 SWE          Zähler
0128 00296 USGN         Vorzeichen Exponent
0129 00297 UEXP         Zeiger auf Exponent
012A 00298 VN           Anzahl der Zahlen vor dem Dezimalpunkt
0128 00299 CHSN         Justierungs-Flag
012C 00300 VF           Anzahl der Positionen vor dem Dezimalpunkt
012D 00301 NF           Anzahl der Positionen nach dem Dezimalpunkt
012E 00302 POSP         +/-Flag (Feld)
012F 00303 FESP         Exponent-Flag (Feld)
0130 00304 ETOF         Schalter
0131 00305 CFORM        Zeichenzähler (Feld)
0132 00306 SNO          Vorzeichennummer
0133 00307 BLFD         Space/Stern-Flag
0134 00308 BEGFD        Zeiger auf Anfang des Feldes
0135 00309 LFOR         Länge des Formatstrings
0136 00310 ENDFD        Zeiger auf Ende des Feldes

0137 00311 SYSSTK       System-Stack

0200 00512 BUF          Basic/Monitor-Puffer

02FC 00764 ESC-FN-VEC   Vektor für zusätzliche Funktions-Routinen

02FE 00766 BNKVEC       Vektor für Funktion-Cartridge

[SEITE H-18 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung

Indirekte RAM-Zeiger (Basic)

0300 00768 IERROR       Fehler Routine (Fehler in X)
0302 00770 IMAIN        Vektor: Basic-Warmstart
0304 00772 ICRNCH       Token-Umwandlungsroutine
0306 00774 IQPLOP       Vektor: Basic-Text listen
0308 00776 IGONE        Vektor: Basic-Befehl ausführen
030A 00778 IEVAL        Token auswerten
030C 00780 IESCLK       Escape-Umwandlungsroutine
030E 00782 IESCPR       Escape List
0310 00784 IESCEX       Escape ausführen

Indirekte Kernal-Vektoren

0312 00786 ITIME        Interruptvektor TIME
0314 00788 IIRQ         IRQ Ram-Vektor
0316 00790 IBRK         BRK-Ram-Vektor
0318 00792 INMI         NMI-Ram-Vektor
031A 00794 IOPEN
031C 00796 ICLOSE
031E 00798 ICHKIN
0320 00800 ICHKOUT
0322 00802 ICLRCH
0324 00804 IBASIN
0326 00806 IBASOUT
0328 00808 ISTOP
032A 00810 IGETIN
032C 00812 ICLALL
032E 00814 EXMON        Indirekter Sprung MONITOR
0330 00816 ILOAD
0332 00818 ISAVE

[SEITE H-19 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
Unterprogramme für indirektes Laden (Aus jeder Bank)

039F 00927 IND-SUB-RAMO Unterprogramm zum Laden aus beliebiger Bank (PCRA und
                        PCRC vorbesetzen)
03AB 00939 IND-SUB-RAM1 S.o. PCRB und PCRD vorbesetzen
0387 00951 INDIN1-RAM1  S.o. Zero-Page-Indirekt $24
03C0 00960 INDIN2       S.o. PCRA und PCRC $26
03C9 00969 INDTXT       S.o. $3D
03D2 00978 ZERO         Konstante für Basic

03D5 00981 CURRENT BANK Register für Bank bei PEEK, SYS, POKE Befehlen
03D6 00982 TMPDES       Temporäre Register
03DA 00986 FIN-BANK     Bank-Zeiger für Zahl/String-Umwandlung
03DB 00987 SAVSIZ       Temporärer Speicher für SSHAPE
03DF 00991 BITS
03E0 00992 SPRTMP-1     Temporärer Speicher für SPRSAV
03E1 00993 SPRTMP-2
03E2 00994 FG-BG        Vordergrund/Hintergrund Farb-Nibble (Gepackt)
03E3 00995 FG-MC1       Vordergrund/Multicolor 1 Nibble (Gepackt)
0400 01024 VICSCN       Bildschirmspeicher 40-Zeichen
0800 02048              Basic-Run-Time-Stack (512 Byte)
0A00 02560 SYSTEM       Restart Vektor (Basic Warmstart)
0A02 02562 DEJAVU       Kernal Warm/Kalt-Start
                        Statusbyte
0A03 02563 PALNTS       PAL/NTSC System-Flag
0A04 02564 INIT-STATUS  Flag: Reset/Nmi Status

[SEITE H-20 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0A05 02565 MEMSTR       Zeiger auf Anfang des verfügbaren Speichers in der
                        System-Bank
0A07 02567 MEMSIZ       S.o. Ende
0A09 02569 IRQTMP       Indirekter IRO-Vektor (Kassette)
0A0B 02571 CASTON       Zeitvergleich bei Kassetten-Operationen
0A0C 02572 KIKA26       Temporärer Speicher beim Kassette-Lesen
0A0D 02573 STUPID       Temporärer Speicher Kassette Lesen
0A0E 02574 TIMOUT       Timeout-Flag (Fast Serial)
0A0F 02575 ENABL        RS-232 Enable
0A10 02576 M5lCTR       RS-232 Control Register
0A11 02577 M51CDR       RS-232 Command Register
0A12 02578 M5lAJB       RS-232 Baud-Rate
0A14 02580 RSSTAT       RS-232 Status Register
0A15 02581 BITNUM       RS-232 Wortlänge
0A16 02582 BAUDOF       Zwischenspeicher Baud-Rate
0A18 02584 RIDBE        RS-232 Zeiger auf Ende des Eingabepuffers
0A19 02585 RIDBS        RS-232 Zeiger auf Start des Eingabepuffers
0A1A 02586 RODBS        RS-232 Zeiger auf Start des Ausgabepuffers
0A1B 02587 RODBE        RS-232 Zeiger auf Ende des Ausgabepuffers
0A1C 02588 SERIAL       Intern/Extern-Flag (Fast Serial)
0A1D 02589 TIMER        Zwischenspeicher Echtzeituhr
0A20 02592 XMAX         Größe Tastatur-Warteschlange
0A21 02593 PAUSE        Flag für Ctrl-S

[SEITE H-21 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
VIC=40-Zeichen-Video-Controller, VDC=80-Zeichen-Video-Controller

0A22 02594 RPTFLG       Ermöglicht Tasten-Wiederholung $80=alle Tasten,
                        $40=keine Taste, $00 nur Cursortasten/DEL/INST
0A23 02595 KOUNT        Zähler für Verzögerung bei Tasten-Wiederholung
0A24 02596 DELAY        Zähler für Verzögerung bis zum Einsetzen der Tasten-
                        Wiederholung
0A25 02597 LSTSHF       Zähler für Verzögerung bei Commodore-Shift
0A26 02598 BLNON        VIC: Cursor-Modus $40=fester Cursor
0A27 02599 BLNSW        VIC: Hilfsregister
0A28 02600 BLNCT        VIC: Hilfsregister
0A29 02601 GDBLN        VIC: Cursorzeichen vor den Blinken
0A2A 02602 GDCOL        VIC: Cursorfarbe vor dem Blinken
1000 04096 PKYBUF       Bereich für die programmierbaren Funktionstasten. Die
                        ersten 10 Byte geben jeweils die Länge der jeweiligen
                        Strings an. Belegbar sind: F1-F8, Shift-Run, Help
100A 04106 PKYDEF       Bereich für die, den Funktionstasten zugeordneten
                        Strings
1100 04352 DOSSTR       Bereich für DOS-String

[SEITE H-22 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
Bereich für Grafik

1131 04401 VWORK
1131 04401 XYPOS
1131 04401 XPOS         Aktuelle X-Position
1133 04403 YPOS         Aktuelle Y-Position
1135 04405 XDEST        X-Koordinate Ziel
1137 04407 YDEST        Y-Koordinate Ziel

Linie zeichnen

1139 04409 XYABS
1139 04409 XABS
1138 04411 YABS
113D 04413 XYSGN
113D 04413 XSGN
113F 04415 YSGN
1141 04417 FCT
1145 04421 ERRVAL
1147 04423 LESSER
1148 04424 GREATR

Variablen für Winkel-Routinen

1149 04425 ANGSGN       Vorzeichen Winkel
114A 04426 SINVAL       Sinus des Winkels
114C 04428 COSVAL       Cosinus des Winkels
114E 04430 ANGCNT       Temporäres Register für Winkelabstand

Variablen für CIRCLE-Befehl

1150 04432 XCIRC1       Kreismitte, X-Koordinate
1152 04434 YCIRC1       Kreismitte, Y-Koordinate
1154 04436 XRADUS       X-Radius
1156 04438 YRADUS       Y-Radius

[SEITE H-23 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
0A2B 02603 CURMOD       VDC: Cursormodus: $80=fest, $60=normal blinkend,
                        $40=schnell blinkend, $20=Aus
0A2C 02604 VM1          VIC: Text-Basiszeiger
0A2D 02605 VM2          VIC: Bit-Map-Basiszeiger
0A2E 02606 VM3          VDC: Text-Basiszeiger
0A2F 02607 VM4          VDC: Attribute-Basiszeiger
0A30 02608 LINTMP       Temporärer Zeiger auf letzte Zeile
0A31 02609 SAV80A       VDC: Temporäres Register
0A32 02610 SAV80B       VDC: Temporäres Register
0A33 02611 SAV80C       VDC: Temporäres Register
0A34 02612 SAV80D       VDC: Temporäres Register
0A35 02613 CURCOL       VDC: Cursorfarbe vor dem Blinken
0A36 02614 SPLIT        VIC: Splitscreen Raster-Wert
0A37 02615 FNADRX       Zwischenspeicher während Bankoperationen
0A38 02616 PALCNT       Hilfszähler für Echtzeituhr bei PAL-System

Systemadressen, die vom MONITOR benutzt werden:

0A80 02688 XCNT         Puffervergleich
0AA0 02720 HULP
0AAA 02730 FORMAT
0AAB 02731 LENGTH       Disassembler/Assembler
0AAC 02732 MSAL         Für Assembler
0AAF 02734 SXREG        Temporär
0AB0 02735 SYREG        Temporär
0AB1 02736 WRAP         Temporär für Assembler
0AB2 02737 XSAVE        X-Register bei indirekten Unterprogramm-Aufrufen
                        sichern
0AB3 02738 DIRECTION    Richtungsanzeige für Transfer
0AB4 02739 TEMPS

0AC0 02752 CURBNK       Aktuelle Funktionstasten ROM-Bank

0AC1 02753 PAT          Physikalische Adressen (Tabelle)

[SEITE H-24 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
0B00 02816 TBUFFR       Kassettenpuffer und Puffer für
                        BOOT-Sektor
0C00 03072 R52331       RS-232 Eingabepuffer
0D00 03328 R52320       RS-232 Ausgabepuffer

0E00 03584              Bereich für Sprite-Definitionen ($E00-$FFF)
1158 04440 ROTANG       Drehwinkel
115C 04444 ANGBEG       Kreissegment-Winkel Start
115E 04446 ANGEND       Kreissegment-Winkel Ende
1160 04448 XRCOS        X-Radius * Cosinus des Drehwinkels
1162 04450 YRSIN        Y-Radius * Sinus des Drehwinkels
1164 04452 XRSIN        X-Radius * Sinus des Drehwinkels
1166 04454 YRCOS        Y-Radius * Cosinus des Drehwinkels

Allgemein benutzte Grafikvariablen (Mehrfach definiert)

1150 04432 XCENTR
1152 04434 YCENTR
1154 04436 XDIST1
1156 04438 YDIST1
1158 04440 XDIST2
115A 04442 YDIST2
115C 04444 DISEND
115E 04446 COLCNT       Für CHAR-Befehl
115F 04447 ROWCNT       Für CHAR-Befehl
1160 04448 STRCNT       Für CHAR-Befehl

[SEITE H-25 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
Variablen für BOX-Befehl

1150 04432 XCORD1       Punkt 1 X-Koordinate
1152 04434 YCORD1       Punkt 1 Y-Koordinate
1154 04436 BOXANG       Drehwinkel
1156 04438 XCOUNT
1158 04440 YCOUNT
115A 04442 BXLENG       Länge einer Seite
115C 04444 XCORD2       Punkt 2 X-Koordinate
115E 04446 YCORD2       Punkt 2 Y-Koordinate

Variablen für SSHAPE/GSHAPE

1151 04433 LEYLEN
1152 04434 KEYNXT
1153 04435 STRSZ        Länge der Stringvariablen
1154 04436 GETTYP       Shape-Modus setzen
1155 04437 STRPTR       Zähler für Stringposition
1156 04438 OLDBYT       Altes Bit-Mapped-Byte
1157 04439 NEWBYT       Variable für neuen String oder Bit-Mapped-Byte
1159 04441 XSIZE        Shape, Länge in X-Richtung
1158 04443 YSIZE        Shape, Länge in Y-Richtung

Variablen für SSHAPE/GSHAPE

115D 04445 XSAVE        Temporärer Speicher (XSIZE)
115F 04447 STRADR       Speicher für Shape/String Deskriptor
1161 04449 BITIDX       Zeiger auf ein Bit in einem Byte

[SEITE H-26 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
Grafikvariablen allgemein

1168 04456 CHRPAG       High-Byte einer Character-Room Adresse für CHAR-Befehl
1169 04457 BITCNT       Register für GSHAPE
116A 04458 SCALEM       SCALE-Modus-Flag
1168 04459 WIDTH        Flag für doppelte Pixel-Größe
116C 04460 FILFLG       Flag für Ausmalen eines Rechtecks (BOX-Befehl)
116D 04461 BITMSK       Temporärer Speicher für Bitmaske
116E 04462 NUMCNT
116F 04463 TRCFLG       Flage für Trace-Modus

1170 04464 RENUM-TMP-1  Temporärer Speicher für RENUMBER
1172 04466 RENUM-TMP-2  Temporärer Speicher für RENUMBER
1174 04468 T3
1175 04469 T4
1177 04471 VTEMP3       Temporärer Speicher für Grafik
1178 04472 VTEMP4       S.o.
1179 04473 VTEMP5       S.o.

117A 04474 ADRAY1       Zeiger auf Konvertierungsroutine Gleitkomma nach
                        Integer
117C 04476 ADRAY2       S.o. Integer nach Fließkomma

117E 04478 SPRITE-DATA  Tabelle für Geschwindigkeit und Richtung der Sprites
11D6 04566 VIC-SAVE     Temporärer Speicher für VIC- Register

Allgemeiner Bereich für Basic

1200 04608 OLDLIN       Vorhergehende Basic-Zeilennummer
1202 04610 OLDTXT       Zeiger auf Basicbefehl (Für CONTINUE)

[SEITE H-27 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
------------------------------------------------------------------------------
Festlegungen für PRINT USING

1204 04612 PUCHRS
1204 04612 PUFILL       Füllzeichen bei PRINT- USING (Standard: Space)
1205 04613 PUCOMA       Kommasymbol
1206 04614 PUDOT        Dezimalpunkt-Symbol
1207 04615 PUMONY       Währungszeichen
1208 04616 ERRNUM       Letzte Fehlernummer
1209 04617 ERRLIN       Zeilennummer in der der letzte Fehler auftrat,
                        $FFFF=kein Fehler
1208 04619 TRAPNO       Verweis auf Zeilennummer für ON ERROR GOTO
120D 04621 TMPTRP       Temporäres Register für TRAP
120E 04622 ERRTXT
1210 04624 TEXT-TOP     Zeiger auf Ende Basic-Text
1212 04626 MAX-MEM-0    Höchste für Basic verfügbare Adresse in Bank 0
1214 04628 TMPTXT       Wird bei einer D0-Schleife benutzt
1216 04630 TMPLIN
1218 04632 USRPOK
1218 04634 RNDX
1220 04640 CIRCLE-      Winkel pro Kreissegment
           SEGMENT
1221 04641 DEJAVU       Reset-Status (Kalt/Warm)

Variablen für Musikbefehle

1222 04642 TEMPO-RATE
1223 04643 VOICES
1229 04649 NTIME
1228 04651 OCTAVE
122C 04652 SHARP
122D 04653 PITCH
122F 04655 VOICE
1230 04656 WAVEO
1233 04659 DNOTE

[SEITE H-28 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label         Bedeutung
------------------------------------------------------------------------------
1234 04660 FLTSAV
1238 04664 FLTFLG
1239 04665 NIBBLE
123A 04666 TONNUM
1238 04667 TONVAL
123E 04670 PARCNT
123F 04671 ATKTAB
1249 04681 SUSTAB
1253 04691 WAVTAB
125D 04701 PULSLW
1267 04711 PULSHI
1271 04721 FILTERS

1276 04726 INT-TRIP-FLAG Interrupt Flag
1279 04729 INT-ADR-LO    Interrupt Flag
127C 04732 INT-ADR-HI    Interrupt Flag
127F 04735 INTVAL
1280 04736 COLTYP

Variablen für SOUND-Befehl

1281 04737 SOUND-VOICE
1282 04738 SOUND-TIME-LO
1285 04741 SOUND-TIME-HI
1288 04744 SOUND-MAX-LO
1288 04747 SOUND-MAX-HI
128E 04750 SOUND-MIN-LO
1291 04753 SOUND-MIN-HI
1294 04756 SOUND-DIRECTION
1297 04759 SOUND-STEP-LO
129A 04762 SOUND-STEP-HI
129D 04765 SOUND-FREQ-LO
12A0 04768 SOUND-FREQ-HI
12A3 04771 TEMP-TIME-LO
12A4 04772 TEMP-TIME-HI
12A5 04773 TEMP-MAX-LO
12A6 04774 TEMP-MAX-HI

[SEITE H-29 * ORGANISATION DER ZERO PAGE]

C128 Systemadressen

Adresse:
Hex. Dez.  Label         Bedeutung
------------------------------------------------------------------------------
12A7 04775 TEMP-MIN-LO
12A8 04776 TEMP-MIN-HI
12A9 04777 TEMP-DIRECTION
12AA 04778 TEMP-STEP-LO
12AB 04779 TEMP-STEP-HI
12AC 04780 TEMP-FREO-LO
12AD 04781 TEMP-FREQ-HI
12AE 04782 TEMP-PULSE-LO
12AF 04783 TEMP-PULSE-HI
1280 04784 TEMP-WAVEFORM
1281 04785 POT-TEMP-1    Temporäres Register für POT
1282 04786 POT-TEMP-2    Temporäres Register für POT
1283 04787 WINDOW-TEMP   Temporäres Register für Window-Befehl
1287 04791 SAVRAM        Register für SPRDEF
12FA 04858 DEFMOD        Register für SPRDEF
12FB 04859 LINCNT        Register für SPRDEF
12FC 04860 SPRITE-NUMBER Register für SPRDEF

1300 04864 Unbenutzter Ram-Bereich ($1300-$l7FF)
1800 06144 Reservierter Ram-Bereich ($1800-$BFF) für Function-Key-Software
1C00 07168 Video-Matrix, Bitmap-Color, wenn Grafik benutzt wird
1C00 07168 Start Basic-Text (Ohne Grafik, Standardwert MEMTOP)
2000 08192 VIC Bitmap (8KByte, wenn Grafik benutzt wird)
4000 16384 Start Basic-Text bei Grafik

[SEITE H-30 * ORGANISATION DER ZERO PAGE]

C128 I/0-Systemadressen

Adresse:
Hex. Dez.  Label        Bedeutung
D000 53248 VICCHR       Character Rom
D000 53248 VICREG       VIC Register
D400 54272 SIDREG       SID Register
D500 54528 MMU-LO       Register der MMU im I/0-Bereich
D600 54784 VDC          80-Zeichen Videochip (VDC)
D800 55296 VICCOL       VIC Color-Nibble
DC00 56320 CIA1         6526 1
DD00 56576 CIA2         6525 2
DE00 56832 I01          Expansion I/0-Slot
DF00 57088 I02          Expansion I/0-Slot (Reserviert für optimalen DMA-
                        Controller)

FF00 65280 MMU-HI       Register der MMU im Common-Bereich

*****************************
*     [ANHANG I]:           *
*                           *
*     BASIC-Abkürzungen     *
*****************************

[SEITE I-1 * BASIC-ABKÜRZUNGEN]

ABKÜRZUNGEN DER BASIC SCHLÜSSELWÖRTER

Damit Sie beim Eintippen Ihrer Programme und Direktkommandos Zeit sparen
können, dürfen Sie die meisten Schlüsselwörter im BASIC 2.0 (C64-Modus)
abkürzen. Die Abkürzung für PRINT ist das Fragezeichen. Die Abkürzungen für
andere Schlüsselwörter werden gebildet, indem man die ersten ein oder zwei
Zeichen eintippt und das nächste Zeichen des Wortes mit SHIFT eingibt. Werden
die Abkürzungen in Programmzeilen benutzt, gibt LIST die Schlüsselwörter in
der ausgeschriebenen Form aus. Beachten Sie, daß Abkürzungen für einige
Schlüsselwörter bereits eine linke Klammer mit einschließen.

             Befehl      Abkürzung   |   Befehl      Abkürzung
             ------------------------+------------------------
             ABS       A {SHIFT} B   |   FOR       F {SHIFT} O
             AND       A {SHIFT} N   |   FRE       F {SHIFT} R
             ASC       A {SHIFT} S   |   GET       G {SHIFT} E
             ATN       A {SHIFT} T   |   GOSUB    GO {SHIFT} S
             CHR$      C {SHIFT} H   |   GOTO      G {SHIFT} O
             CLOSE    CL {SHIFT} 0   |   INPUT#    I {SHIFT} N
             CLR       C {SHIFT} L   |   LET       L {SHIFT} E
             CMD       C {SHIFT} M   |   LEFT$    LE {SHIFT} F
             CONT      C {SHIFT} O   |   LIST      L {SHIFT} I
             DATA      D {SHIFT} A   |   LOAD      L {SHIFT} 0
             DEF       D {SHIFT} E   |   MID$      M {SHIFT} I
             DIM       D {SHIFT} I   |   NEXT      N {SHIFT} E
             END       E {SHIFT} N   |   NOT       N {SHIFT} O
             EXP       E {SHIFT} X   |   OPEN      O {SHIFT} P

[SEITE I-2 * BASIC-ABKÜRZUNGEN]

             Befehl      Abkürzung   |   Befehl      Abkürzung
             ------------------------+------------------------
             PEEK      P {SHIFT} E   |   SPC(      S {SHIFT} P
             POKE      P {SHIFT} O   |   SQR       S {SHIFT} Q
             PRINT     ?             |   STEP     ST {SHIFT} E
             PRINT#    P {SHIFT} R   |   STOP      S {SHIFT} T
             READ      R {SHIFT} E   |   STR$     ST {SHIFT} R
             RESTORE  RE {SHIFT} S   |   SYS       S {SHIFT} Y
             RETURN   RE {SHIFT} T   |   TAB       T {SHIFT} A
             RIGHT$    R {SHIFT} I   |   THEN      T {SHIFT} H
             RND       R {SHIFT} N   |   USR       U {SHIFT} S
             RUN       R {SHIFT} U   |   VAL       V {SHIFT} A
             SAVE      S {SHIFT} A   |   VERIFY    V {SHIFT} E
             SGN       S {SHIFT} G   |   WAIT      W {SHIFT} A
             SIN       S {SHIFT} I   |

[SEITE I-3 * BASIC-ABKÜRZUNGEN]

Abkürzungen der Basic-Schlüsselwörter (Basic 7.0), die im Basic des C64 nicht
enthalten sind.

Befehl         Abkürzung
------------------------------------------------------------------------------
APPEND         A    {SHIFT} P
AUTO           A    {SHIFT} U
BACKUP         BA   {SHIFT} C
BANK           B    {SHIFT} A
BEGIN          B    {SHIFT} E
BEND           BE   {SHIFT} N
BLOAD          B    {SHIFT} L
BOOT           B    {SHIFT} O
BOX                  KEINE
BSAVE          B    {SHIFT} S
BUMP           B    {SHIFT} U
CATALOG        C    {SHIFT} A
CHAR           CH   {SHIFT} A
CIRCLE         C    {SHIFT} I
COLLECT        COLL {SHIFT} E
COLLISION      CO   {SHIFT} L
COLOR          COL  {SHIFT} O
CONCAT         C    {SHIFT} O
COPY           CO   {SHIFT} P
DCLEAR         DCL  {SHIFT} E
DCLOSE         D    {SHIFT} C
DEC                  KEINE
DELETE         DE   {SHIFT} L
DIRECTORY      DI   {SHIFT} R
DLOAD          D    {SHIFT} L
DO                   KEINE
DOPEN          D    {SHIFT} O
DRAW           D    {SHIFT} R
DSAVE          D    {SHIFT} S
DVERIFY        D    {SHIFT} V
ENVELOPE       E    {SHIFT} N
FAST           F    {SHIFT} A
FETCH          F    {SHIFT} E
FILTER         F    {SHIFT} I
FRE            F    {SHIFT} R
GETKEY         GETK {SHIFT} E

[I-4]

Abkürzungen der Basic-Schlüsselwörter (Basic 7.0), die im Basic des C64 nicht
enthalten sind.

Befehl         Abkürzung
------------------------------------------------------------------------------
G064                 KEINE
GRAPHIC        G    {SHIFT} R
GSHAPE         G    {SHIFT} S
HEADER         HE   {SHIFT} A
HELP           HE   {SHIFT} L
HEX$           H    {SHIFT} E
IF                   KEINE
INSTR          IN   {SHIFT} S
JOY            J    {SHIFT} O
KEY            K    {SHIFT} E
LOCATE         LO   {SHIFT} C
MONITOR        MO   {SHIFT} N
MOVSPR         M    {SHIFT} O
PAINT          P    {SHIFT} A
PEN            P    {SHIFT} E
PLAY           P    {SHIFT} L
POINTER        PO   {SHIFT} I
POT            P    {SHIFT} O
PRINTUSING     ?US  {SHIFT} I
PUDEF          P    {SHIFT} U
RCLR           R    {SHIFT} C
RDOT           R    {SHIFT} D
RECORD         R    {SHIFT} E
RENAME         RE   {SHIFT} N
RENUMBER       REN  {SHIFT} U
RESTORE        RE   {SHIFT} S
RESUME         RES  {SHIFT} U
RGR                  KEINE
RREG           R    {SHIFT} R
RSPCOLOR       RSP  {SHIFT} C
RSPPOS         R    {SHIFT} S
RSPRITE        RSP  {SHIFT} R
RUN            R    {SHIFT} U
RWINDOW        R    {SHIFT} W
SCALE          SC   {SHIFT} A
SCNCLR         S    {SHIFT} C
SCRATCH        SC   {SHIFT} R

[SEITE I-5 * BASIC-ABKÜRZUNGEN]

Abkürzungen der Basic-Schlüsselwörter (Basic 7.0), die im Basic des C64 nicht
enthalten sind.

Befehl         Abkürzung
------------------------------------------------------------------------------
SLEEP          S    {SHIFT} L
SLOW           SL   {SHIFT} O
SOUND          S    {SHIFT} O
SPRCOLOR       SPR  {SHIFT} C
SPRDEF         SPR  {SHIFT} D
SPRITE         S    {SHIFT} P
SPRSAV         SPR  {SHIFT} S
SSHAPE         S    {SHIFT} S
STASH          S    {SHIFT} T
SWAP           S    {SHIFT} W
TEMPO          T    {SHIFT} E
TRAP           T    {SHIFT} R
TRON           TR   {SHIFT} O
TROFF          TRO  {SHIFT} F
VOL            V    {SHIFT} O
WIDTH          WI   {SHIFT} D
WINDOW         W    {SHIFT} I
XOR            X    {SHIFT} O

Anmerkung:
Sollten Sie Basic-Schlüsselwörter der Version 2.0 des C64 im C128-Modus
benutzen, ergeben sich folgende Änderungen:

Keine Abkürzungen möglich für:

CONT
END
SPC
SYS

Neue Abkürzungen ergeben sich für:

PEEK           PE   {SHIFT} E
POKE           PO   {SHIFT} K
READ           RE   {SHIFT} A
STOP           ST   {SHIFT} O

*********************************************
*     [ANHANG J]:                           *
*                                           *
*     Definition von Tastaturbelegungen     *
*********************************************

[SEITE J-1 * DEFINITION VON TASTATURBELEGUNGEN]

ANHANG J: DEFINITION VON TASTATURBELEGUNGEN

Wie bereits im Kapitel 4.1 bei der Beschreibung der ALT-Taste erwähnt, kann
mit dieser Taste eine anwenderspezifische Tastaturbelegung gewählt werden.

Die ALT-Taste arbeitet prinzipiell genauso wie die SHIFT-, C= - oder CTRL-
Taste. Wird sie gleichzeitig mit einer weiteren Taste gedrückt, so wird dieser
zweiten Taste ein anderer Code zugeordnet. Die den Tasten selbst oder mit der
ALT-, SHIFT-, C= -, oder CTRL-Taste modifiziert zugeordneten Codes sind in
sogenannten Tastaturtabellen im Speicher abgelegt, wobei standardmäßig die
Tabelle für die mit der ALT-Taste modifizierten Tasten dieselbe ist, wie die
für die nichtmodifizierten (ohne SHIFT) Tasten. Daher zeigt das Drücken der
ALT-Taste zusammen mit einer anderen Taste zunächst keine andere Wirkung, als
wenn die Taste alleine gedrückt würde. Jeder Taste der Tastatur mit Ausnahme
der SHIFT-, C= (Commodore)-, ALT-, RESTORE-, ASCII/DIN-, 40/80 DISPLAY- und
NO SCROLL-Tasten ist ein Platz in der Tastaturtabelle zugeordnet. Der Code,
der an dieser Stelle gespeichert ist, bestimmt, welches Zeichen beim Drücken
der zugehörigen Taste angezeigt oder zugeordnet wird.

In der folgenden Tabelle ist die Zuordnung von Tabellenplatz, Taste und Code
für die Originaltastaturtabelle der ASCII-Tastatur aufgeführt.


Platz     Taste                                Code
                                               hex        dez
 1        DEL                                   14         20
 2        RETURN                                OD         13
 3        CRSR rechts                           1D         29
 4        Funktionstaste f7                     88        136
 5        Funktionstaste f1                     85        133
 6        Funktionstaste f3                     86        134
 7        Funktionstaste f5                     87        135
 8        CRSR unten                            11         17
 9        3                                     33         51
10        w                                     57         87
11        a                                     41         65


[SEITE J-2 * DEFINITION VON TASTATURBELEGUNGEN]

Tastaturtabelle (Fortsetzung)

Platz     Taste                                Code
                                               hex        dez
12        4                                     34         52
13        z                                     5A         90
14        s                                     53         83
15        e                                     45         69
16        reserviert (muß 1 enthalten)          01          1
17        5                                     35         53
18        r                                     52         82
19        d                                     44         68
20        6                                     36         54
21        c                                     43         67
22        f                                     46         70
23        t                                     54         84
24        x                                     58         88
25        7                                     37         55
26        y                                     59         89
27        g                                     47         71
28        8                                     38         56
29        b                                     42         66
30        h                                     48         72
31        u                                     55         85
32        v                                     56         86
33        9                                     39         57
34        i                                     49         73
35        j                                     4A         74
36        0                                     30         48
37        m                                     4D         77
38        k                                     4B         75
39        0                                     4F         79
40        n                                     4E         78
41        +                                     2B         43
42        p                                     50         80
43        |                                     4C         76
44        -                                     2D         45
45        .                                     2E         46
46        :                                     3A         58
47        @                                     40         64
48        ,                                     2C         44
49        \                                     5C         92
50        *                                     2A         42


[SEITE J-3 * DEFINITION VON TASTATURBELEGUNGEN]

Tastaturtabelle (Fortsetzung)

Platz        Taste                                        Code
                                               hex        dez
51        ;                                     3B         59
52        HOME                                  13         19
53        reserviert (muß 1 enthalten)          01          1
54        =                                     3D         61
55        ^                                     5E         94
56        /                                     2F         47
57        1                                     31         49
58        -                                     5F         95
59        reserviert (muß 4 enthalten)          04          4
60        2                                     32         50
61        Leertaste                             20         32
62        reserviert (muß 2 enthalten)          02          2
63        q                                     51         81
64        STOP                                  03          3
65        HELP                                  84        132
66        8 (Zehnertastatur)                    38         56
67        5 (Zehnertastatur)                    35         53
68        TAB                                   09          9
69        2 (Zehnertastatur)                    32         50
70        4 (Zehnertastatur)                    34         52
71        7 (Zehnertastatur)                    37         55
72        1 (Zehnertastatur)                    31         49
73        ESC                                   1B         27
74        + (Zehnertastatur)                    2B         43
75        - (Zehnertastatur)                    2D         45
76        LINE FEED                             OA         10
77        ENTER (Zehnertastatur)                OD         13
78        6 (Zehnertastatur)                    36         54
79        9 (Zehnertastatur)                    39         57
80        3 (Zehnertastatur)                    33         51
81        reserviert (muß 8 enthalten)          08          8
82        0 (Zehnertastatur)                    30         48
83        . (Zehnertastatur)                    2E         46
84        CRSR oben (Cursor-Einzeltaste)        91        145
85        CRSR unten (Cursor-Einzeltaste)       11         17
86        CRSR links (Cursor-Einzeltaste)       9D        157
87        CRSR rechts (Cursor-Einzeltaste)      1D         29
88        reserviert (muß 255 enthalten)        FF        255
89        reserviert (muß 255 enthalten)        FF        255


[SEITE J-4 * DEFINITION VON TASTATURBELEGUNGEN]

Wenn Sie nur wenige Tastenbelegungen ändern wollen, ist es am einfachsten, die
Originaltabelle, die im ROM liegt, in den RAM-Bereich unterhalb der Adresse
$4000 (16384 dezimal) zu kopieren. Dies können Sie z.B. für die ASCII-Origi-
naltabelle mit Hilfe des T-Befehls des Monitors (s.a. Anhang C) folgender-
maßen erreichen:

T FFA8O FFAD8 03FA7

Danach ändern Sie entweder mit Hilfe von POKE-Befehlen oder des Monitors die
Tabelle nach Ihren eigenen Wünschen ab. Die Originaltabellen für die beiden
verfügbaren Tastaturen (ASCII und DIN) sowie die Umschalttasten C= , SHIFT
und CTRL liegen im ROM bei folgenden Adressen:

Tabelle                        Adresse hex      Adresse dez

Normaltabelle      ASCII       FFA8O            Bank 15, 64128
Normaltabelle      DIN         FFD29            Bank 15, 64809
SHIFT-Tabelle      ASCII       FFAD9            Bank 15, 64217
SHIFT-Tabelle      DIN         FFD82            Bank 15, 64898
C= -Tabelle        ASCII       FFB32            Bank 15, 64306
C= -Tabelle        DIN         FFDDB            Bank 15, 64987
CTRL-Tabelle                   FFB8B            Bank 15, 64395

Haben Sie die Tabelle nach Ihren Wünschen geändert, so müssen Sie noch den
Adreßzeiger der Tastatur-Betriebssystemroutine für die ALT-Taste so ändern,
daß er auf den Anfang Ihrer Tabelle zeigt. Der Zeiger steht im RAM bei der
Adresse $346,$347 (838,839 dezimal). Haben sie Ihre Tabelle z.B. wie auf der
letzten Seite angegeben, ab der Speicheradresse $3FA7 (16295 dez) abgelegt,
so können Sie den Adreßzeiger für die ALT-Taste folgendermaßen einstellen:

BANK 0
POKE 838,16295-int(16295/256)*256        (niederwert. Teil)
POKE 839,int(16295/256)                  (höherwert. Teil)

In die Speicherzelle mit der Adresse 838 wird der niederwertige und in die mit
der Adresse 839 der höherwertige Teil der Gesamtadresse eingetragen.

Auf dieselbe Art und Weise wie die ALT-Tastaturbelegung geändert wird, können
Sie auch die SHIFT-, C= -, und CTRL-Tastaturbelegung ändern.

[SEITE J-5 * DEFINITION VON TASTATURBELEGUNGEN]

Nachfolgend finden Sie die Adreßzeiger für alle Tastaturtabellen zusammen-
gestellt:

Tabelle            Adreßzeiger hex         Adreßzeiger dez
Normaltabelle      33E,33F                 830,831
SHIFT-Tabelle      340,341                 832,833
C= -Tabelle        342,343                 834,835
CTRL-Tabelle       344,345                 836,837
ALT-Tabelle        346,347                 838,839

**************************************************
*     [ANHANG K]:                                *
*                                                *
*     Umschreibung transzendenter Funktionen     *
**************************************************

[SEITE K-1 * UMSCHREIBUNGEN TRANSZENDENTER FUNKTIONEN]

ANHANG K: UMSCHREIBUNG TRANSZENDENTER FUNKTIONEN]

Einige der trigonometrischen, zyklometrischen und alle Hyperbelfunktionen sind
nicht Bestandteil des CBM-BASIC und müssen daher wie folgt berechnet werden:

Funktion                        Umschreibung in CBM-BASIC

Logarithmus zur Basis B         LOG(X)/LOG(B)
Sekans                          1/COS(X)
Cosekans                        1/SIN(X)
Cotangens                       1/TAN(X)
Arcussinus                      ATN(X/SQR(1-X^2))
Arcuscosinus                    1.570796-ATN(X/SQR(1-X^2))
Arcussecans                     ATN(SQR(X^2-1))
                                +(X<0)*3.141593
Arcuscosecans                   ATN(1/SQR(X^2-1))
                                +(X<0)*3.141593
Arcuscotangens                  1.570796-ATN(X)
Sinus Hyperbolicus              (EXP(X)-EXP(-X))/2
Cosinus Hyperbolicus            (EXP(X)+EXP(-X))/2
Tangens Hyperbolicus            (EXP(X)-EXP(-X))
                                /(EXP(X)+EXP(-X))
Cotangens Hyperbolicus          (EXP(X)+EXP(-X))
                                /(EXP(X)-EXP(-X))
Sekans Hyperbolicus             2/(EXP(X)+EXP(-X))
Cosekans Hyperbolicus           2/(EXP(X)-EXP(-X))
Area Sinus Hyperbolicus         LOG(X+SQR(X^2+1))
Area Cos. Hyperbolicus          LOG(X+SQR(X^2-1))
Area Tan. Hyperbolicus          LOG((1+X)/(1-X))/2
Area Cot. Hyperbolicus          LOG((X+1)/(X-1))/2
Area Sec. Huperbolicus          LOG((SQR(-X^2+1)+1)/X)
Area Cosec. Hyperbolicus        LOG((SGN(X)*SQR(X^2+1)/X)

*****************************
*     [ANHANG L]:           *
*                           *
*     Steckerbelegungen     *
*****************************

[SEITE L-1 * STECKERBELEGUNGEN]

STECKERBELEGUNG DER EIN-/AUSGABE ANSCHLÜSSE

Dieser Anhang soll Ihnen zeigen, wie welches Gerät wo an den C128 angeschlos-
sen werden kann.

1) Steuereingänge für Spiele            4) Serielle E/A (Disk/Drucker)
2) Modul-Steckplatz                     5) Kassette
3) Audio/Video                          6) User Port


Control Port 1

  Pin| Signal      | Bem.
  ---+-------------+------------
   1 |    JOYA0    |
   2 |    JOYA1    |
   3 |    JOYA2    |
   4 |    JOYA3    |
   5 |    POT AY** |
   6 | BUTTON A/LP*|
   7 |     +5V     | MAX. 100mA
   8 |     GND     |
   9 |   POT AX**  |

                              -----------------------
                              \  1   2   3   4   5  /
                               \                   /
                                \  6   7   8   9  /
                                 \_______________/
Control Port 2

  Pin| Signal      | Bem.
  ---+-------------+------------
   1 |    JOYB0    |
   2 |    JOYB1    |
   3 |    JOYB2    |
   4 |    JOYB3    |
   5 |    POT BY** |
   6 |  BUTTON B   |
   7 |     +5V     | MAX. 100mA
   8 |     GND     |
   9 |   POT BX**  |

 *) Button = Feuerknopf am Joystick
    LP = Light pen
**) POT = Paddle Potentiometer


[SEITE L-2 * STECKERBELEGUNGEN]

Belegung der Videobuchsen des Commodore 128 Personal Computer

  Belegung der 40-Zeichen-Buchse

  Pin| Signal
  ---+-----------------------
   1 | LUMINANCE/SYNC
   2 | MASSE                           _______
   3 | AUDIO OUT                      /       \
   4 | VIDEO OUT                     /  8   7  \
   5 | AUDIO IN                      | 3  6  1 |
   6 | CHROMINANCE                   |  5   4  |
   7 | NICHT ANGESCHLOSSEN           \    2    /
   8 | 5 VOLT                         \_______/


  Belegung der 80-Zeichen-Videobuchse

  PIN        BEZEICHNUNG        BEMERKUNG

   1        Masse
   2        Masse
   3        Rot                TTL-Signal, 0-5 Volt
                        Rot-Teil des RGBI-Signals
   4        Grün                TTL-Signal, 0-5 Volt
                        Grün-Teil des RGBI-Signals
   5        Blau                TTL-Signal, 0-5 Volt
                        Blau-Teil des RGBI-Signals
   6        Intensität        TTL-Signal, 0-5 Volt
                        Intensitäts-Teil des RGBI-Signals
   7        Monochrome        1 Volt Uss, 15625 Hz Zeilenfrequenz
                        50 Hz vertikal (BAS)
   8        Hsync                TTL-Signal, 0-5 Volt
                        Horizontales Synchronsignal
   9        Vsync                TTL-Signal, 0-5 Volt
                        Vertikales Synchronsignal - 50 Hz


   -----------------------
   \  5   4   3   2   1  /
    \                   /
     \  9   8   7   6  /
      \_______________/

        Außenaufsicht


  Anschluß eines monochromen Monitors

80-Zeichen: 9-polige Sub-D-Buchse
Pin 7 = Signal, Pin 1 = Masse
Analogsignal 1 V Uss, 15625 Hz Zeilenfrequenz

40-Zeichen: (C64- bzw. C128-Modus)
8-polige DIN-Video-Buchse Pin 1 =
Luminanz (FBAS) Pin 2 = Masse

Audioanschluß: DIN-Video-Buchse Pin 3

[SEITE L-3 * STECKERBELEGUNGEN]

Modul-Steckplatz

Pin       Signal                     Pin      Signal

22        GND                         Z        GND
21        CD0                         Y        CA0
20        CD1                         X        CA1
19        CD2                         W        CA2
18        CD3                         V        CA3
17        CD4                         U        CA4
16        CD5                         T        CA5
15        CD6                         S        CA6
14        CD7                         R        CA7
13        /DMA                        P        CA8
12        BA                          N        CA9
11        /ROML                       M        CA10
10        / I/O 2                     L        CA11
 9        /EXROM                      K        CA12
 8        /GAME                       J        CA13
 7        / I/O 1                     H        CA14
 6        Dot Clock                   F        CA15
 5        CR/-W                       E        ø2
 4        /IRQ                        D        /NMI
 3        +5V                         C        /RESET
 2        +5V                         B        /ROMH
 1        GND                         A        GND


  22 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
 +==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==+
 |                                                                 |
 +==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==+
   Z  Y  X  W  V  U  T  S  R  P  N  M  L  K  J  H  F  E  D  C  B  A



Audio/Video
                                                      ____
Pin       Signal           Pin        Signal        /     \
 1        LUMINANCE         6        CHROMINANZ    / 8   7 \
 2        GND               7        O. BELEGUN   | 3  6  1 |
 3        AUDIO OUT         8        O. BELEGUNG  |  5   4  |
 4        VIDEO OUT                                \   2   /
 5        AUDIO IN                                  \_____/



Serielle E/A

Pin       Signal                                    _______
 1        SERIAL /SRQIN                            /       \
 2        GND                                     / 5     1 \
 3        SERIAL ATN IN/OUT                       |    6    |
 4        SERIAL CLK IN/OUT                       | 4     2 |
 5        SERIAL DATA IN/OUT                      \    3    /
 6        /RESET                                   \_______/


[SEITE L-4 * STECKERBELEGUNGEN]

Cassette

Pin        Signal
A-1        GND                     1   2   3   4   5   6
B-2        +5V                 +--===-===+===-===-===-===--+
C-3        CASSETTE MOTOR      |         |                 |
D-4        CASSETTE READ       +--===-===+===-===-===-===--+
E-5        CASSETTE WRITE          A   B   C   D   E   F
F-6        CASSETTE SENSE



User Port
   Pin        Signal                Bemerkung
    1        GND
    2        +5V DC                MAX. 100 mA
    3        /RESET
    4        CNT1
    5        SP1
    6        CNT2
    7        SP2
    8        /PC2
    9        SER. ATN IN
   10        9 VAC                MAX. 100 mA
   11        9 VAC                MAX. 100 mA
   12        GND
    A        GND
    B        /FLAG2
    C        PB0
    D        PB1
    E        PB2
    F        PB3
    H        PB4
    J        PB5
    K        PB6
    L        PB7
    M        PA2
    N        GND


      1   2   3   4   5   6   7   8   9   10  11  12
  +--===+===-===-===-===-===-===-===-===-===+===-===--+
  |     |                                   |         |
  +--===+===-===-===-===-===-===-===-===-===+===-===--+
      A   B   C   D   E   F   H   J   K   L   M   N

*********************************************************
*     [ANHANG M]:                                       *
*                                                       *
*     Übertragung von BASIC4-Programmen nach BASIC7     *
*********************************************************

[SEITE M-1 * ÜBERTRAGUNG VON BASIC4-PROGRAMMEN]

ANHANG M: UMWANDLUNG VON BASIC4 IN BASIC7-PROGRAMME

Programm zur Umsetzung von CBM 8000er-Programmen (BASIC 4.0) auf das BASIC 7.0
des C 128.

Es werden aber nur Befehlstokens umgesetzt, nicht jedoch PEEK-, POKE-, SYS-
und USR-Adressen; ebenfalls nicht die komplexen Cursor-Steuerzeichen des
BASIC 4.0.

Das Umsetzprogramm selbst ist in BASIC 2 geschrieben, es läuft damit auf jedem
beliebigen Commodore-Rechner.

  10 REM SAVE"0:4NACH7",8
  20 REM TOKEN-UMSETZUNG BASIC 4.0 NACH BASIC 7.0
  50 DIMA$,ZZ$,N$,FG:N$=CHR$(0):G$=CHR$(34)
 100 PRINT"DISKETTE IN DRIVE 0 LEGEN.
 105 PRINT"UMSETZUNG ERFOLGT VON DISKETTE ZU DISKETTE
 110 INPUT"8XXX-NAME =";N8$
 120 INPUT" 128-NAME =";N2$:IFN8$=N2$THEN120
 140 OPEN2,8,4,N2$:GET#2,A$,A$:S=ST:CLOSE2:REM TESTLESEN
 150 IFS=0THENPRINT"ZIELFILE EXISTIERT!":PRINT:GOTO120
 160 OPEN1,8,3,N8$:OPEN2,8,4,N2$+",P,W"
 170 GET#1,A$,B$:A8=ASC(A$+N$)+256*ASC(B$+N$):REM LADE-ADR
 180 A2=28*256+1:REM FUER 128: LADE-ADR = $1C01
 181 H2=INT(A2/256):PRINT#2,CHR$(A2-H2*256);CHR$(H2);
 190 DIMC$(256),ZN(256):REM TOKEN-UMSETZ-TABELLEN
 191 FORI=204TO256:READA$:IFA$="E"THENI=999:GOTO194
 192 ZN(I)=-(LEN(A$)>3):C$(I)=CHR$(VAL(LEFT$(A$,3)))
 193 IFZN(I)THENC$(I)=C$(I)+CHR$(VAL(RIGHT$(A$,3)))
 194 NEXT
 200 GET#1,A$,B$:B8=ASC(A$+N$)+256*ASC(B$+N$):REM CHAINING-POINTER
 201 N8=B8-A8:IFB8=0THENPRINT#2,N$;N$;:CLOSE1:CLOSE2:END:REM PROG-ENDE
 210 Z2=0:FG=-1:GET#1,A$:ZZ$=LEFT$(A$+N$,1):REM NEUE ZEILE IN ZZ$
 211 GET#1,B$:ZZ$=ZZ$+LEFT$(B$+N$,1):REM ZEILENNR. FERTIG
 215 PRINT"ZEILE";ASC(LEFT$(ZZ$,1))+256*ASC(RIGHT$(ZZ$,1))
 220 FORI=4TON8-2:GET#1,A$:IFA$=G$THENFG=NOTFG:REM FOR FUER ZEILE
 230 IFFGTHENA=ASC(A$):IFA>203ANDA<255THENA$=C$(A):Z2=Z2+ZN(A):REM UMCOD

[SEITE M-2 * ÜBERTRAGUNG VON BASIC4-PROGRAMMEN]

 240 ZZ$=ZZ$+A$:NEXT:GET#1,A$:ZZ$=ZZ$+N$:REM NULL AM ZEILENENDE
 250 A8=B8:A2=A2+N8+Z2:H2=INT(A2/256):REM CHAINING MITZAEHLEN
 260 PRINT#2,CHR$(A2-256*H2);CHR$(H2);ZZ$;:GOTO200:REM NEUE ZEILE
9000 REM CONCAT,DOPEN,DCLOSE,RECORD,HEADER,COLLECT
9010 DATA 254019,254013,254015,254018,241,243
9020 REM BACKUP,COPY,APPEND,DSAVE,DLOAD,CATALOG
9030 DATA 246,244,254014,239,240,254012
9040 REM RENAME,SCRATCH,DIRECTORY
9050 DATA 245,242,238,E


******************************************************************************

     BESCHEINIGUNG DES HERSTELLERS

Hiermit wird bestätigt, daß der Personal-Computer

     COMMODORE C 128

in Übereinstimmung mit den Bestimmungen der

     Amtsblattverfügung Nr. 1046/1984

funkentstört ist.

Der Deutschen Bundespost wurde das Inverkehrbringen dieses Gerätes angezeigt
und die Berechtigung zur Überprüfung der Serie auf Einhaltung der Bestimmungen
eingeräumt.

COMMODORE BÜROMASCHINEN GMBH


     CERTIFICATE OF THE MANUFACTURER

Herewith we certify that our device Personal-Computer

     COMMODORE C 128

corresponds to the regulations

     Amtsblattverfügung Nr. 1046/1984

is eliminated of radio interference.

The German Bundespost has been informed that this unit is on the market and
has got the right to check on the mass production if the limits are kept.

     COMMODORE BUSINESS MACHINES LIMITED
******************************************************************************

Commodore Büromaschinen GmbH
Lyoner Str. 38, 6000 Frankfurt 71
Tel. (0 69) 66 38-0, Telefax 66 38-1 59
Telex 4 125 663 commo d

Commodore AG
Langenhagstraße 1, CH-4147 Aesch
Tel. (0 61) 78 22 12, Twx. 64 961

Commodore Büromaschinen GmbH
Kinskygasse 40-44, A-1232 Wien,
Tel. (02 22) 67 56 00, Twx. 111 350

                               ____
                             /  ___|  ___
                            |  /     |__/
                            | |       __
                            |  \___  |__\
                             \ ____|

Art.-Nr.: 580128         C o m m o d o r e

*********

End of the iDOC= etext of the Commodre 128 User's Manual.

*********
